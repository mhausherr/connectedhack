/*! Babylon 2014-05-13 */
var BABYLON; !function (a) { var b = function () { function a(a, b, c) { "undefined" == typeof a && (a = 0), "undefined" == typeof b && (b = 0), "undefined" == typeof c && (c = 0), this.r = a, this.g = b, this.b = c } return a.prototype.toString = function () { return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}" }, a.prototype.toArray = function (a, b) { void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b }, a.prototype.asArray = function () { var a = []; return this.toArray(a, 0), a }, a.prototype.multiply = function (b) { return new a(this.r * b.r, this.g * b.g, this.b * b.b) }, a.prototype.multiplyToRef = function (a, b) { b.r = this.r * a.r, b.g = this.g * a.g, b.b = this.b * a.b }, a.prototype.equals = function (a) { return a && this.r === a.r && this.g === a.g && this.b === a.b }, a.prototype.scale = function (b) { return new a(this.r * b, this.g * b, this.b * b) }, a.prototype.scaleToRef = function (a, b) { b.r = this.r * a, b.g = this.g * a, b.b = this.b * a }, a.prototype.add = function (b) { return new a(this.r + b.r, this.g + b.g, this.b + b.b) }, a.prototype.addToRef = function (a, b) { b.r = this.r + a.r, b.g = this.g + a.g, b.b = this.b + a.b }, a.prototype.subtract = function (b) { return new a(this.r - b.r, this.g - b.g, this.b - b.b) }, a.prototype.subtractToRef = function (a, b) { b.r = this.r - a.r, b.g = this.g - a.g, b.b = this.b - a.b }, a.prototype.clone = function () { return new a(this.r, this.g, this.b) }, a.prototype.copyFrom = function (a) { this.r = a.r, this.g = a.g, this.b = a.b }, a.prototype.copyFromFloats = function (a, b, c) { this.r = a, this.g = b, this.b = c }, a.FromArray = function (b) { return new a(b[0], b[1], b[2]) }, a.FromInts = function (b, c, d) { return new a(b / 255, c / 255, d / 255) }, a.Lerp = function (b, c, d) { var e = b.r + (c.r - b.r) * d, f = b.g + (c.g - b.g) * d, g = b.b + (c.b - b.b) * d; return new a(e, f, g) }, a.Red = function () { return new a(1, 0, 0) }, a.Green = function () { return new a(0, 1, 0) }, a.Blue = function () { return new a(0, 0, 1) }, a.Black = function () { return new a(0, 0, 0) }, a.White = function () { return new a(1, 1, 1) }, a.Purple = function () { return new a(.5, 0, .5) }, a.Magenta = function () { return new a(1, 0, 1) }, a.Yellow = function () { return new a(1, 1, 0) }, a }(); a.Color3 = b; var c = function () { function b(a, b, c, d) { this.r = a, this.g = b, this.b = c, this.a = d } return b.prototype.addInPlace = function (a) { this.r += a.r, this.g += a.g, this.b += a.b, this.a += a.a }, b.prototype.asArray = function () { var a = []; return this.toArray(a, 0), a }, b.prototype.toArray = function (a, b) { void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a[b + 3] = this.a }, b.prototype.add = function (a) { return new b(this.r + a.r, this.g + a.g, this.b + a.b, this.a + a.a) }, b.prototype.subtract = function (a) { return new b(this.r - a.r, this.g - a.g, this.b - a.b, this.a - a.a) }, b.prototype.subtractToRef = function (a, b) { b.r = this.r - a.r, b.g = this.g - a.g, b.b = this.b - a.b, b.a = this.a - a.a }, b.prototype.scale = function (a) { return new b(this.r * a, this.g * a, this.b * a, this.a * a) }, b.prototype.scaleToRef = function (a, b) { b.r = this.r * a, b.g = this.g * a, b.b = this.b * a, b.a = this.a * a }, b.prototype.toString = function () { return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}" }, b.prototype.clone = function () { return new b(this.r, this.g, this.b, this.a) }, b.Lerp = function (c, d, e) { var f = new b(0, 0, 0, 0); return a.Color4.LerpToRef(c, d, e, f), f }, b.LerpToRef = function (a, b, c, d) { d.r = a.r + (b.r - a.r) * c, d.g = a.g + (b.g - a.g) * c, d.b = a.b + (b.b - a.b) * c, d.a = a.a + (b.a - a.a) * c }, b.FromArray = function (a, c) { return c || (c = 0), new b(a[c], a[c + 1], a[c + 2], a[c + 3]) }, b.FromInts = function (a, c, d, e) { return new b(a / 255, c / 255, d / 255, e / 255) }, b }(); a.Color4 = c; var d = function () { function a(a, b) { this.x = a, this.y = b } return a.prototype.toString = function () { return "{X: " + this.x + " Y:" + this.y + "}" }, a.prototype.toArray = function (a, b) { void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y }, a.prototype.asArray = function () { var a = []; return this.toArray(a, 0), a }, a.prototype.copyFrom = function (a) { this.x = a.x, this.y = a.y }, a.prototype.add = function (b) { return new a(this.x + b.x, this.y + b.y) }, a.prototype.subtract = function (b) { return new a(this.x - b.x, this.y - b.y) }, a.prototype.negate = function () { return new a(-this.x, -this.y) }, a.prototype.scaleInPlace = function (a) { this.x *= a, this.y *= a }, a.prototype.scale = function (b) { return new a(this.x * b, this.y * b) }, a.prototype.equals = function (a) { return a && this.x === a.x && this.y === a.y }, a.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, a.prototype.lengthSquared = function () { return this.x * this.x + this.y * this.y }, a.prototype.normalize = function () { var a = this.length(); if (0 !== a) { var b = 1 / a; this.x *= b, this.y *= b } }, a.prototype.clone = function () { return new a(this.x, this.y) }, a.Zero = function () { return new a(0, 0) }, a.CatmullRom = function (b, c, d, e, f) { var g = f * f, h = f * g, i = .5 * (2 * c.x + (-b.x + d.x) * f + (2 * b.x - 5 * c.x + 4 * d.x - e.x) * g + (-b.x + 3 * c.x - 3 * d.x + e.x) * h), j = .5 * (2 * c.y + (-b.y + d.y) * f + (2 * b.y - 5 * c.y + 4 * d.y - e.y) * g + (-b.y + 3 * c.y - 3 * d.y + e.y) * h); return new a(i, j) }, a.Clamp = function (b, c, d) { var e = b.x; e = e > d.x ? d.x : e, e = e < c.x ? c.x : e; var f = b.y; return f = f > d.y ? d.y : f, f = f < c.y ? c.y : f, new a(e, f) }, a.Hermite = function (b, c, d, e, f) { var g = f * f, h = f * g, i = 2 * h - 3 * g + 1, j = -2 * h + 3 * g, k = h - 2 * g + f, l = h - g, m = b.x * i + d.x * j + c.x * k + e.x * l, n = b.y * i + d.y * j + c.y * k + e.y * l; return new a(m, n) }, a.Lerp = function (b, c, d) { var e = b.x + (c.x - b.x) * d, f = b.y + (c.y - b.y) * d; return new a(e, f) }, a.Dot = function (a, b) { return a.x * b.x + a.y * b.y }, a.Normalize = function (a) { var b = a.clone(); return b.normalize(), b }, a.Minimize = function (b, c) { var d = b.x < c.x ? b.x : c.x, e = b.y < c.y ? b.y : c.y; return new a(d, e) }, a.Maximize = function (b, c) { var d = b.x > c.x ? b.x : c.x, e = b.y > c.y ? b.y : c.y; return new a(d, e) }, a.Transform = function (b, c) { var d = b.x * c.m[0] + b.y * c.m[4], e = b.x * c.m[1] + b.y * c.m[5]; return new a(d, e) }, a.Distance = function (b, c) { return Math.sqrt(a.DistanceSquared(b, c)) }, a.DistanceSquared = function (a, b) { var c = a.x - b.x, d = a.y - b.y; return c * c + d * d }, a }(); a.Vector2 = d; var e = function () { function b(a, b, c) { this.x = a, this.y = b, this.z = c } return b.prototype.toString = function () { return "{X: " + this.x + " Y:" + this.y + " Z:" + this.z + "}" }, b.prototype.asArray = function () { var a = []; return this.toArray(a, 0), a }, b.prototype.toArray = function (a, b) { void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z }, b.prototype.addInPlace = function (a) { this.x += a.x, this.y += a.y, this.z += a.z }, b.prototype.add = function (a) { return new b(this.x + a.x, this.y + a.y, this.z + a.z) }, b.prototype.addToRef = function (a, b) { b.x = this.x + a.x, b.y = this.y + a.y, b.z = this.z + a.z }, b.prototype.subtractInPlace = function (a) { this.x -= a.x, this.y -= a.y, this.z -= a.z }, b.prototype.subtract = function (a) { return new b(this.x - a.x, this.y - a.y, this.z - a.z) }, b.prototype.subtractToRef = function (a, b) { b.x = this.x - a.x, b.y = this.y - a.y, b.z = this.z - a.z }, b.prototype.subtractFromFloats = function (a, c, d) { return new b(this.x - a, this.y - c, this.z - d) }, b.prototype.subtractFromFloatsToRef = function (a, b, c, d) { d.x = this.x - a, d.y = this.y - b, d.z = this.z - c }, b.prototype.negate = function () { return new b(-this.x, -this.y, -this.z) }, b.prototype.scaleInPlace = function (a) { this.x *= a, this.y *= a, this.z *= a }, b.prototype.scale = function (a) { return new b(this.x * a, this.y * a, this.z * a) }, b.prototype.scaleToRef = function (a, b) { b.x = this.x * a, b.y = this.y * a, b.z = this.z * a }, b.prototype.equals = function (a) { return a && this.x === a.x && this.y === a.y && this.z === a.z }, b.prototype.equalsToFloats = function (a, b, c) { return this.x === a && this.y === b && this.z === c }, b.prototype.multiplyInPlace = function (a) { this.x *= a.x, this.y *= a.y, this.z *= a.z }, b.prototype.multiply = function (a) { return new b(this.x * a.x, this.y * a.y, this.z * a.z) }, b.prototype.multiplyToRef = function (a, b) { b.x = this.x * a.x, b.y = this.y * a.y, b.z = this.z * a.z }, b.prototype.multiplyByFloats = function (a, c, d) { return new b(this.x * a, this.y * c, this.z * d) }, b.prototype.divide = function (a) { return new b(this.x / a.x, this.y / a.y, this.z / a.z) }, b.prototype.divideToRef = function (a, b) { b.x = this.x / a.x, b.y = this.y / a.y, b.z = this.z / a.z }, b.prototype.MinimizeInPlace = function (a) { a.x < this.x && (this.x = a.x), a.y < this.y && (this.y = a.y), a.z < this.z && (this.z = a.z) }, b.prototype.MaximizeInPlace = function (a) { a.x > this.x && (this.x = a.x), a.y > this.y && (this.y = a.y), a.z > this.z && (this.z = a.z) }, b.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, b.prototype.lengthSquared = function () { return this.x * this.x + this.y * this.y + this.z * this.z }, b.prototype.normalize = function () { var a = this.length(); if (0 !== a) { var b = 1 / a; this.x *= b, this.y *= b, this.z *= b } }, b.prototype.clone = function () { return new b(this.x, this.y, this.z) }, b.prototype.copyFrom = function (a) { this.x = a.x, this.y = a.y, this.z = a.z }, b.prototype.copyFromFloats = function (a, b, c) { this.x = a, this.y = b, this.z = c }, b.FromArray = function (a, c) { return c || (c = 0), new b(a[c], a[c + 1], a[c + 2]) }, b.FromArrayToRef = function (a, b, c) { c.x = a[b], c.y = a[b + 1], c.z = a[b + 2] }, b.FromFloatArrayToRef = function (a, b, c) { c.x = a[b], c.y = a[b + 1], c.z = a[b + 2] }, b.FromFloatsToRef = function (a, b, c, d) { d.x = a, d.y = b, d.z = c }, b.Zero = function () { return new b(0, 0, 0) }, b.Up = function () { return new b(0, 1, 0) }, b.TransformCoordinates = function (a, c) { var d = b.Zero(); return b.TransformCoordinatesToRef(a, c, d), d }, b.TransformCoordinatesToRef = function (a, b, c) { var d = a.x * b.m[0] + a.y * b.m[4] + a.z * b.m[8] + b.m[12], e = a.x * b.m[1] + a.y * b.m[5] + a.z * b.m[9] + b.m[13], f = a.x * b.m[2] + a.y * b.m[6] + a.z * b.m[10] + b.m[14], g = a.x * b.m[3] + a.y * b.m[7] + a.z * b.m[11] + b.m[15]; c.x = d / g, c.y = e / g, c.z = f / g }, b.TransformCoordinatesFromFloatsToRef = function (a, b, c, d, e) { var f = a * d.m[0] + b * d.m[4] + c * d.m[8] + d.m[12], g = a * d.m[1] + b * d.m[5] + c * d.m[9] + d.m[13], h = a * d.m[2] + b * d.m[6] + c * d.m[10] + d.m[14], i = a * d.m[3] + b * d.m[7] + c * d.m[11] + d.m[15]; e.x = f / i, e.y = g / i, e.z = h / i }, b.TransformNormal = function (a, c) { var d = b.Zero(); return b.TransformNormalToRef(a, c, d), d }, b.TransformNormalToRef = function (a, b, c) { c.x = a.x * b.m[0] + a.y * b.m[4] + a.z * b.m[8], c.y = a.x * b.m[1] + a.y * b.m[5] + a.z * b.m[9], c.z = a.x * b.m[2] + a.y * b.m[6] + a.z * b.m[10] }, b.TransformNormalFromFloatsToRef = function (a, b, c, d, e) { e.x = a * d.m[0] + b * d.m[4] + c * d.m[8], e.y = a * d.m[1] + b * d.m[5] + c * d.m[9], e.z = a * d.m[2] + b * d.m[6] + c * d.m[10] }, b.CatmullRom = function (a, c, d, e, f) { var g = f * f, h = f * g, i = .5 * (2 * c.x + (-a.x + d.x) * f + (2 * a.x - 5 * c.x + 4 * d.x - e.x) * g + (-a.x + 3 * c.x - 3 * d.x + e.x) * h), j = .5 * (2 * c.y + (-a.y + d.y) * f + (2 * a.y - 5 * c.y + 4 * d.y - e.y) * g + (-a.y + 3 * c.y - 3 * d.y + e.y) * h), k = .5 * (2 * c.z + (-a.z + d.z) * f + (2 * a.z - 5 * c.z + 4 * d.z - e.z) * g + (-a.z + 3 * c.z - 3 * d.z + e.z) * h); return new b(i, j, k) }, b.Clamp = function (a, c, d) { var e = a.x; e = e > d.x ? d.x : e, e = e < c.x ? c.x : e; var f = a.y; f = f > d.y ? d.y : f, f = f < c.y ? c.y : f; var g = a.z; return g = g > d.z ? d.z : g, g = g < c.z ? c.z : g, new b(e, f, g) }, b.Hermite = function (a, c, d, e, f) { var g = f * f, h = f * g, i = 2 * h - 3 * g + 1, j = -2 * h + 3 * g, k = h - 2 * g + f, l = h - g, m = a.x * i + d.x * j + c.x * k + e.x * l, n = a.y * i + d.y * j + c.y * k + e.y * l, o = a.z * i + d.z * j + c.z * k + e.z * l; return new b(m, n, o) }, b.Lerp = function (a, c, d) { var e = a.x + (c.x - a.x) * d, f = a.y + (c.y - a.y) * d, g = a.z + (c.z - a.z) * d; return new b(e, f, g) }, b.Dot = function (a, b) { return a.x * b.x + a.y * b.y + a.z * b.z }, b.Cross = function (a, c) { var d = b.Zero(); return b.CrossToRef(a, c, d), d }, b.CrossToRef = function (a, b, c) { c.x = a.y * b.z - a.z * b.y, c.y = a.z * b.x - a.x * b.z, c.z = a.x * b.y - a.y * b.x }, b.Normalize = function (a) { var c = b.Zero(); return b.NormalizeToRef(a, c), c }, b.NormalizeToRef = function (a, b) { b.copyFrom(a), b.normalize() }, b.Project = function (c, d, e, f) { var g = f.width, h = f.height, i = f.x, j = f.y, k = a.Matrix.FromValues(g / 2, 0, 0, 0, 0, -h / 2, 0, 0, 0, 0, 1, 0, i + g / 2, h / 2 + j, 0, 1), l = d.multiply(e).multiply(k); return b.TransformCoordinates(c, l) }, b.Unproject = function (b, c, d, e, f, g) { var h = e.multiply(f).multiply(g); h.invert(), b.x = b.x / c * 2 - 1, b.y = -(b.y / d * 2 - 1); var i = a.Vector3.TransformCoordinates(b, h), j = b.x * h.m[3] + b.y * h.m[7] + b.z * h.m[11] + h.m[15]; return a.Tools.WithinEpsilon(j, 1) && (i = i.scale(1 / j)), i }, b.Minimize = function (a, b) { var c = a.clone(); return c.MinimizeInPlace(b), c }, b.Maximize = function (a, b) { var c = a.clone(); return c.MaximizeInPlace(b), c }, b.Distance = function (a, c) { return Math.sqrt(b.DistanceSquared(a, c)) }, b.DistanceSquared = function (a, b) { var c = a.x - b.x, d = a.y - b.y, e = a.z - b.z; return c * c + d * d + e * e }, b.Center = function (a, b) { var c = a.add(b); return c.scaleInPlace(.5), c }, b }(); a.Vector3 = e; var f = function () { function a(a, b, c, d) { "undefined" == typeof a && (a = 0), "undefined" == typeof b && (b = 0), "undefined" == typeof c && (c = 0), "undefined" == typeof d && (d = 0), this.x = a, this.y = b, this.z = c, this.w = d } return a.prototype.toString = function () { return "{X: " + this.x + " Y:" + this.y + " Z:" + this.z + " W:" + this.w + "}" }, a.prototype.asArray = function () { return [this.x, this.y, this.z, this.w] }, a.prototype.equals = function (a) { return a && this.x === a.x && this.y === a.y && this.z === a.z && this.w === a.w }, a.prototype.clone = function () { return new a(this.x, this.y, this.z, this.w) }, a.prototype.copyFrom = function (a) { this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w }, a.prototype.add = function (b) { return new a(this.x + b.x, this.y + b.y, this.z + b.z, this.w + b.w) }, a.prototype.scale = function (b) { return new a(this.x * b, this.y * b, this.z * b, this.w * b) }, a.prototype.multiply = function (b) { var c = new a(0, 0, 0, 1); return this.multiplyToRef(b, c), c }, a.prototype.multiplyToRef = function (a, b) { b.x = this.x * a.w + this.y * a.z - this.z * a.y + this.w * a.x, b.y = -this.x * a.z + this.y * a.w + this.z * a.x + this.w * a.y, b.z = this.x * a.y - this.y * a.x + this.z * a.w + this.w * a.z, b.w = -this.x * a.x - this.y * a.y - this.z * a.z + this.w * a.w }, a.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, a.prototype.normalize = function () { var a = 1 / this.length(); this.x *= a, this.y *= a, this.z *= a, this.w *= a }, a.prototype.toEulerAngles = function () { var a = this.x, b = this.y, c = this.z, d = this.w, f = a * a, g = b * b, h = c * c, i = Math.atan2(2 * (b * d - a * c), 1 - 2 * (g + h)), j = Math.asin(2 * (a * b + c * d)), k = Math.atan2(2 * (a * d - b * c), 1 - 2 * (f + h)), l = a * b + c * d; return l > .499 ? (i = 2 * Math.atan2(a, d), k = 0) : -.499 > l && (i = -2 * Math.atan2(a, d), k = 0), new e(j, i, k) }, a.prototype.toRotationMatrix = function (a) { var b = this.x * this.x, c = this.y * this.y, d = this.z * this.z, e = this.x * this.y, f = this.z * this.w, g = this.z * this.x, h = this.y * this.w, i = this.y * this.z, j = this.x * this.w; a.m[0] = 1 - 2 * (c + d), a.m[1] = 2 * (e + f), a.m[2] = 2 * (g - h), a.m[3] = 0, a.m[4] = 2 * (e - f), a.m[5] = 1 - 2 * (d + b), a.m[6] = 2 * (i + j), a.m[7] = 0, a.m[8] = 2 * (g + h), a.m[9] = 2 * (i - j), a.m[10] = 1 - 2 * (c + b), a.m[11] = 0, a.m[12] = 0, a.m[13] = 0, a.m[14] = 0, a.m[15] = 1 }, a.RotationAxis = function (b, c) { var d = new a, e = Math.sin(c / 2); return d.w = Math.cos(c / 2), d.x = b.x * e, d.y = b.y * e, d.z = b.z * e, d }, a.FromArray = function (b, c) { return c || (c = 0), new a(b[c], b[c + 1], b[c + 2], b[c + 3]) }, a.RotationYawPitchRoll = function (b, c, d) { var e = new a; return a.RotationYawPitchRollToRef(b, c, d, e), e }, a.RotationYawPitchRollToRef = function (a, b, c, d) { var e = .5 * c, f = .5 * b, g = .5 * a, h = Math.sin(e), i = Math.cos(e), j = Math.sin(f), k = Math.cos(f), l = Math.sin(g), m = Math.cos(g); d.x = m * j * i + l * k * h, d.y = l * k * i - m * j * h, d.z = m * k * h - l * j * i, d.w = m * k * i + l * j * h }, a.Slerp = function (b, c, d) { var e, f, g = d, h = b.x * c.x + b.y * c.y + b.z * c.z + b.w * c.w, i = !1; if (0 > h && (i = !0, h = -h), h > .999999) f = 1 - g, e = i ? -g : g; else { var j = Math.acos(h), k = 1 / Math.sin(j); f = Math.sin((1 - g) * j) * k, e = i ? -Math.sin(g * j) * k : Math.sin(g * j) * k } return new a(f * b.x + e * c.x, f * b.y + e * c.y, f * b.z + e * c.z, f * b.w + e * c.w) }, a }(); a.Quaternion = f; var g = function () { function a() { this.m = new Float32Array(16) } return a.prototype.isIdentity = function () { return 1 != this.m[0] || 1 != this.m[5] || 1 != this.m[10] || 1 != this.m[15] ? !1 : 0 != this.m[1] || 0 != this.m[2] || 0 != this.m[3] || 0 != this.m[4] || 0 != this.m[6] || 0 != this.m[7] || 0 != this.m[8] || 0 != this.m[9] || 0 != this.m[11] || 0 != this.m[12] || 0 != this.m[13] || 0 != this.m[14] ? !1 : !0 }, a.prototype.determinant = function () { var a = this.m[10] * this.m[15] - this.m[11] * this.m[14], b = this.m[9] * this.m[15] - this.m[11] * this.m[13], c = this.m[9] * this.m[14] - this.m[10] * this.m[13], d = this.m[8] * this.m[15] - this.m[11] * this.m[12], e = this.m[8] * this.m[14] - this.m[10] * this.m[12], f = this.m[8] * this.m[13] - this.m[9] * this.m[12]; return this.m[0] * (this.m[5] * a - this.m[6] * b + this.m[7] * c) - this.m[1] * (this.m[4] * a - this.m[6] * d + this.m[7] * e) + this.m[2] * (this.m[4] * b - this.m[5] * d + this.m[7] * f) - this.m[3] * (this.m[4] * c - this.m[5] * e + this.m[6] * f) }, a.prototype.toArray = function () { return this.m }, a.prototype.asArray = function () { return this.toArray() }, a.prototype.invert = function () { this.invertToRef(this) }, a.prototype.invertToRef = function (a) { var b = this.m[0], c = this.m[1], d = this.m[2], e = this.m[3], f = this.m[4], g = this.m[5], h = this.m[6], i = this.m[7], j = this.m[8], k = this.m[9], l = this.m[10], m = this.m[11], n = this.m[12], o = this.m[13], p = this.m[14], q = this.m[15], r = l * q - m * p, s = k * q - m * o, t = k * p - l * o, u = j * q - m * n, v = j * p - l * n, w = j * o - k * n, x = g * r - h * s + i * t, y = -(f * r - h * u + i * v), z = f * s - g * u + i * w, A = -(f * t - g * v + h * w), B = 1 / (b * x + c * y + d * z + e * A), C = h * q - i * p, D = g * q - i * o, E = g * p - h * o, F = f * q - i * n, G = f * p - h * n, H = f * o - g * n, I = h * m - i * l, J = g * m - i * k, K = g * l - h * k, L = f * m - i * j, M = f * l - h * j, N = f * k - g * j; a.m[0] = x * B, a.m[4] = y * B, a.m[8] = z * B, a.m[12] = A * B, a.m[1] = -(c * r - d * s + e * t) * B, a.m[5] = (b * r - d * u + e * v) * B, a.m[9] = -(b * s - c * u + e * w) * B, a.m[13] = (b * t - c * v + d * w) * B, a.m[2] = (c * C - d * D + e * E) * B, a.m[6] = -(b * C - d * F + e * G) * B, a.m[10] = (b * D - c * F + e * H) * B, a.m[14] = -(b * E - c * G + d * H) * B, a.m[3] = -(c * I - d * J + e * K) * B, a.m[7] = (b * I - d * L + e * M) * B, a.m[11] = -(b * J - c * L + e * N) * B, a.m[15] = (b * K - c * M + d * N) * B }, a.prototype.setTranslation = function (a) { this.m[12] = a.x, this.m[13] = a.y, this.m[14] = a.z }, a.prototype.multiply = function (b) { var c = new a; return this.multiplyToRef(b, c), c }, a.prototype.copyFrom = function (a) { for (var b = 0; 16 > b; b++) this.m[b] = a.m[b] }, a.prototype.multiplyToRef = function (a, b) { this.multiplyToArray(a, b.m, 0) }, a.prototype.multiplyToArray = function (a, b, c) { var d = this.m[0], e = this.m[1], f = this.m[2], g = this.m[3], h = this.m[4], i = this.m[5], j = this.m[6], k = this.m[7], l = this.m[8], m = this.m[9], n = this.m[10], o = this.m[11], p = this.m[12], q = this.m[13], r = this.m[14], s = this.m[15], t = a.m[0], u = a.m[1], v = a.m[2], w = a.m[3], x = a.m[4], y = a.m[5], z = a.m[6], A = a.m[7], B = a.m[8], C = a.m[9], D = a.m[10], E = a.m[11], F = a.m[12], G = a.m[13], H = a.m[14], I = a.m[15]; b[c] = d * t + e * x + f * B + g * F, b[c + 1] = d * u + e * y + f * C + g * G, b[c + 2] = d * v + e * z + f * D + g * H, b[c + 3] = d * w + e * A + f * E + g * I, b[c + 4] = h * t + i * x + j * B + k * F, b[c + 5] = h * u + i * y + j * C + k * G, b[c + 6] = h * v + i * z + j * D + k * H, b[c + 7] = h * w + i * A + j * E + k * I, b[c + 8] = l * t + m * x + n * B + o * F, b[c + 9] = l * u + m * y + n * C + o * G, b[c + 10] = l * v + m * z + n * D + o * H, b[c + 11] = l * w + m * A + n * E + o * I, b[c + 12] = p * t + q * x + r * B + s * F, b[c + 13] = p * u + q * y + r * C + s * G, b[c + 14] = p * v + q * z + r * D + s * H, b[c + 15] = p * w + q * A + r * E + s * I }, a.prototype.equals = function (a) { return a && this.m[0] === a.m[0] && this.m[1] === a.m[1] && this.m[2] === a.m[2] && this.m[3] === a.m[3] && this.m[4] === a.m[4] && this.m[5] === a.m[5] && this.m[6] === a.m[6] && this.m[7] === a.m[7] && this.m[8] === a.m[8] && this.m[9] === a.m[9] && this.m[10] === a.m[10] && this.m[11] === a.m[11] && this.m[12] === a.m[12] && this.m[13] === a.m[13] && this.m[14] === a.m[14] && this.m[15] === a.m[15] }, a.prototype.clone = function () { return a.FromValues(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5], this.m[6], this.m[7], this.m[8], this.m[9], this.m[10], this.m[11], this.m[12], this.m[13], this.m[14], this.m[15]) }, a.FromArray = function (b, c) { var d = new a; return c || (c = 0), a.FromArrayToRef(b, c, d), d }, a.FromArrayToRef = function (a, b, c) { for (var d = 0; 16 > d; d++) c.m[d] = a[d + b] }, a.FromValuesToRef = function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) { q.m[0] = a, q.m[1] = b, q.m[2] = c, q.m[3] = d, q.m[4] = e, q.m[5] = f, q.m[6] = g, q.m[7] = h, q.m[8] = i, q.m[9] = j, q.m[10] = k, q.m[11] = l, q.m[12] = m, q.m[13] = n, q.m[14] = o, q.m[15] = p }, a.FromValues = function (b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) { var r = new a; return r.m[0] = b, r.m[1] = c, r.m[2] = d, r.m[3] = e, r.m[4] = f, r.m[5] = g, r.m[6] = h, r.m[7] = i, r.m[8] = j, r.m[9] = k, r.m[10] = l, r.m[11] = m, r.m[12] = n, r.m[13] = o, r.m[14] = p, r.m[15] = q, r }, a.Identity = function () { return a.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) }, a.IdentityToRef = function (b) { a.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, b) }, a.Zero = function () { return a.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) }, a.RotationX = function (b) { var c = new a; return a.RotationXToRef(b, c), c }, a.RotationXToRef = function (a, b) { var c = Math.sin(a), d = Math.cos(a); b.m[0] = 1, b.m[15] = 1, b.m[5] = d, b.m[10] = d, b.m[9] = -c, b.m[6] = c, b.m[1] = 0, b.m[2] = 0, b.m[3] = 0, b.m[4] = 0, b.m[7] = 0, b.m[8] = 0, b.m[11] = 0, b.m[12] = 0, b.m[13] = 0, b.m[14] = 0 }, a.RotationY = function (b) { var c = new a; return a.RotationYToRef(b, c), c }, a.RotationYToRef = function (a, b) { var c = Math.sin(a), d = Math.cos(a); b.m[5] = 1, b.m[15] = 1, b.m[0] = d, b.m[2] = -c, b.m[8] = c, b.m[10] = d, b.m[1] = 0, b.m[3] = 0, b.m[4] = 0, b.m[6] = 0, b.m[7] = 0, b.m[9] = 0, b.m[11] = 0, b.m[12] = 0, b.m[13] = 0, b.m[14] = 0 }, a.RotationZ = function (b) { var c = new a; return a.RotationZToRef(b, c), c }, a.RotationZToRef = function (a, b) { var c = Math.sin(a), d = Math.cos(a); b.m[10] = 1, b.m[15] = 1, b.m[0] = d, b.m[1] = c, b.m[4] = -c, b.m[5] = d, b.m[2] = 0, b.m[3] = 0, b.m[6] = 0, b.m[7] = 0, b.m[8] = 0, b.m[9] = 0, b.m[11] = 0, b.m[12] = 0, b.m[13] = 0, b.m[14] = 0 }, a.RotationAxis = function (b, c) { var d = Math.sin(-c), e = Math.cos(-c), f = 1 - e; b.normalize(); var g = a.Zero(); return g.m[0] = b.x * b.x * f + e, g.m[1] = b.x * b.y * f - b.z * d, g.m[2] = b.x * b.z * f + b.y * d, g.m[3] = 0, g.m[4] = b.y * b.x * f + b.z * d, g.m[5] = b.y * b.y * f + e, g.m[6] = b.y * b.z * f - b.x * d, g.m[7] = 0, g.m[8] = b.z * b.x * f - b.y * d, g.m[9] = b.z * b.y * f + b.x * d, g.m[10] = b.z * b.z * f + e, g.m[11] = 0, g.m[15] = 1, g }, a.RotationYawPitchRoll = function (b, c, d) { var e = new a; return a.RotationYawPitchRollToRef(b, c, d, e), e }, a.RotationYawPitchRollToRef = function (a, b, c, d) { f.RotationYawPitchRollToRef(a, b, c, this._tempQuaternion), this._tempQuaternion.toRotationMatrix(d) }, a.Scaling = function (b, c, d) { var e = a.Zero(); return a.ScalingToRef(b, c, d, e), e }, a.ScalingToRef = function (a, b, c, d) { d.m[0] = a, d.m[1] = 0, d.m[2] = 0, d.m[3] = 0, d.m[4] = 0, d.m[5] = b, d.m[6] = 0, d.m[7] = 0, d.m[8] = 0, d.m[9] = 0, d.m[10] = c, d.m[11] = 0, d.m[12] = 0, d.m[13] = 0, d.m[14] = 0, d.m[15] = 1 }, a.Translation = function (b, c, d) { var e = a.Identity(); return a.TranslationToRef(b, c, d, e), e }, a.TranslationToRef = function (b, c, d, e) { a.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, b, c, d, 1, e) }, a.LookAtLH = function (b, c, d) { var e = a.Zero(); return a.LookAtLHToRef(b, c, d, e), e }, a.LookAtLHToRef = function (b, c, d, f) { c.subtractToRef(b, this._zAxis), this._zAxis.normalize(), e.CrossToRef(d, this._zAxis, this._xAxis), this._xAxis.normalize(), e.CrossToRef(this._zAxis, this._xAxis, this._yAxis), this._yAxis.normalize(); var g = -e.Dot(this._xAxis, b), h = -e.Dot(this._yAxis, b), i = -e.Dot(this._zAxis, b); return a.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, g, h, i, 1, f) }, a.OrthoLH = function (b, c, d, e) { var f = 2 / b, g = 2 / c, h = 1 / (e - d), i = d / (d - e); return a.FromValues(f, 0, 0, 0, 0, g, 0, 0, 0, 0, h, 0, 0, 0, i, 1) }, a.OrthoOffCenterLH = function (b, c, d, e, f, g) { var h = a.Zero(); return a.OrthoOffCenterLHToRef(b, c, d, e, f, g, h), h }, a.OrthoOffCenterLHToRef = function (a, b, c, d, e, f, g) { g.m[0] = 2 / (b - a), g.m[1] = g.m[2] = g.m[3] = 0, g.m[5] = 2 / (d - c), g.m[4] = g.m[6] = g.m[7] = 0, g.m[10] = -1 / (e - f), g.m[8] = g.m[9] = g.m[11] = 0, g.m[12] = (a + b) / (a - b), g.m[13] = (d + c) / (c - d), g.m[14] = e / (e - f), g.m[15] = 1 }, a.PerspectiveLH = function (b, c, d, e) { var f = a.Zero(); return f.m[0] = 2 * d / b, f.m[1] = f.m[2] = f.m[3] = 0, f.m[5] = 2 * d / c, f.m[4] = f.m[6] = f.m[7] = 0, f.m[10] = -e / (d - e), f.m[8] = f.m[9] = 0, f.m[11] = 1, f.m[12] = f.m[13] = f.m[15] = 0, f.m[14] = d * e / (d - e), f }, a.PerspectiveFovLH = function (b, c, d, e) { var f = a.Zero(); return a.PerspectiveFovLHToRef(b, c, d, e, f), f }, a.PerspectiveFovLHToRef = function (a, b, c, d, e) { var f = 1 / Math.tan(.5 * a); e.m[0] = f / b, e.m[1] = e.m[2] = e.m[3] = 0, e.m[5] = f, e.m[4] = e.m[6] = e.m[7] = 0, e.m[8] = e.m[9] = 0, e.m[10] = -d / (c - d), e.m[11] = 1, e.m[12] = e.m[13] = e.m[15] = 0, e.m[14] = c * d / (c - d) }, a.GetFinalMatrix = function (b, c, d, e, f, g) { var h = b.width, i = b.height, j = b.x, k = b.y, l = a.FromValues(h / 2, 0, 0, 0, 0, -i / 2, 0, 0, 0, 0, g - f, 0, j + h / 2, i / 2 + k, f, 1); return c.multiply(d).multiply(e).multiply(l) }, a.Transpose = function (b) { var c = new a; return c.m[0] = b.m[0], c.m[1] = b.m[4], c.m[2] = b.m[8], c.m[3] = b.m[12], c.m[4] = b.m[1], c.m[5] = b.m[5], c.m[6] = b.m[9], c.m[7] = b.m[13], c.m[8] = b.m[2], c.m[9] = b.m[6], c.m[10] = b.m[10], c.m[11] = b.m[14], c.m[12] = b.m[3], c.m[13] = b.m[7], c.m[14] = b.m[11], c.m[15] = b.m[15], c }, a.Reflection = function (b) { var c = new a; return a.ReflectionToRef(b, c), c }, a.ReflectionToRef = function (a, b) { a.normalize(); var c = a.normal.x, d = a.normal.y, e = a.normal.z, f = -2 * c, g = -2 * d, h = -2 * e; b.m[0] = f * c + 1, b.m[1] = g * c, b.m[2] = h * c, b.m[3] = 0, b.m[4] = f * d, b.m[5] = g * d + 1, b.m[6] = h * d, b.m[7] = 0, b.m[8] = f * e, b.m[9] = g * e, b.m[10] = h * e + 1, b.m[11] = 0, b.m[12] = f * a.d, b.m[13] = g * a.d, b.m[14] = h * a.d, b.m[15] = 1 }, a._tempQuaternion = new f, a._xAxis = e.Zero(), a._yAxis = e.Zero(), a._zAxis = e.Zero(), a }(); a.Matrix = g; var h = function () { function b(a, b, c, d) { this.normal = new e(a, b, c), this.d = d } return b.prototype.asArray = function () { return [this.normal.x, this.normal.y, this.normal.z, this.d] }, b.prototype.clone = function () { return new b(this.normal.x, this.normal.y, this.normal.z, this.d) }, b.prototype.normalize = function () { var a = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z), b = 0; 0 != a && (b = 1 / a), this.normal.x *= b, this.normal.y *= b, this.normal.z *= b, this.d *= b }, b.prototype.transform = function (b) { var c = a.Matrix.Transpose(b), d = this.normal.x, e = this.normal.y, f = this.normal.z, g = this.d, h = d * c.m[0] + e * c.m[1] + f * c.m[2] + g * c.m[3], i = d * c.m[4] + e * c.m[5] + f * c.m[6] + g * c.m[7], j = d * c.m[8] + e * c.m[9] + f * c.m[10] + g * c.m[11], k = d * c.m[12] + e * c.m[13] + f * c.m[14] + g * c.m[15]; return new a.Plane(h, i, j, k) }, b.prototype.dotCoordinate = function (a) { return this.normal.x * a.x + this.normal.y * a.y + this.normal.z * a.z + this.d }, b.prototype.copyFromPoints = function (a, b, c) { var d, e = b.x - a.x, f = b.y - a.y, g = b.z - a.z, h = c.x - a.x, i = c.y - a.y, j = c.z - a.z, k = f * j - g * i, l = g * h - e * j, m = e * i - f * h, n = Math.sqrt(k * k + l * l + m * m); d = 0 != n ? 1 / n : 0, this.normal.x = k * d, this.normal.y = l * d, this.normal.z = m * d, this.d = -(this.normal.x * a.x + this.normal.y * a.y + this.normal.z * a.z) }, b.prototype.isFrontFacingTo = function (a, b) { var c = e.Dot(this.normal, a); return b >= c }, b.prototype.signedDistanceTo = function (a) { return e.Dot(a, this.normal) + this.d }, b.FromArray = function (b) { return new a.Plane(b[0], b[1], b[2], b[3]) }, b.FromPoints = function (b, c, d) { var e = new a.Plane(0, 0, 0, 0); return e.copyFromPoints(b, c, d), e }, b.FromPositionAndNormal = function (b, c) { var d = new a.Plane(0, 0, 0, 0); return c.normalize(), d.normal = c, d.d = -(c.x * b.x + c.y * b.y + c.z * b.z), d }, b.SignedDistanceToPlaneFromPositionAndNormal = function (a, b, c) { var d = -(b.x * a.x + b.y * a.y + b.z * a.z); return e.Dot(c, b) + d }, b }(); a.Plane = h; var i = function () { function a(a, b, c, d) { this.x = a, this.y = b, this.width = c, this.height = d } return a.prototype.toGlobal = function (b) { var c = b.getRenderWidth(), d = b.getRenderHeight(); return new a(this.x * c, this.y * d, this.width * c, this.height * d) }, a }(); a.Viewport = i; var j = function () { function a() { } return a.GetPlanes = function (b) { for (var c = [], d = 0; 6 > d; d++) c.push(new h(0, 0, 0, 0)); return a.GetPlanesToRef(b, c), c }, a.GetPlanesToRef = function (a, b) { b[0].normal.x = a.m[3] + a.m[2], b[0].normal.y = a.m[7] + a.m[6], b[0].normal.z = a.m[10] + a.m[10], b[0].d = a.m[15] + a.m[14], b[0].normalize(), b[1].normal.x = a.m[3] - a.m[2], b[1].normal.y = a.m[7] - a.m[6], b[1].normal.z = a.m[11] - a.m[10], b[1].d = a.m[15] - a.m[14], b[1].normalize(), b[2].normal.x = a.m[3] + a.m[0], b[2].normal.y = a.m[7] + a.m[4], b[2].normal.z = a.m[11] + a.m[8], b[2].d = a.m[15] + a.m[12], b[2].normalize(), b[3].normal.x = a.m[3] - a.m[0], b[3].normal.y = a.m[7] - a.m[4], b[3].normal.z = a.m[11] - a.m[8], b[3].d = a.m[15] - a.m[12], b[3].normalize(), b[4].normal.x = a.m[3] - a.m[1], b[4].normal.y = a.m[7] - a.m[5], b[4].normal.z = a.m[11] - a.m[9], b[4].d = a.m[15] - a.m[13], b[4].normalize(), b[5].normal.x = a.m[3] + a.m[1], b[5].normal.y = a.m[7] + a.m[5], b[5].normal.z = a.m[11] + a.m[9], b[5].d = a.m[15] + a.m[13], b[5].normalize() }, a }(); a.Frustum = j; var k = function () { function b(a, b) { this.origin = a, this.direction = b } return b.prototype.intersectsBox = function (a) { var b = 0, c = Number.MAX_VALUE; if (Math.abs(this.direction.x) < 1e-7) { if (this.origin.x < a.minimum.x || this.origin.x > a.maximum.x) return !1 } else { var d = 1 / this.direction.x, e = (a.minimum.x - this.origin.x) * d, f = (a.maximum.x - this.origin.x) * d; if (e > f) { var g = e; e = f, f = g } if (b = Math.max(e, b), c = Math.min(f, c), b > c) return !1 } if (Math.abs(this.direction.y) < 1e-7) { if (this.origin.y < a.minimum.y || this.origin.y > a.maximum.y) return !1 } else if (d = 1 / this.direction.y, e = (a.minimum.y - this.origin.y) * d, f = (a.maximum.y - this.origin.y) * d, e > f && (g = e, e = f, f = g), b = Math.max(e, b), c = Math.min(f, c), b > c) return !1; if (Math.abs(this.direction.z) < 1e-7) { if (this.origin.z < a.minimum.z || this.origin.z > a.maximum.z) return !1 } else if (d = 1 / this.direction.z, e = (a.minimum.z - this.origin.z) * d, f = (a.maximum.z - this.origin.z) * d, e > f && (g = e, e = f, f = g), b = Math.max(e, b), c = Math.min(f, c), b > c) return !1; return !0 }, b.prototype.intersectsSphere = function (a) { var b = a.center.x - this.origin.x, c = a.center.y - this.origin.y, d = a.center.z - this.origin.z, e = b * b + c * c + d * d, f = a.radius * a.radius; if (f >= e) return !0; var g = b * this.direction.x + c * this.direction.y + d * this.direction.z; if (0 > g) return !1; var h = e - g * g; return f >= h }, b.prototype.intersectsTriangle = function (b, c, d) { this._edge1 || (this._edge1 = a.Vector3.Zero(), this._edge2 = a.Vector3.Zero(), this._pvec = a.Vector3.Zero(), this._tvec = a.Vector3.Zero(), this._qvec = a.Vector3.Zero()), c.subtractToRef(b, this._edge1), d.subtractToRef(b, this._edge2), a.Vector3.CrossToRef(this.direction, this._edge2, this._pvec); var f = e.Dot(this._edge1, this._pvec); if (0 === f) return null; var g = 1 / f; this.origin.subtractToRef(b, this._tvec); var h = e.Dot(this._tvec, this._pvec) * g; if (0 > h || h > 1) return null; e.CrossToRef(this._tvec, this._edge1, this._qvec); var i = e.Dot(this.direction, this._qvec) * g; return 0 > i || h + i > 1 ? null : new a.IntersectionInfo(h, i, e.Dot(this._edge2, this._qvec) * g) }, b.CreateNew = function (c, d, e, f, g, h, i) { var j = a.Vector3.Unproject(new a.Vector3(c, d, 0), e, f, g, h, i), k = a.Vector3.Unproject(new a.Vector3(c, d, 1), e, f, g, h, i), l = k.subtract(j); return l.normalize(), new b(j, l) }, b.Transform = function (c, d) { var e = a.Vector3.TransformCoordinates(c.origin, d), f = a.Vector3.TransformNormal(c.direction, d); return new b(e, f) }, b }(); a.Ray = k, function (a) { a[a.LOCAL = 0] = "LOCAL", a[a.WORLD = 1] = "WORLD" }(a.Space || (a.Space = {})); var l = (a.Space, function () { function b() { } return b.X = new a.Vector3(1, 0, 0), b.Y = new a.Vector3(0, 1, 0), b.Z = new a.Vector3(0, 0, 1), b }()); a.Axis = l }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b, c = 60, d = [], e = 60, f = 0, g = function (b, c) { return b ? b instanceof a.Mesh ? null : b instanceof a.SubMesh ? b.clone(c) : b.clone ? b.clone() : null : null }, h = function () {
		function h() { } return h.GetFilename = function (a) { var b = a.lastIndexOf("/"); return 0 > b ? a : a.substring(b + 1) }, h.GetDOMTextContent = function (a) { for (var b = "", c = a.firstChild; c;) 3 == c.nodeType && (b += c.textContent), c = c.nextSibling; return b }, h.ToDegrees = function (a) { return 180 * a / Math.PI }, h.ToRadians = function (a) { return a * Math.PI / 180 }, h.ExtractMinAndMax = function (b, c, d) { for (var e = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), f = new a.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), g = c; c + d > g; g++) { var h = new a.Vector3(b[3 * g], b[3 * g + 1], b[3 * g + 2]); e = a.Vector3.Minimize(h, e), f = a.Vector3.Maximize(h, f) } return { minimum: e, maximum: f } }, h.MakeArray = function (a, b) { return b === !0 || void 0 !== a && null != a ? Array.isArray(a) ? a : [a] : void 0 }, h.GetPointerPrefix = function () { var a = "pointer"; return navigator.pointerEnabled || (a = "mouse"), a }, h.QueueNewFrame = function (a) { window.requestAnimationFrame ? window.requestAnimationFrame(a) : window.msRequestAnimationFrame ? window.msRequestAnimationFrame(a) : window.webkitRequestAnimationFrame ? window.webkitRequestAnimationFrame(a) : window.mozRequestAnimationFrame ? window.mozRequestAnimationFrame(a) : window.oRequestAnimationFrame ? window.oRequestAnimationFrame(a) : window.setTimeout(a, 16) }, h.RequestFullscreen = function (a) { a.requestFullscreen ? a.requestFullscreen() : a.msRequestFullscreen ? a.msRequestFullscreen() : a.webkitRequestFullscreen ? a.webkitRequestFullscreen() : a.mozRequestFullScreen && a.mozRequestFullScreen() }, h.ExitFullscreen = function () { document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.msCancelFullScreen && document.msCancelFullScreen() }, h.LoadImage = function (a, b, c, d) { var e = new Image; e.crossOrigin = "anonymous", e.onload = function () { b(e) }, e.onerror = function (a) { c(e, a) }; var f = function () { e.src = a }, g = function () { d.loadImageFromDB(a, e) }; if (d && d.enableTexturesOffline) d.openAsync(g, f); else if (-1 === a.indexOf("file:")) f(); else try { var i, j = a.substring(5); try { i = URL.createObjectURL(FilesTextures[j], { oneTimeOnly: !0 }) } catch (k) { i = URL.createObjectURL(FilesTextures[j]) } e.src = i } catch (l) { h.Log("Error while trying to load texture: " + j), e.src = null } return e }, h.LoadFile = function (a, b, c, d, e) { var f = function () { var d = new XMLHttpRequest, f = h.BaseUrl + a; d.open("GET", f, !0), e && (d.responseType = "arraybuffer"), d.onprogress = c, d.onreadystatechange = function () { if (4 == d.readyState) { if (200 != d.status) throw new Error("Error status: " + d.status + " - Unable to load " + f); b(e ? d.response : d.responseText) } }, d.send(null) }, g = function () { d.loadSceneFromDB(a, b, c, f) }; d && -1 !== a.indexOf(".babylon") && d.enableSceneOffline ? d.openAsync(g, f) : f() }, h.ReadFile = function (a, b, c) { var d = new FileReader; d.onload = function (a) { b(a.target.result) }, d.onprogress = c, d.readAsText(a) }, h.WithinEpsilon = function (a, b) { var c = a - b; return c >= -1.401298e-45 && 1.401298e-45 >= c }, h.DeepCopy = function (a, b, c, d) { for (var e in a) if (("_" !== e[0] || d && -1 !== d.indexOf(e)) && (!c || -1 === c.indexOf(e))) { var f = a[e], h = typeof f; if ("function" != h) if ("object" == h) if (f instanceof Array) { if (b[e] = [], f.length > 0) if ("object" == typeof f[0]) for (var i = 0; i < f.length; i++) { var j = g(f[i], b); -1 === b[e].indexOf(j) && b[e].push(j) } else b[e] = f.slice(0) } else b[e] = g(f, b); else b[e] = f } }, h.IsEmpty = function (a) { for (var b in a) return !1; return !0 }, h.RegisterTopRootEvents = function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; window.addEventListener(c.name, c.handler, !1); try { window.parent && window.parent.addEventListener(c.name, c.handler, !1) } catch (d) { } } }, h.UnregisterTopRootEvents = function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; window.removeEventListener(c.name, c.handler); try { window.parent && window.parent.removeEventListener(c.name, c.handler) } catch (d) { } } }, h.GetFps = function () {
			return e
		}, h.GetDeltaTime = function () { return f }, h._MeasureFps = function () { d.push((new Date).getTime()); var a = d.length; if (a >= 2 && (f = d[a - 1] - d[a - 2]), a >= c) { a > c && (d.splice(0, 1), a = d.length); for (var b = 0, g = 0; a - 1 > g; g++) b += d[g + 1] - d[g]; e = 1e3 / (b / (a - 1)) } }, h.CreateScreenshot = function (c, d, e) { var f, g; if (e.precision) f = Math.round(c.getRenderWidth() * e.precision), g = Math.round(f / c.getAspectRatio(d)), e = { width: f, height: g }; else if (e.width && e.height) f = e.width, g = e.height; else if (e.width && !e.height) f = e.width, g = Math.round(f / c.getAspectRatio(d)), e = { width: f, height: g }; else if (e.height && !e.width) g = e.height, f = Math.round(g * c.getAspectRatio(d)), e = { width: f, height: g }; else { if (isNaN(e)) return void h.Error("Invalid 'size' parameter !"); g = e, f = e } var i = new a.RenderTargetTexture("screenShot", e, c.scenes[0]); i.renderList = c.scenes[0].meshes, i.onAfterRender = function () { for (var a = 4 * f, d = g / 2, e = c.readPixels(0, 0, f, g), h = 0; d > h; h++) for (var i = 0; a > i; i++) { var j = i + h * a, k = g - h - 1, l = i + k * a, m = e[j]; e[j] = e[l], e[l] = m } b || (b = document.createElement("canvas")), b.width = f, b.height = g; var n = b.getContext("2d"), o = n.createImageData(f, g); o.data.set(e), n.putImageData(o, 0, 0); var p = b.toDataURL(); if ("download" in document.createElement("a")) { var q = window.document.createElement("a"); q.href = p; var r = new Date, s = r.getFullYear() + "/" + r.getMonth() + "/" + r.getDate() + "-" + r.getHours() + ":" + r.getMinutes(); q.setAttribute("download", "screenshot-" + s), window.document.body.appendChild(q), q.addEventListener("click", function () { q.parentElement.removeChild(q) }), q.click() } else { var t = window.open(""), u = t.document.createElement("img"); u.src = p, t.document.body.appendChild(u) } }, i.render(), i.dispose() }, Object.defineProperty(h, "NoneLogLevel", { get: function () { return h._NoneLogLevel }, enumerable: !0, configurable: !0 }), Object.defineProperty(h, "MessageLogLevel", { get: function () { return h._MessageLogLevel }, enumerable: !0, configurable: !0 }), Object.defineProperty(h, "WarningLogLevel", { get: function () { return h._WarningLogLevel }, enumerable: !0, configurable: !0 }), Object.defineProperty(h, "ErrorLogLevel", { get: function () { return h._ErrorLogLevel }, enumerable: !0, configurable: !0 }), Object.defineProperty(h, "AllLogLevel", { get: function () { return h._MessageLogLevel | h._WarningLogLevel | h._ErrorLogLevel }, enumerable: !0, configurable: !0 }), h._FormatMessage = function (a) { var b = function (a) { return 10 > a ? "0" + a : "" + a }, c = new Date; return "BJS - [" + b(c.getHours()) + ":" + b(c.getMinutes()) + ":" + b(c.getSeconds()) + "]: " + a }, h._LogDisabled = function () { }, h._LogEnabled = function (a) { console.log(h._FormatMessage(a)) }, h._WarnDisabled = function () { }, h._WarnEnabled = function (a) { console.warn(h._FormatMessage(a)) }, h._ErrorDisabled = function () { }, h._ErrorEnabled = function (a) { console.error(h._FormatMessage(a)) }, Object.defineProperty(h, "LogLevels", { set: function (a) { h.Log = (a & h.MessageLogLevel) === h.MessageLogLevel ? h._LogEnabled : h._LogDisabled, h.Warn = (a & h.WarningLogLevel) === h.WarningLogLevel ? h._WarnEnabled : h._WarnDisabled, h.Error = (a & h.ErrorLogLevel) === h.ErrorLogLevel ? h._ErrorEnabled : h._ErrorDisabled }, enumerable: !0, configurable: !0 }), h.BaseUrl = "", h._NoneLogLevel = 0, h._MessageLogLevel = 1, h._WarningLogLevel = 2, h._ErrorLogLevel = 4, h.Log = h._LogEnabled, h.Warn = h._WarnEnabled, h.Error = h._ErrorEnabled, h
	}(); a.Tools = h
}(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function (a, b, c, d) { var e = a.createShader("vertex" === c ? a.VERTEX_SHADER : a.FRAGMENT_SHADER); if (a.shaderSource(e, (d ? d + "\n" : "") + b), a.compileShader(e), !a.getShaderParameter(e, a.COMPILE_STATUS)) throw new Error(a.getShaderInfoLog(e)); return e }, c = function (a, b) { var c = 1; do c *= 2; while (a > c); return c > b && (c = b), c }, d = function (a, b, d, e, f, g, h, i, j) { var k = d.getEngine(), l = c(e, k.getCaps().maxTextureSize), m = c(f, k.getCaps().maxTextureSize); b.bindTexture(b.TEXTURE_2D, a), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, void 0 === g ? 1 : g ? 1 : 0), j(l, m), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR), h ? b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR) : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR_MIPMAP_LINEAR), i || b.generateMipmap(b.TEXTURE_2D)), b.bindTexture(b.TEXTURE_2D, null), k._activeTexturesCache = [], a._baseWidth = e, a._baseHeight = f, a._width = l, a._height = m, a.isReady = !0, d._removePendingData(a) }, e = function (b, c, d, f, g, h) { var i, j = function () { d.push(i), f._removePendingData(i), c != h.length - 1 ? e(b, c + 1, d, f, g, h) : g(d) }, k = function () { f._removePendingData(i) }; i = a.Tools.LoadImage(b + h[c], j, k, f.database), f._addPendingData(i) }, f = function () { function a() { } return a }(); a.EngineCapabilities = f; var g = function () { function g(a, b, c) { var d = this; this.isFullscreen = !1, this.isPointerLock = !1, this.forceWireframe = !1, this.cullBackFaces = !0, this.renderEvenInBackground = !0, this.scenes = new Array, this._windowIsBackground = !1, this._runningLoop = !1, this._loadedTexturesCache = new Array, this._activeTexturesCache = new Array, this._compiledEffects = {}, this._depthMask = !1, this._renderingCanvas = a, c = c || {}, c.antialias = b; try { this._gl = a.getContext("webgl", c) || a.getContext("experimental-webgl", c) } catch (e) { throw new Error("WebGL not supported") } if (!this._gl) throw new Error("WebGL not supported"); this._onBlur = function () { d._windowIsBackground = !0 }, this._onFocus = function () { d._windowIsBackground = !1 }, window.addEventListener("blur", this._onBlur), window.addEventListener("focus", this._onFocus), this._workingCanvas = document.createElement("canvas"), this._workingContext = this._workingCanvas.getContext("2d"), this._hardwareScalingLevel = 1 / (window.devicePixelRatio || 1), this.resize(), this._caps = new f, this._caps.maxTexturesImageUnits = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxTextureSize = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE), this._caps.maxCubemapTextureSize = this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.maxRenderTextureSize = this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE), this._caps.standardDerivatives = null !== this._gl.getExtension("OES_standard_derivatives"), this._caps.s3tc = this._gl.getExtension("WEBGL_compressed_texture_s3tc"), this._caps.textureFloat = null !== this._gl.getExtension("OES_texture_float"), this._caps.textureAnisotropicFilterExtension = this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this.setDepthBuffer(!0), this.setDepthFunctionToLessOrEqual(), this.setDepthWrite(!0), this._onFullscreenChange = function () { void 0 !== document.fullscreen ? d.isFullscreen = document.fullscreen : void 0 !== document.mozFullScreen ? d.isFullscreen = document.mozFullScreen : void 0 !== document.webkitIsFullScreen ? d.isFullscreen = document.webkitIsFullScreen : void 0 !== document.msIsFullScreen && (d.isFullscreen = document.msIsFullScreen), d.isFullscreen && d._pointerLockRequested && (a.requestPointerLock = a.requestPointerLock || a.msRequestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, a.requestPointerLock && a.requestPointerLock()) }, document.addEventListener("fullscreenchange", this._onFullscreenChange, !1), document.addEventListener("mozfullscreenchange", this._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, !1), document.addEventListener("msfullscreenchange", this._onFullscreenChange, !1), this._onPointerLockChange = function () { d.isPointerLock = document.mozPointerLockElement === a || document.webkitPointerLockElement === a || document.msPointerLockElement === a || document.pointerLockElement === a }, document.addEventListener("pointerlockchange", this._onPointerLockChange, !1), document.addEventListener("mspointerlockchange", this._onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", this._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, !1) } return Object.defineProperty(g, "ALPHA_DISABLE", { get: function () { return g._ALPHA_DISABLE }, enumerable: !0, configurable: !0 }), Object.defineProperty(g, "ALPHA_ADD", { get: function () { return g._ALPHA_ADD }, enumerable: !0, configurable: !0 }), Object.defineProperty(g, "ALPHA_COMBINE", { get: function () { return g._ALPHA_COMBINE }, enumerable: !0, configurable: !0 }), Object.defineProperty(g, "DELAYLOADSTATE_NONE", { get: function () { return g._DELAYLOADSTATE_NONE }, enumerable: !0, configurable: !0 }), Object.defineProperty(g, "DELAYLOADSTATE_LOADED", { get: function () { return g._DELAYLOADSTATE_LOADED }, enumerable: !0, configurable: !0 }), Object.defineProperty(g, "DELAYLOADSTATE_LOADING", { get: function () { return g._DELAYLOADSTATE_LOADING }, enumerable: !0, configurable: !0 }), Object.defineProperty(g, "DELAYLOADSTATE_NOTLOADED", { get: function () { return g._DELAYLOADSTATE_NOTLOADED }, enumerable: !0, configurable: !0 }), g.prototype.getAspectRatio = function (a) { var b = a.viewport; return this.getRenderWidth() * b.width / (this.getRenderHeight() * b.height) }, g.prototype.getRenderWidth = function () { return this._currentRenderTarget ? this._currentRenderTarget._width : this._renderingCanvas.width }, g.prototype.getRenderHeight = function () { return this._currentRenderTarget ? this._currentRenderTarget._height : this._renderingCanvas.height }, g.prototype.getRenderingCanvas = function () { return this._renderingCanvas }, g.prototype.setHardwareScalingLevel = function (a) { this._hardwareScalingLevel = a, this.resize() }, g.prototype.getHardwareScalingLevel = function () { return this._hardwareScalingLevel }, g.prototype.getLoadedTexturesCache = function () { return this._loadedTexturesCache }, g.prototype.getCaps = function () { return this._caps }, g.prototype.setDepthFunctionToGreater = function () { this._gl.depthFunc(this._gl.GREATER) }, g.prototype.setDepthFunctionToGreaterOrEqual = function () { this._gl.depthFunc(this._gl.GEQUAL) }, g.prototype.setDepthFunctionToLess = function () { this._gl.depthFunc(this._gl.LESS) }, g.prototype.setDepthFunctionToLessOrEqual = function () { this._gl.depthFunc(this._gl.LEQUAL) }, g.prototype.stopRenderLoop = function () { this._renderFunction = null, this._runningLoop = !1 }, g.prototype._renderLoop = function () { var b = this, c = !0; !this.renderEvenInBackground && this._windowIsBackground && (c = !1), c && (this.beginFrame(), this._renderFunction && this._renderFunction(), this.endFrame()), this._runningLoop && a.Tools.QueueNewFrame(function () { b._renderLoop() }) }, g.prototype.runRenderLoop = function (b) { var c = this; this._runningLoop = !0, this._renderFunction = b, a.Tools.QueueNewFrame(function () { c._renderLoop() }) }, g.prototype.switchFullscreen = function (b) { this.isFullscreen ? a.Tools.ExitFullscreen() : (this._pointerLockRequested = b, a.Tools.RequestFullscreen(this._renderingCanvas)) }, g.prototype.clear = function (a, b, c) { this._gl.clearColor(a.r, a.g, a.b, void 0 !== a.a ? a.a : 1), this._depthMask && this._gl.clearDepth(1); var d = 0; b && (d |= this._gl.COLOR_BUFFER_BIT), c && this._depthMask && (d |= this._gl.DEPTH_BUFFER_BIT), this._gl.clear(d) }, g.prototype.setViewport = function (a, b, c) { var d = b || this._renderingCanvas.width, e = c || this._renderingCanvas.height, f = a.x || 0, g = a.y || 0; this._cachedViewport = a, this._gl.viewport(f * d, g * e, d * a.width, e * a.height) }, g.prototype.setDirectViewport = function (a, b, c, d) { this._cachedViewport = null, this._gl.viewport(a, b, c, d) }, g.prototype.beginFrame = function () { a.Tools._MeasureFps() }, g.prototype.endFrame = function () { this.flushFramebuffer() }, g.prototype.resize = function () { this._renderingCanvas.width = this._renderingCanvas.clientWidth / this._hardwareScalingLevel, this._renderingCanvas.height = this._renderingCanvas.clientHeight / this._hardwareScalingLevel }, g.prototype.bindFramebuffer = function (a) { this._currentRenderTarget = a; var b = this._gl; b.bindFramebuffer(b.FRAMEBUFFER, a._framebuffer), this._gl.viewport(0, 0, a._width, a._height), this.wipeCaches() }, g.prototype.unBindFramebuffer = function (a) { if (this._currentRenderTarget = null, a.generateMipMaps) { var b = this._gl; b.bindTexture(b.TEXTURE_2D, a), b.generateMipmap(b.TEXTURE_2D), b.bindTexture(b.TEXTURE_2D, null) } this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null) }, g.prototype.flushFramebuffer = function () { this._gl.flush() }, g.prototype.restoreDefaultFramebuffer = function () { this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null), this.setViewport(this._cachedViewport), this.wipeCaches() }, g.prototype._resetVertexBufferBinding = function () { this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null), this._cachedVertexBuffers = null }, g.prototype.createVertexBuffer = function (a) { var b = this._gl.createBuffer(); return this._gl.bindBuffer(this._gl.ARRAY_BUFFER, b), this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(a), this._gl.STATIC_DRAW), this._resetVertexBufferBinding(), b.references = 1, b }, g.prototype.createDynamicVertexBuffer = function (a) { var b = this._gl.createBuffer(); return this._gl.bindBuffer(this._gl.ARRAY_BUFFER, b), this._gl.bufferData(this._gl.ARRAY_BUFFER, a, this._gl.DYNAMIC_DRAW), this._resetVertexBufferBinding(), b.references = 1, b }, g.prototype.updateDynamicVertexBuffer = function (a, b, c) { this._gl.bindBuffer(this._gl.ARRAY_BUFFER, a), c && c != b.length ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(b, 0, c)) : b instanceof Float32Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, b) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(b)), this._resetVertexBufferBinding() }, g.prototype._resetIndexBufferBinding = function () { this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, null), this._cachedIndexBuffer = null }, g.prototype.createIndexBuffer = function (a) { var b = this._gl.createBuffer(); return this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, b), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(a), this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), b.references = 1, b }, g.prototype.bindBuffers = function (a, b, c, d, e) { if (this._cachedVertexBuffers !== a || this._cachedEffectForVertexBuffers !== e) { this._cachedVertexBuffers = a, this._cachedEffectForVertexBuffers = e, this._gl.bindBuffer(this._gl.ARRAY_BUFFER, a); for (var f = 0, g = 0; g < c.length; g++) { var h = e.getAttribute(g); h >= 0 && this._gl.vertexAttribPointer(h, c[g], this._gl.FLOAT, !1, d, f), f += 4 * c[g] } } this._cachedIndexBuffer !== b && (this._cachedIndexBuffer = b, this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, b)) }, g.prototype.bindMultiBuffers = function (a, b, c) { if (this._cachedVertexBuffers !== a || this._cachedEffectForVertexBuffers !== c) { this._cachedVertexBuffers = a, this._cachedEffectForVertexBuffers = c; for (var d = c.getAttributesNames(), e = 0; e < d.length; e++) { var f = c.getAttribute(e); if (f >= 0) { var g = a[d[e]], h = g.getStrideSize(); this._gl.bindBuffer(this._gl.ARRAY_BUFFER, g.getBuffer()), this._gl.vertexAttribPointer(f, h, this._gl.FLOAT, !1, 4 * h, 0) } } } this._cachedIndexBuffer !== b && (this._cachedIndexBuffer = b, this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, b)) }, g.prototype._releaseBuffer = function (a) { return a.references--, 0 === a.references ? (this._gl.deleteBuffer(a), !0) : !1 }, g.prototype.draw = function (a, b, c) { this._gl.drawElements(a ? this._gl.TRIANGLES : this._gl.LINES, c, this._gl.UNSIGNED_SHORT, 2 * b) }, g.prototype._releaseEffect = function (a) { this._compiledEffects[a._key] && (delete this._compiledEffects[a._key], a.getProgram() && this._gl.deleteProgram(a.getProgram())) }, g.prototype.createEffect = function (b, c, d, e, f, g, h, i) { var j = b.vertexElement || b.vertex || b, k = b.fragmentElement || b.fragment || b, l = j + "+" + k + "@" + f; if (this._compiledEffects[l]) return this._compiledEffects[l]; var m = new a.Effect(b, c, d, e, this, f, g, h, i); return m._key = l, this._compiledEffects[l] = m, m }, g.prototype.createShaderProgram = function (a, c, d) { var e = b(this._gl, a, "vertex", d), f = b(this._gl, c, "fragment", d), g = this._gl.createProgram(); this._gl.attachShader(g, e), this._gl.attachShader(g, f), this._gl.linkProgram(g); var h = this._gl.getProgramParameter(g, this._gl.LINK_STATUS); if (!h) { var i = this._gl.getProgramInfoLog(g); if (i) throw new Error(i) } return this._gl.deleteShader(e), this._gl.deleteShader(f), g }, g.prototype.getUniforms = function (a, b) { for (var c = [], d = 0; d < b.length; d++) c.push(this._gl.getUniformLocation(a, b[d])); return c }, g.prototype.getAttributes = function (a, b) { for (var c = [], d = 0; d < b.length; d++) try { c.push(this._gl.getAttribLocation(a, b[d])) } catch (e) { c.push(-1) } return c }, g.prototype.enableEffect = function (a) { if (a && a.getAttributesCount() && this._currentEffect !== a) { this._vertexAttribArrays = this._vertexAttribArrays || [], this._gl.useProgram(a.getProgram()); for (var b in this._vertexAttribArrays) b > this._gl.VERTEX_ATTRIB_ARRAY_ENABLED || !this._vertexAttribArrays[b] || (this._vertexAttribArrays[b] = !1, this._gl.disableVertexAttribArray(b)); for (var c = a.getAttributesCount(), d = 0; c > d; d++) { var e = a.getAttribute(d); e >= 0 && (this._vertexAttribArrays[e] = !0, this._gl.enableVertexAttribArray(e)) } this._currentEffect = a } }, g.prototype.setArray = function (a, b) { a && this._gl.uniform1fv(a, b) }, g.prototype.setMatrices = function (a, b) { a && this._gl.uniformMatrix4fv(a, !1, b) }, g.prototype.setMatrix = function (a, b) { a && this._gl.uniformMatrix4fv(a, !1, b.toArray()) }, g.prototype.setFloat = function (a, b) { a && this._gl.uniform1f(a, b) }, g.prototype.setFloat2 = function (a, b, c) { a && this._gl.uniform2f(a, b, c) }, g.prototype.setFloat3 = function (a, b, c, d) { a && this._gl.uniform3f(a, b, c, d) }, g.prototype.setBool = function (a, b) { a && this._gl.uniform1i(a, b) }, g.prototype.setFloat4 = function (a, b, c, d, e) { a && this._gl.uniform4f(a, b, c, d, e) }, g.prototype.setColor3 = function (a, b) { a && this._gl.uniform3f(a, b.r, b.g, b.b) }, g.prototype.setColor4 = function (a, b, c) { a && this._gl.uniform4f(a, b.r, b.g, b.b, c) }, g.prototype.setState = function (a) { this._cullingState !== a && (a ? (this._gl.cullFace(this.cullBackFaces ? this._gl.BACK : this._gl.FRONT), this._gl.enable(this._gl.CULL_FACE)) : this._gl.disable(this._gl.CULL_FACE), this._cullingState = a) }, g.prototype.setDepthBuffer = function (a) { a ? this._gl.enable(this._gl.DEPTH_TEST) : this._gl.disable(this._gl.DEPTH_TEST) }, g.prototype.setDepthWrite = function (a) { this._gl.depthMask(a), this._depthMask = a }, g.prototype.setColorWrite = function (a) { this._gl.colorMask(a, a, a, a) }, g.prototype.setAlphaMode = function (b) { switch (b) { case a.Engine.ALPHA_DISABLE: this.setDepthWrite(!0), this._gl.disable(this._gl.BLEND); break; case a.Engine.ALPHA_COMBINE: this.setDepthWrite(!1), this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._gl.enable(this._gl.BLEND); break; case a.Engine.ALPHA_ADD: this.setDepthWrite(!1), this._gl.blendFuncSeparate(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._gl.enable(this._gl.BLEND) } }, g.prototype.setAlphaTesting = function (a) { this._alphaTest = a }, g.prototype.getAlphaTesting = function () { return this._alphaTest }, g.prototype.wipeCaches = function () { this._activeTexturesCache = [], this._currentEffect = null, this._cullingState = null, this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null }, g.prototype.createTexture = function (b, c, e, f) { var g = this, h = this._gl.createTexture(), i = this.getCaps().s3tc && ".dds" === b.substr(b.length - 4, 4).toLowerCase(); if (f._addPendingData(h), h.url = b, h.noMipmap = c, h.references = 1, this._loadedTexturesCache.push(h), i) a.Tools.LoadFile(b, function (b) { var i = a.Internals.DDSTools.GetDDSInfo(b), j = i.mipmapCount > 1 && !c; d(h, g._gl, f, i.width, i.height, e, !j, !0, function () { a.Internals.DDSTools.UploadDDSLevels(g._gl, g.getCaps().s3tc, b, j) }) }, null, f.database, !0); else { var j = function (a) { d(h, g._gl, f, a.width, a.height, e, c, !1, function (b, c) { var d = a.width == b && a.height == c; d || (g._workingCanvas.width = b, g._workingCanvas.height = c, g._workingContext.drawImage(a, 0, 0, a.width, a.height, 0, 0, b, c)), g._gl.texImage2D(g._gl.TEXTURE_2D, 0, g._gl.RGBA, g._gl.RGBA, g._gl.UNSIGNED_BYTE, d ? a : g._workingCanvas) }) }, k = function () { f._removePendingData(h) }; a.Tools.LoadImage(b, j, k, f.database) } return h }, g.prototype.createDynamicTexture = function (a, b, d) { var e = this._gl.createTexture(); return a = c(a, this._caps.maxTextureSize), b = c(b, this._caps.maxTextureSize), this._gl.bindTexture(this._gl.TEXTURE_2D, e), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), d ? this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR_MIPMAP_LINEAR) : this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._activeTexturesCache = [], e._baseWidth = a, e._baseHeight = b, e._width = a, e._height = b, e.isReady = !1, e.generateMipMaps = d, e.references = 1, this._loadedTexturesCache.push(e), e }, g.prototype.updateDynamicTexture = function (a, b, c) { this._gl.bindTexture(this._gl.TEXTURE_2D, a), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, c ? 1 : 0), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, b), a.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._activeTexturesCache = [], a.isReady = !0 }, g.prototype.updateVideoTexture = function (a, b, c) { this._gl.bindTexture(this._gl.TEXTURE_2D, a), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, c ? 0 : 1), b.videoWidth !== a._width || b.videoHeight !== a._height ? (a._workingCanvas || (a._workingCanvas = document.createElement("canvas"), a._workingContext = a._workingCanvas.getContext("2d"), a._workingCanvas.width = a._width, a._workingCanvas.height = a._height), a._workingContext.drawImage(b, 0, 0, b.videoWidth, b.videoHeight, 0, 0, a._width, a._height), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, a._workingCanvas)) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, b), a.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._activeTexturesCache = [], a.isReady = !0 }, g.prototype.createRenderTargetTexture = function (b, c) { var d = !1, e = !0, f = a.Texture.TRILINEAR_SAMPLINGMODE; void 0 !== c && (d = void 0 === c.generateMipMaps ? c : c.generateMipmaps, e = void 0 === c.generateDepthBuffer ? !0 : c.generateDepthBuffer, void 0 !== c.samplingMode && (f = c.samplingMode)); var g = this._gl, h = g.createTexture(); g.bindTexture(g.TEXTURE_2D, h); var i = b.width || b, j = b.height || b, k = g.NEAREST, l = g.NEAREST; f === a.Texture.BILINEAR_SAMPLINGMODE ? (k = g.LINEAR, l = d ? g.LINEAR_MIPMAP_NEAREST : g.LINEAR) : f === a.Texture.TRILINEAR_SAMPLINGMODE && (k = g.LINEAR, l = d ? g.LINEAR_MIPMAP_LINEAR : g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, k), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, l), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texImage2D(g.TEXTURE_2D, 0, g.RGBA, i, j, 0, g.RGBA, g.UNSIGNED_BYTE, null); var m; e && (m = g.createRenderbuffer(), g.bindRenderbuffer(g.RENDERBUFFER, m), g.renderbufferStorage(g.RENDERBUFFER, g.DEPTH_COMPONENT16, i, j)); var n = g.createFramebuffer(); return g.bindFramebuffer(g.FRAMEBUFFER, n), g.framebufferTexture2D(g.FRAMEBUFFER, g.COLOR_ATTACHMENT0, g.TEXTURE_2D, h, 0), e && g.framebufferRenderbuffer(g.FRAMEBUFFER, g.DEPTH_ATTACHMENT, g.RENDERBUFFER, m), g.bindTexture(g.TEXTURE_2D, null), g.bindRenderbuffer(g.RENDERBUFFER, null), g.bindFramebuffer(g.FRAMEBUFFER, null), h._framebuffer = n, e && (h._depthBuffer = m), h._width = i, h._height = j, h.isReady = !0, h.generateMipMaps = d, h.references = 1, this._activeTexturesCache = [], this._loadedTexturesCache.push(h), h }, g.prototype.createCubeTexture = function (a, b, d, f) { var g = this, h = this._gl, i = h.createTexture(); return i.isCube = !0, i.url = a, i.references = 1, this._loadedTexturesCache.push(i), e(a, 0, [], b, function (a) { var b = c(a[0].width, g._caps.maxCubemapTextureSize), d = b; g._workingCanvas.width = b, g._workingCanvas.height = d; var e = [h.TEXTURE_CUBE_MAP_POSITIVE_X, h.TEXTURE_CUBE_MAP_POSITIVE_Y, h.TEXTURE_CUBE_MAP_POSITIVE_Z, h.TEXTURE_CUBE_MAP_NEGATIVE_X, h.TEXTURE_CUBE_MAP_NEGATIVE_Y, h.TEXTURE_CUBE_MAP_NEGATIVE_Z]; h.bindTexture(h.TEXTURE_CUBE_MAP, i), h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, 0); for (var j = 0; j < e.length; j++) g._workingContext.drawImage(a[j], 0, 0, a[j].width, a[j].height, 0, 0, b, d), h.texImage2D(e[j], 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, g._workingCanvas); f || h.generateMipmap(h.TEXTURE_CUBE_MAP), h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_MIN_FILTER, f ? h.LINEAR : h.LINEAR_MIPMAP_LINEAR), h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.bindTexture(h.TEXTURE_CUBE_MAP, null), g._activeTexturesCache = [], i._width = b, i._height = d, i.isReady = !0 }, d), i }, g.prototype._releaseTexture = function (a) { var b = this._gl; a._framebuffer && b.deleteFramebuffer(a._framebuffer), a._depthBuffer && b.deleteRenderbuffer(a._depthBuffer), b.deleteTexture(a); for (var c = 0; c < this._caps.maxTexturesImageUnits; c++) this._gl.activeTexture(this._gl["TEXTURE" + c]), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null), this._activeTexturesCache[c] = null; var d = this._loadedTexturesCache.indexOf(a); -1 !== d && this._loadedTexturesCache.splice(d, 1) }, g.prototype.bindSamplers = function (a) { this._gl.useProgram(a.getProgram()); for (var b = a.getSamplers(), c = 0; c < b.length; c++) { var d = a.getUniform(b[c]); this._gl.uniform1i(d, c) } this._currentEffect = null }, g.prototype._bindTexture = function (a, b) { this._gl.activeTexture(this._gl["TEXTURE" + a]), this._gl.bindTexture(this._gl.TEXTURE_2D, b), this._activeTexturesCache[a] = null }, g.prototype.setTextureFromPostProcess = function (a, b) { this._bindTexture(a, b._textures.data[b._currentRenderTextureInd]) }, g.prototype.setTexture = function (b, c) { if (!(0 > b)) { if (!c || !c.isReady()) return void (null != this._activeTexturesCache[b] && (this._gl.activeTexture(this._gl["TEXTURE" + b]), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null), this._activeTexturesCache[b] = null)); if (c instanceof a.VideoTexture) c.update() && (this._activeTexturesCache[b] = null); else if (c.delayLoadState == a.Engine.DELAYLOADSTATE_NOTLOADED) return void c.delayLoad(); if (this._activeTexturesCache[b] != c) { this._activeTexturesCache[b] = c; var d = c.getInternalTexture(); if (this._gl.activeTexture(this._gl["TEXTURE" + b]), d.isCube) { if (this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, d), d._cachedCoordinatesMode !== c.coordinatesMode) { d._cachedCoordinatesMode = c.coordinatesMode; var e = c.coordinatesMode !== a.Texture.CUBIC_MODE && c.coordinatesMode !== a.Texture.SKYBOX_MODE ? this._gl.REPEAT : this._gl.CLAMP_TO_EDGE; this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_S, e), this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_T, e) } this._setAnisotropicLevel(this._gl.TEXTURE_CUBE_MAP, c) } else { if (this._gl.bindTexture(this._gl.TEXTURE_2D, d), d._cachedWrapU !== c.wrapU) switch (d._cachedWrapU = c.wrapU, c.wrapU) { case a.Texture.WRAP_ADDRESSMODE: this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT); break; case a.Texture.CLAMP_ADDRESSMODE: this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE); break; case a.Texture.MIRROR_ADDRESSMODE: this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.MIRRORED_REPEAT) } if (d._cachedWrapV !== c.wrapV) switch (d._cachedWrapV = c.wrapV, c.wrapV) { case a.Texture.WRAP_ADDRESSMODE: this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT); break; case a.Texture.CLAMP_ADDRESSMODE: this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE); break; case a.Texture.MIRROR_ADDRESSMODE: this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.MIRRORED_REPEAT) } this._setAnisotropicLevel(this._gl.TEXTURE_2D, c) } } } }, g.prototype._setAnisotropicLevel = function (a, b) { var c = this._caps.textureAnisotropicFilterExtension; c && b._cachedAnisotropicFilteringLevel !== b.anisotropicFilteringLevel && (this._gl.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropicFilteringLevel, this._caps.maxAnisotropy)), b._cachedAnisotropicFilteringLevel = b.anisotropicFilteringLevel) }, g.prototype.readPixels = function (a, b, c, d) { var e = new Uint8Array(d * c * 4); return this._gl.readPixels(0, 0, c, d, this._gl.RGBA, this._gl.UNSIGNED_BYTE, e), e }, g.prototype.dispose = function () { for (this.stopRenderLoop() ; this.scenes.length;) this.scenes[0].dispose(); for (var a in this._compiledEffects) this._gl.deleteProgram(this._compiledEffects[a]._program); window.removeEventListener("blur", this._onBlur), window.removeEventListener("focus", this._onFocus), document.removeEventListener("fullscreenchange", this._onFullscreenChange), document.removeEventListener("mozfullscreenchange", this._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange), document.removeEventListener("msfullscreenchange", this._onFullscreenChange), document.removeEventListener("pointerlockchange", this._onPointerLockChange), document.removeEventListener("mspointerlockchange", this._onPointerLockChange), document.removeEventListener("mozpointerlockchange", this._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange) }, g.isSupported = function () { try { var a = document.createElement("canvas"), b = a.getContext("webgl") || a.getContext("experimental-webgl"); return null != b && !!window.WebGLRenderingContext } catch (c) { return !1 } }, g._ALPHA_DISABLE = 0, g._ALPHA_ADD = 1, g._ALPHA_COMBINE = 2, g._DELAYLOADSTATE_NONE = 0, g._DELAYLOADSTATE_LOADED = 1, g._DELAYLOADSTATE_LOADING = 2, g._DELAYLOADSTATE_NOTLOADED = 4, g.Epsilon = .001, g.CollisionsEpsilon = .001, g.ShadersRepository = "Babylon/Shaders/", g }(); a.Engine = g }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a, b) { this.animations = new Array, this._childrenFlag = -1, this._isEnabled = !0, this._isReady = !0, this._currentRenderId = -1, this.name = a, this.id = a, this._scene = b, this._initCache() } return b.prototype.getScene = function () { return this._scene }, b.prototype.getEngine = function () { return this._scene.getEngine() }, b.prototype.getWorldMatrix = function () { return a.Matrix.Identity() }, b.prototype._initCache = function () { this._cache = {}, this._cache.parent = void 0 }, b.prototype.updateCache = function (a) { (a || !this.isSynchronized()) && (this._cache.parent = this.parent, this._updateCache()) }, b.prototype._updateCache = function () { }, b.prototype._isSynchronized = function () { return !0 }, b.prototype.isSynchronizedWithParent = function () { return this.parent ? this.parent._currentRenderId <= this._currentRenderId : !0 }, b.prototype.isSynchronized = function (a) { var b = this.hasNewParent(); return b = b || !this.isSynchronizedWithParent(), b = b || !this._isSynchronized(), a && this.updateCache(!0), !b }, b.prototype.hasNewParent = function (a) { return this._cache.parent === this.parent ? !1 : (a && (this._cache.parent = this.parent), !0) }, b.prototype.isReady = function () { return this._isReady }, b.prototype.isEnabled = function () { return this.isReady() && this._isEnabled ? this.parent ? this.parent.isEnabled() : !0 : !1 }, b.prototype.setEnabled = function (a) { this._isEnabled = a }, b.prototype.isDescendantOf = function (a) { return this.parent ? this.parent === a ? !0 : this.parent.isDescendantOf(a) : !1 }, b.prototype._getDescendants = function (a, b) { for (var c = 0; c < a.length; c++) { var d = a[c]; d.isDescendantOf(this) && b.push(d) } }, b.prototype.getDescendants = function () { var a = []; return this._getDescendants(this._scene.meshes, a), this._getDescendants(this._scene.lights, a), this._getDescendants(this._scene.cameras, a), a }, b }(); a.Node = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c) { this.minimum = b, this.maximum = c, this._tempRadiusVector = a.Vector3.Zero(); var d = a.Vector3.Distance(b, c); this.center = a.Vector3.Lerp(b, c, .5), this.radius = .5 * d, this.centerWorld = a.Vector3.Zero(), this._update(a.Matrix.Identity()) } return b.prototype._update = function (b) { a.Vector3.TransformCoordinatesToRef(this.center, b, this.centerWorld), a.Vector3.TransformNormalFromFloatsToRef(1, 0, 0, b, this._tempRadiusVector), this.radiusWorld = this._tempRadiusVector.length() * this.radius }, b.prototype.isInFrustum = function (a) { for (var b = 0; 6 > b; b++) if (a[b].dotCoordinate(this.centerWorld) <= -this.radiusWorld) return !1; return !0 }, b.prototype.intersectsPoint = function (b) { var c = this.centerWorld.x - b.x, d = this.centerWorld.y - b.y, e = this.centerWorld.z - b.z, f = Math.sqrt(c * c + d * d + e * e); return Math.abs(this.radiusWorld - f) < a.Engine.Epsilon ? !1 : !0 }, b.Intersects = function (a, b) { var c = a.centerWorld.x - b.centerWorld.x, d = a.centerWorld.y - b.centerWorld.y, e = a.centerWorld.z - b.centerWorld.z, f = Math.sqrt(c * c + d * d + e * e); return a.radiusWorld + b.radiusWorld < f ? !1 : !0 }, b }(); a.BoundingSphere = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function () {
		function b(b, c) {
			this.minimum = b, this.maximum = c, this.vectors = new Array, this.vectorsWorld = new Array, this.vectors.push(this.minimum.clone()), this.vectors.push(this.maximum.clone()), this.vectors.push(this.minimum.clone()), this.vectors[2].x = this.maximum.x, this.vectors.push(this.minimum.clone()), this.vectors[3].y = this.maximum.y, this.vectors.push(this.minimum.clone()), this.vectors[4].z = this.maximum.z, this.vectors.push(this.maximum.clone()), this.vectors[5].z = this.minimum.z, this.vectors.push(this.maximum.clone()), this.vectors[6].x = this.minimum.x, this.vectors.push(this.maximum.clone()), this.vectors[7].y = this.minimum.y, this.center = this.maximum.add(this.minimum).scale(.5), this.extends = this.maximum.subtract(this.minimum).scale(.5), this.directions = [a.Vector3.Zero(), a.Vector3.Zero(), a.Vector3.Zero()];
			for (var d = 0; d < this.vectors.length; d++) this.vectorsWorld[d] = a.Vector3.Zero(); this.minimumWorld = a.Vector3.Zero(), this.maximumWorld = a.Vector3.Zero(), this._update(a.Matrix.Identity())
		} return b.prototype._update = function (b) { a.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimumWorld), a.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximumWorld); for (var c = 0; c < this.vectors.length; c++) { var d = this.vectorsWorld[c]; a.Vector3.TransformCoordinatesToRef(this.vectors[c], b, d), d.x < this.minimumWorld.x && (this.minimumWorld.x = d.x), d.y < this.minimumWorld.y && (this.minimumWorld.y = d.y), d.z < this.minimumWorld.z && (this.minimumWorld.z = d.z), d.x > this.maximumWorld.x && (this.maximumWorld.x = d.x), d.y > this.maximumWorld.y && (this.maximumWorld.y = d.y), d.z > this.maximumWorld.z && (this.maximumWorld.z = d.z) } this.maximumWorld.addToRef(this.minimumWorld, this.center), this.center.scaleInPlace(.5), a.Vector3.FromFloatArrayToRef(b.m, 0, this.directions[0]), a.Vector3.FromFloatArrayToRef(b.m, 4, this.directions[1]), a.Vector3.FromFloatArrayToRef(b.m, 8, this.directions[2]) }, b.prototype.isInFrustum = function (a) { return b.IsInFrustum(this.vectorsWorld, a) }, b.prototype.intersectsPoint = function (b) { var c = a.Engine.Epsilon; return this.maximumWorld.x - b.x < c || c > b.x - this.minimumWorld.x ? !1 : this.maximumWorld.y - b.y < c || c > b.y - this.minimumWorld.y ? !1 : this.maximumWorld.z - b.z < c || c > b.z - this.minimumWorld.z ? !1 : !0 }, b.prototype.intersectsSphere = function (b) { var c = a.Vector3.Clamp(b.centerWorld, this.minimumWorld, this.maximumWorld), d = a.Vector3.DistanceSquared(b.centerWorld, c); return d <= b.radiusWorld * b.radiusWorld }, b.prototype.intersectsMinMax = function (a, b) { return this.maximumWorld.x < a.x || this.minimumWorld.x > b.x ? !1 : this.maximumWorld.y < a.y || this.minimumWorld.y > b.y ? !1 : this.maximumWorld.z < a.z || this.minimumWorld.z > b.z ? !1 : !0 }, b.Intersects = function (a, b) { return a.maximumWorld.x < b.minimumWorld.x || a.minimumWorld.x > b.maximumWorld.x ? !1 : a.maximumWorld.y < b.minimumWorld.y || a.minimumWorld.y > b.maximumWorld.y ? !1 : a.maximumWorld.z < b.minimumWorld.z || a.minimumWorld.z > b.maximumWorld.z ? !1 : !0 }, b.IsInFrustum = function (a, b) { for (var c = 0; 6 > c; c++) { for (var d = 8, e = 0; 8 > e && b[c].dotCoordinate(a[e]) < 0; e++)--d; if (0 == d) return !1 } return !0 }, b
	}(); a.BoundingBox = b
}(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function (b, c) { var d = a.Vector3.Dot(c.center, b), e = Math.abs(a.Vector3.Dot(c.directions[0], b)) * c.extends.x, f = Math.abs(a.Vector3.Dot(c.directions[1], b)) * c.extends.y, g = Math.abs(a.Vector3.Dot(c.directions[2], b)) * c.extends.z, h = e + f + g; return { min: d - h, max: d + h } }, c = function (a, b, c, d) { return !(a > d || c > b) }, d = function (a, d, e) { var f = b(a, d), g = b(a, e); return c(f.min, f.max, g.min, g.max) }, e = function () { function b(b, c) { this.boundingBox = new a.BoundingBox(b, c), this.boundingSphere = new a.BoundingSphere(b, c) } return b.prototype._update = function (a) { this.boundingBox._update(a), this.boundingSphere._update(a) }, b.prototype.isInFrustum = function (a) { return this.boundingSphere.isInFrustum(a) ? this.boundingBox.isInFrustum(a) : !1 }, b.prototype._checkCollision = function (a) { return a._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld) }, b.prototype.intersectsPoint = function (a) { return this.boundingSphere.centerWorld && this.boundingSphere.intersectsPoint(a) && this.boundingBox.intersectsPoint(a) ? !0 : !1 }, b.prototype.intersects = function (b, c) { if (!this.boundingSphere.centerWorld || !b.boundingSphere.centerWorld) return !1; if (!a.BoundingSphere.Intersects(this.boundingSphere, b.boundingSphere)) return !1; if (!a.BoundingBox.Intersects(this.boundingBox, b.boundingBox)) return !1; if (!c) return !0; var e = this.boundingBox, f = b.boundingBox; return d(e.directions[0], e, f) && d(e.directions[1], e, f) && d(e.directions[2], e, f) && d(f.directions[0], e, f) && d(f.directions[1], e, f) && d(f.directions[2], e, f) && d(a.Vector3.Cross(e.directions[0], f.directions[0]), e, f) && d(a.Vector3.Cross(e.directions[0], f.directions[1]), e, f) && d(a.Vector3.Cross(e.directions[0], f.directions[2]), e, f) && d(a.Vector3.Cross(e.directions[1], f.directions[0]), e, f) && d(a.Vector3.Cross(e.directions[1], f.directions[1]), e, f) && d(a.Vector3.Cross(e.directions[1], f.directions[2]), e, f) && d(a.Vector3.Cross(e.directions[2], f.directions[0]), e, f) && d(a.Vector3.Cross(e.directions[2], f.directions[1]), e, f) && d(a.Vector3.Cross(e.directions[2], f.directions[2]), e, f) ? !0 : !1 }, b }(); a.BoundingInfo = e }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d) { b.call(this, c, d), this.diffuse = new a.Color3(1, 1, 1), this.specular = new a.Color3(1, 1, 1), this.intensity = 1, this.range = Number.MAX_VALUE, this.excludedMeshes = new Array, d.lights.push(this) } return __extends(c, b), c.prototype.getShadowGenerator = function () { return this._shadowGenerator }, c.prototype.transferToEffect = function () { }, c.prototype._getWorldMatrix = function () { return a.Matrix.Identity() }, c.prototype.getWorldMatrix = function () { this._currentRenderId = this.getScene().getRenderId(); var b = this._getWorldMatrix(); return this.parent && this.parent.getWorldMatrix ? (this._parentedWorldMatrix || (this._parentedWorldMatrix = a.Matrix.Identity()), b.multiplyToRef(this.parent.getWorldMatrix(), this._parentedWorldMatrix), this._parentedWorldMatrix) : b }, c.prototype.dispose = function () { this._shadowGenerator && (this._shadowGenerator.dispose(), this._shadowGenerator = null); var a = this.getScene().lights.indexOf(this); this.getScene().lights.splice(a, 1) }, c }(a.Node); a.Light = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(a, c, d) { b.call(this, a, d), this.position = c } return __extends(c, b), c.prototype.transferToEffect = function (b, c) { return this.parent && this.parent.getWorldMatrix ? (this._transformedPosition || (this._transformedPosition = a.Vector3.Zero()), a.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this._transformedPosition), void b.setFloat4(c, this._transformedPosition.x, this._transformedPosition.y, this._transformedPosition.z, 0)) : void b.setFloat4(c, this.position.x, this.position.y, this.position.z, 0) }, c.prototype.getShadowGenerator = function () { return null }, c.prototype._getWorldMatrix = function () { return this._worldMatrix || (this._worldMatrix = a.Matrix.Identity()), a.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this._worldMatrix }, c }(a.Light); a.PointLight = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(a, c, d, e, f, g) { b.call(this, a, g), this.position = c, this.direction = d, this.angle = e, this.exponent = f } return __extends(c, b), c.prototype.setDirectionToTarget = function (b) { return this.direction = a.Vector3.Normalize(b.subtract(this.position)), this.direction }, c.prototype.transferToEffect = function (b, c, d) { var e; if (this.parent && this.parent.getWorldMatrix) { this._transformedDirection || (this._transformedDirection = a.Vector3.Zero()), this._transformedPosition || (this._transformedPosition = a.Vector3.Zero()); var f = this.parent.getWorldMatrix(); a.Vector3.TransformCoordinatesToRef(this.position, f, this._transformedPosition), a.Vector3.TransformNormalToRef(this.direction, f, this._transformedDirection), b.setFloat4(c, this._transformedPosition.x, this._transformedPosition.y, this._transformedPosition.z, this.exponent), e = a.Vector3.Normalize(this._transformedDirection) } else b.setFloat4(c, this.position.x, this.position.y, this.position.z, this.exponent), e = a.Vector3.Normalize(this.direction); b.setFloat4(d, e.x, e.y, e.z, Math.cos(.5 * this.angle)) }, c.prototype._getWorldMatrix = function () { return this._worldMatrix || (this._worldMatrix = a.Matrix.Identity()), a.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this._worldMatrix }, c }(a.Light); a.SpotLight = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(a, c, d) { b.call(this, a, d), this.direction = c, this.position = c.scale(-1) } return __extends(c, b), c.prototype.setDirectionToTarget = function (b) { return this.direction = a.Vector3.Normalize(b.subtract(this.position)), this.direction }, c.prototype._computeTransformedPosition = function () { return this.parent && this.parent.getWorldMatrix ? (this._transformedPosition || (this._transformedPosition = a.Vector3.Zero()), a.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this._transformedPosition), !0) : !1 }, c.prototype.transferToEffect = function (b, c) { return this.parent && this.parent.getWorldMatrix ? (this._transformedDirection || (this._transformedDirection = a.Vector3.Zero()), a.Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this._transformedDirection), void b.setFloat4(c, this._transformedDirection.x, this._transformedDirection.y, this._transformedDirection.z, 1)) : void b.setFloat4(c, this.direction.x, this.direction.y, this.direction.z, 1) }, c.prototype._getWorldMatrix = function () { return this._worldMatrix || (this._worldMatrix = a.Matrix.Identity()), a.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this._worldMatrix }, c }(a.Light); a.DirectionalLight = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c) { var d = this; this.useVarianceShadowMap = !0, this._darkness = 0, this._transparencyShadow = !1, this._viewMatrix = a.Matrix.Zero(), this._projectionMatrix = a.Matrix.Zero(), this._transformMatrix = a.Matrix.Zero(), this._worldViewProjection = a.Matrix.Zero(), this._light = c, this._scene = c.getScene(), c._shadowGenerator = this, this._shadowMap = new a.RenderTargetTexture(c.name + "_shadowMap", b, this._scene, !1), this._shadowMap.wrapU = a.Texture.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = a.Texture.CLAMP_ADDRESSMODE, this._shadowMap.renderParticles = !1; var e = function (b) { var c = b.getMesh(), e = c.getWorldMatrix(), f = d._scene.getEngine(); d.isReady(c) && (f.enableEffect(d._effect), c.skeleton && c.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind) && c.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind) ? (d._effect.setMatrix("world", e), d._effect.setMatrix("viewProjection", d.getTransformMatrix()), d._effect.setMatrices("mBones", c.skeleton.getTransformMatrices())) : (e.multiplyToRef(d.getTransformMatrix(), d._worldViewProjection), d._effect.setMatrix("worldViewProjection", d._worldViewProjection)), c.bindAndDraw(b, d._effect, !1)) }; this._shadowMap.customRenderFunction = function (a, b, c) { var f; for (f = 0; f < a.length; f++) e(a.data[f]); for (f = 0; f < b.length; f++) e(b.data[f]); if (d._transparencyShadow) for (f = 0; f < c.length; f++) e(c.data[f]) } } return b.prototype.isReady = function (b) { var c = []; this.useVarianceShadowMap && c.push("#define VSM"); var d = [a.VertexBuffer.PositionKind]; b.skeleton && b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind) && b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind) && (d.push(a.VertexBuffer.MatricesIndicesKind), d.push(a.VertexBuffer.MatricesWeightsKind), c.push("#define BONES"), c.push("#define BonesPerMesh " + b.skeleton.bones.length)); var e = c.join("\n"); return this._cachedDefines != e && (this._cachedDefines = e, this._effect = this._scene.getEngine().createEffect("shadowMap", d, ["world", "mBones", "viewProjection", "worldViewProjection"], [], e)), this._effect.isReady() }, b.prototype.getShadowMap = function () { return this._shadowMap }, b.prototype.getLight = function () { return this._light }, b.prototype.getTransformMatrix = function () { var b = this._light.position, c = this._light.direction; if (this._light._computeTransformedPosition() && (b = this._light._transformedPosition), !(this._cachedPosition && this._cachedDirection && b.equals(this._cachedPosition) && c.equals(this._cachedDirection))) { this._cachedPosition = b.clone(), this._cachedDirection = c.clone(); var d = this._scene.activeCamera; a.Matrix.LookAtLHToRef(b, this._light.position.add(c), a.Vector3.Up(), this._viewMatrix), a.Matrix.PerspectiveFovLHToRef(Math.PI / 2, 1, d.minZ, d.maxZ, this._projectionMatrix), this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix) } return this._transformMatrix }, b.prototype.getDarkness = function () { return this._darkness }, b.prototype.setDarkness = function (a) { a >= 1 ? this._darkness = 1 : 0 >= a && (this._darkness = 0), elsethis._darkness = a }, b.prototype.setTransparencyShadow = function (a) { this._transparencyShadow = a }, b.prototype.dispose = function () { this._shadowMap.dispose() }, b }(); a.ShadowGenerator = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e) { b.call(this, c, e), this.direction = d, this.groundColor = new a.Color3(0, 0, 0) } return __extends(c, b), c.prototype.setDirectionToTarget = function (b) { return this.direction = a.Vector3.Normalize(b.subtract(a.Vector3.Zero())), this.direction }, c.prototype.getShadowGenerator = function () { return null }, c.prototype.transferToEffect = function (b, c, d) { var e = a.Vector3.Normalize(this.direction); b.setFloat4(c, e.x, e.y, e.z, 0), b.setColor3(d, this.groundColor.scale(this.intensity)) }, c.prototype._getWorldMatrix = function () { return this._worldMatrix || (this._worldMatrix = a.Matrix.Identity()), this._worldMatrix }, c }(a.Light); a.HemisphericLight = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function (a, b, c, d) { return a.x > c.x + d ? !1 : c.x - d > b.x ? !1 : a.y > c.y + d ? !1 : c.y - d > b.y ? !1 : a.z > c.z + d ? !1 : c.z - d > b.z ? !1 : !0 }, c = function (a, b, c, d) { var e = b * b - 4 * a * c, f = { root: 0, found: !1 }; if (0 > e) return f; var g = Math.sqrt(e), h = (-b - g) / (2 * a), i = (-b + g) / (2 * a); if (h > i) { var j = i; i = h, h = j } return h > 0 && d > h ? (f.root = h, f.found = !0, f) : i > 0 && d > i ? (f.root = i, f.found = !0, f) : f }, d = function () { function d() { this.radius = new a.Vector3(1, 1, 1), this.retry = 0, this.basePointWorld = a.Vector3.Zero(), this.velocityWorld = a.Vector3.Zero(), this.normalizedVelocity = a.Vector3.Zero(), this._collisionPoint = a.Vector3.Zero(), this._planeIntersectionPoint = a.Vector3.Zero(), this._tempVector = a.Vector3.Zero(), this._tempVector2 = a.Vector3.Zero(), this._tempVector3 = a.Vector3.Zero(), this._tempVector4 = a.Vector3.Zero(), this._edge = a.Vector3.Zero(), this._baseToVertex = a.Vector3.Zero(), this._destinationPoint = a.Vector3.Zero(), this._slidePlaneNormal = a.Vector3.Zero(), this._displacementVector = a.Vector3.Zero() } return d.prototype._initialize = function (b, c, d) { this.velocity = c, a.Vector3.NormalizeToRef(c, this.normalizedVelocity), this.basePoint = b, b.multiplyToRef(this.radius, this.basePointWorld), c.multiplyToRef(this.radius, this.velocityWorld), this.velocityWorldLength = this.velocityWorld.length(), this.epsilon = d, this.collisionFound = !1 }, d.prototype._checkPointInTriangle = function (b, c, d, e, f) { c.subtractToRef(b, this._tempVector), d.subtractToRef(b, this._tempVector2), a.Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4); var g = a.Vector3.Dot(this._tempVector4, f); return 0 > g ? !1 : (e.subtractToRef(b, this._tempVector3), a.Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4), g = a.Vector3.Dot(this._tempVector4, f), 0 > g ? !1 : (a.Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4), g = a.Vector3.Dot(this._tempVector4, f), g >= 0)) }, d.prototype._canDoCollision = function (c, d, e, f) { var g = a.Vector3.Distance(this.basePointWorld, c), h = Math.max(this.radius.x, this.radius.y); return h = Math.max(h, this.radius.z), g > this.velocityWorldLength + h + d ? !1 : b(e, f, this.basePointWorld, this.velocityWorldLength + h) ? !0 : !1 }, d.prototype._testTriangle = function (b, d, e, f, g) { var h, i = !1; d._trianglePlanes || (d._trianglePlanes = []), d._trianglePlanes[b] || (d._trianglePlanes[b] = new a.Plane(0, 0, 0, 0), d._trianglePlanes[b].copyFromPoints(e, f, g)); var j = d._trianglePlanes[b]; if (d.getMaterial() || j.isFrontFacingTo(this.normalizedVelocity, 0)) { var k = j.signedDistanceTo(this.basePoint), l = a.Vector3.Dot(j.normal, this.velocity); if (0 == l) { if (Math.abs(k) >= 1) return; i = !0, h = 0 } else { h = (-1 - k) / l; var m = (1 - k) / l; if (h > m) { var n = m; m = h, h = n } if (h > 1 || 0 > m) return; 0 > h && (h = 0), h > 1 && (h = 1) } this._collisionPoint.copyFromFloats(0, 0, 0); var o = !1, p = 1; if (i || (this.basePoint.subtractToRef(j.normal, this._planeIntersectionPoint), this.velocity.scaleToRef(h, this._tempVector), this._planeIntersectionPoint.addInPlace(this._tempVector), this._checkPointInTriangle(this._planeIntersectionPoint, e, f, g, j.normal) && (o = !0, p = h, this._collisionPoint.copyFrom(this._planeIntersectionPoint))), !o) { var q = this.velocity.lengthSquared(), r = q; this.basePoint.subtractToRef(e, this._tempVector); var s = 2 * a.Vector3.Dot(this.velocity, this._tempVector), t = this._tempVector.lengthSquared() - 1, u = c(r, s, t, p); u.found && (p = u.root, o = !0, this._collisionPoint.copyFrom(e)), this.basePoint.subtractToRef(f, this._tempVector), s = 2 * a.Vector3.Dot(this.velocity, this._tempVector), t = this._tempVector.lengthSquared() - 1, u = c(r, s, t, p), u.found && (p = u.root, o = !0, this._collisionPoint.copyFrom(f)), this.basePoint.subtractToRef(g, this._tempVector), s = 2 * a.Vector3.Dot(this.velocity, this._tempVector), t = this._tempVector.lengthSquared() - 1, u = c(r, s, t, p), u.found && (p = u.root, o = !0, this._collisionPoint.copyFrom(g)), f.subtractToRef(e, this._edge), e.subtractToRef(this.basePoint, this._baseToVertex); var v = this._edge.lengthSquared(), w = a.Vector3.Dot(this._edge, this.velocity), x = a.Vector3.Dot(this._edge, this._baseToVertex); if (r = v * -q + w * w, s = 2 * v * a.Vector3.Dot(this.velocity, this._baseToVertex) - 2 * w * x, t = v * (1 - this._baseToVertex.lengthSquared()) + x * x, u = c(r, s, t, p), u.found) { var y = (w * u.root - x) / v; y >= 0 && 1 >= y && (p = u.root, o = !0, this._edge.scaleInPlace(y), e.addToRef(this._edge, this._collisionPoint)) } g.subtractToRef(f, this._edge), f.subtractToRef(this.basePoint, this._baseToVertex), v = this._edge.lengthSquared(), w = a.Vector3.Dot(this._edge, this.velocity), x = a.Vector3.Dot(this._edge, this._baseToVertex), r = v * -q + w * w, s = 2 * v * a.Vector3.Dot(this.velocity, this._baseToVertex) - 2 * w * x, t = v * (1 - this._baseToVertex.lengthSquared()) + x * x, u = c(r, s, t, p), u.found && (y = (w * u.root - x) / v, y >= 0 && 1 >= y && (p = u.root, o = !0, this._edge.scaleInPlace(y), f.addToRef(this._edge, this._collisionPoint))), e.subtractToRef(g, this._edge), g.subtractToRef(this.basePoint, this._baseToVertex), v = this._edge.lengthSquared(), w = a.Vector3.Dot(this._edge, this.velocity), x = a.Vector3.Dot(this._edge, this._baseToVertex), r = v * -q + w * w, s = 2 * v * a.Vector3.Dot(this.velocity, this._baseToVertex) - 2 * w * x, t = v * (1 - this._baseToVertex.lengthSquared()) + x * x, u = c(r, s, t, p), u.found && (y = (w * u.root - x) / v, y >= 0 && 1 >= y && (p = u.root, o = !0, this._edge.scaleInPlace(y), g.addToRef(this._edge, this._collisionPoint))) } if (o) { var z = p * this.velocity.length(); (!this.collisionFound || z < this.nearestDistance) && (this.intersectionPoint ? this.intersectionPoint.copyFrom(this._collisionPoint) : this.intersectionPoint = this._collisionPoint.clone(), this.nearestDistance = z, this.collisionFound = !0, this.collidedMesh = d.getMesh()) } } }, d.prototype._collide = function (a, b, c, d, e, f) { for (var g = d; e > g; g += 3) { var h = b[c[g] - f], i = b[c[g + 1] - f], j = b[c[g + 2] - f]; this._testTriangle(g, a, j, i, h) } }, d.prototype._getResponse = function (b, c) { b.addToRef(c, this._destinationPoint), c.scaleInPlace(this.nearestDistance / c.length()), this.basePoint.addToRef(c, b), b.subtractToRef(this.intersectionPoint, this._slidePlaneNormal), this._slidePlaneNormal.normalize(), this._slidePlaneNormal.scaleToRef(this.epsilon, this._displacementVector), b.addInPlace(this._displacementVector), this.intersectionPoint.addInPlace(this._displacementVector), this._slidePlaneNormal.scaleInPlace(a.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint)), this._destinationPoint.subtractInPlace(this._slidePlaneNormal), this._destinationPoint.subtractToRef(this.intersectionPoint, c) }, d }(); a.Collider = d }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { BABYLON.InputControllerTarget = function () { this._position = new BABYLON.Vector3(0, 0, 0), this._orientation = { yaw: 0, pitch: 0, roll: 0 } }, BABYLON.InputControllerTarget.prototype.getPosition = function () { return this._position }, BABYLON.InputControllerTarget.prototype.getOrientation = function () { return this._orientation }, BABYLON.InputControllerTarget.prototype.moveRelative = function () { }, BABYLON.InputControllerTarget.prototype.rotateRelative = function () { }, BABYLON.InputControllerTarget.prototype.getOrientationMatrix = function () { return new BABYLON.Matrix }, BABYLON.InputControllerTarget.prototype.getInvertOrientationMatrix = function () { return new BABYLON.Matrix }, BABYLON.InputControllerMultiTarget = function (a) { this.targets = a; var b = this.targets[0]; b.controllers ? b.controllers.push(this) : b.controllers = [this] }, BABYLON.InputControllerMultiTarget.prototype.getPosition = function () { return this.targets[0].getPosition() }, BABYLON.InputControllerMultiTarget.prototype.getOrientation = function () { return this.targets[0].getOrientation() }, BABYLON.InputControllerMultiTarget.prototype.getOrientationMatrix = function () { return this.targets[0].getOrientationMatrix() }, BABYLON.InputControllerMultiTarget.prototype.getInvertOrientationMatrix = function () { return this.targets[0].getInvertOrientationMatrix() }, BABYLON.InputControllerMultiTarget.prototype.moveRelative = function (a) { for (var b = 0; b < this.targets.length; ++b) this.targets[b].moveRelative(a) }, BABYLON.InputControllerMultiTarget.prototype.rotateRelative = function (a) { for (var b = 0; b < this.targets.length; ++b) this.targets[b].rotateRelative(a) }, BABYLON.InputControllerMultiTarget.prototype.update = function () { if (this.controllers) for (var a = 0; a < this.controllers.length; ++a) this.controllers[a].update() }, BABYLON.InputController = function (a, b) { this.scene = a, this.target = b, this.target.controllers ? this.target.controllers.push(this) : this.target.controllers = [this] }, BABYLON.InputController.prototype.attachToCanvas = function () { }, BABYLON.InputController.prototype.detachFromCanvas = function () { }, BABYLON.InputController.prototype.update = function () { }, BABYLON.InputController.prototype.dispose = function () { }, BABYLON.inputFilter = function (a, b) { BABYLON.InputController.call(this, a, b) }, BABYLON.inputFilter.prototype = Object.create(BABYLON.InputController.prototype), BABYLON.inputFilter.prototype.update = function () { if (this.controllers) for (var a = 0; a < this.controllers.length; ++a) this.controllers[a].update() }, BABYLON.inputFilter.prototype.getPosition = function () { return this.target.getPosition() }, BABYLON.inputFilter.prototype.getOrientation = function () { return this.target.getOrientation() }, BABYLON.inputFilter.prototype.getOrientationMatrix = function () { return this.target.getOrientationMatrix() }, BABYLON.inputFilter.prototype.getInvertOrientationMatrix = function () { return this.target.getInvertOrientationMatrix() }, BABYLON.inputFilter.prototype.moveRelative = function (a) { this.target.moveRelative(a) }, BABYLON.inputFilter.prototype.rotateRelative = function (a) { this.target.rotateRelative(a) } }(); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(d, e, f) { b.call(this, d, f), this.position = e, this.upVector = a.Vector3.Up(), this.orthoLeft = null, this.orthoRight = null, this.orthoBottom = null, this.orthoTop = null, this.fov = .8, this.minZ = .1, this.maxZ = 1e3, this.inertia = .9, this.mode = c.PERSPECTIVE_CAMERA, this.isIntermediate = !1, this.viewport = new a.Viewport(0, 0, 1, 1), this.subCameras = [], this._computedViewMatrix = a.Matrix.Identity(), this._projectionMatrix = new a.Matrix, this._postProcesses = [], this._postProcessesTakenIndices = [], f.cameras.push(this), f.activeCamera || (f.activeCamera = this) } return __extends(c, b), c.prototype._initCache = function () { b.prototype._initCache.call(this), this._cache.position = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0 }, c.prototype._updateCache = function (a) { a || b.prototype._updateCache.call(this); var c = this.getEngine(); this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector), this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._cache.fov = this.fov, this._cache.aspectRatio = c.getAspectRatio(this), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.renderWidth = c.getRenderWidth(), this._cache.renderHeight = c.getRenderHeight() }, c.prototype._updateFromScene = function () { this.updateCache(), this._update() }, c.prototype._isSynchronized = function () { return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix() }, c.prototype._isSynchronizedViewMatrix = function () { return b.prototype._isSynchronized.call(this) ? this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent() : !1 }, c.prototype._isSynchronizedProjectionMatrix = function () { var b = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ; if (!b) return !1; var c = this.getEngine(); return b = this.mode === a.Camera.PERSPECTIVE_CAMERA ? this._cache.fov === this.fov && this._cache.aspectRatio === c.getAspectRatio(this) : this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === c.getRenderWidth() && this._cache.renderHeight === c.getRenderHeight() }, c.prototype.attachControl = function () { }, c.prototype.detachControl = function () { }, c.prototype._update = function () { }, c.prototype.attachPostProcess = function (b, c) { if ("undefined" == typeof c && (c = null), !b.isReusable() && this._postProcesses.indexOf(b) > -1) return a.Tools.Error("You're trying to reuse a post process not defined as reusable."), 0; if (null == c || 0 > c) return this._postProcesses.push(b), this._postProcessesTakenIndices.push(this._postProcesses.length - 1), this._postProcesses.length - 1; var d = 0; if (this._postProcesses[c]) { for (var e = this._postProcesses.length - 1, f = e; f >= c + 1; --f) this._postProcesses[f + 1] = this._postProcesses[f]; d = 1 } for (f = 0; f < this._postProcessesTakenIndices.length; ++f) if (!(this._postProcessesTakenIndices[f] < c)) { e = this._postProcessesTakenIndices.length - 1; for (var g = e; g >= f; --g) this._postProcessesTakenIndices[g + 1] = this._postProcessesTakenIndices[g] + d; this._postProcessesTakenIndices[f] = c; break } d || -1 != this._postProcessesTakenIndices.indexOf(c) || this._postProcessesTakenIndices.push(c); var h = c + d; return this._postProcesses[h] = b, h }, c.prototype.detachPostProcess = function (a, b) { "undefined" == typeof b && (b = null); var c = []; if (b) for (b = b instanceof Array ? b : [b], f = 0; f < b.length; f++) { var d = this._postProcesses[b[f]]; d === a ? (delete this._postProcesses[b[f]], g = this._postProcessesTakenIndices.indexOf(b[f]), this._postProcessesTakenIndices.splice(g, 1)) : c.push(f) } else for (var e = this._postProcesses.length, f = 0; e > f; f++) if (this._postProcesses[f] === a) { delete this._postProcesses[f]; var g = this._postProcessesTakenIndices.indexOf(f); this._postProcessesTakenIndices.splice(g, 1) } return c }, c.prototype.getWorldMatrix = function () { this._worldMatrix || (this._worldMatrix = a.Matrix.Identity()); var b = this.getViewMatrix(); return b.invertToRef(this._worldMatrix), this._worldMatrix }, c.prototype._getViewMatrix = function () { return a.Matrix.Identity() }, c.prototype.getViewMatrix = function () { return this._computedViewMatrix = this._computeViewMatrix(), this.parent && this.parent.getWorldMatrix && !this.isSynchronized() ? (this._worldMatrix || (this._worldMatrix = a.Matrix.Identity()), this._computedViewMatrix.invertToRef(this._worldMatrix), this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._computedViewMatrix), this._computedViewMatrix.invert(), this._currentRenderId = this.getScene().getRenderId(), this._computedViewMatrix) : this._computedViewMatrix }, c.prototype._computeViewMatrix = function (a) { return !a && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this._computedViewMatrix = this._getViewMatrix(), this.parent && this.parent.getWorldMatrix || (this._currentRenderId = this.getScene().getRenderId()), this._computedViewMatrix) }, c.prototype.getProjectionMatrix = function (b) { if (!b && this._isSynchronizedProjectionMatrix()) return this._projectionMatrix; var c = this.getEngine(); if (this.mode === a.Camera.PERSPECTIVE_CAMERA) return a.Matrix.PerspectiveFovLHToRef(this.fov, c.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix), this._projectionMatrix; var d = c.getRenderWidth() / 2, e = c.getRenderHeight() / 2; return a.Matrix.OrthoOffCenterLHToRef(this.orthoLeft || -d, this.orthoRight || d, this.orthoBottom || -e, this.orthoTop || e, this.minZ, this.maxZ, this._projectionMatrix), this._projectionMatrix }, c.prototype.dispose = function () { var a = this.getScene().cameras.indexOf(this); this.getScene().cameras.splice(a, 1); for (var b = 0; b < this._postProcessesTakenIndices.length; ++b) this._postProcesses[this._postProcessesTakenIndices[b]].dispose(this) }, c.PERSPECTIVE_CAMERA = 0, c.ORTHOGRAPHIC_CAMERA = 1, c }(a.Node); a.Camera = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) {
	var b = function (b) {
		function c(c, d, e) { b.call(this, c, d, e), this.cameraDirection = new a.Vector3(0, 0, 0), this.cameraRotation = new a.Vector2(0, 0), this.rotation = new a.Vector3(0, 0, 0), this.ellipsoid = new a.Vector3(.5, 1, .5), this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39], this.speed = 2, this.checkCollisions = !1, this.applyGravity = !1, this.noRotationConstraint = !1, this.angularSensibility = 2e3, this.lockedTarget = null, this.onCollide = null, this._keys = [], this._collider = new a.Collider, this._needMoveForGravity = !0, this._currentTarget = a.Vector3.Zero(), this._viewMatrix = a.Matrix.Zero(), this._camMatrix = a.Matrix.Zero(), this._cameraTransformMatrix = a.Matrix.Zero(), this._cameraRotationMatrix = a.Matrix.Zero(), this._referencePoint = a.Vector3.Zero(), this._transformedReferencePoint = a.Vector3.Zero(), this._oldPosition = a.Vector3.Zero(), this._diffPosition = a.Vector3.Zero(), this._newPosition = a.Vector3.Zero(), this._lookAtTemp = a.Matrix.Zero(), this._tempMatrix = a.Matrix.Zero() } return __extends(c, b), c.prototype._getLockedTargetPosition = function () { return this.lockedTarget ? this.lockedTarget.position || this.lockedTarget : null }, c.prototype._initCache = function () { b.prototype._initCache.call(this), this._cache.lockedTarget = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE) }, c.prototype._updateCache = function (a) { a || b.prototype._updateCache.call(this); var c = this._getLockedTargetPosition(); c ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(c) : this._cache.lockedTarget = c.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation) }, c.prototype._isSynchronizedViewMatrix = function () { if (!b.prototype._isSynchronizedViewMatrix.call(this)) return !1; var a = this._getLockedTargetPosition(); return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(a) : !a) && this._cache.rotation.equals(this.rotation) }, c.prototype._computeLocalCameraSpeed = function () { return this.speed * (a.Tools.GetDeltaTime() / (10 * a.Tools.GetFps())) }, c.prototype.setTarget = function (b) { this.upVector.normalize(), a.Matrix.LookAtLHToRef(this.position, b, this.upVector, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]); var c = b.subtract(this.position); this.rotation.y = c.x >= 0 ? -Math.atan(c.z / c.x) + Math.PI / 2 : -Math.atan(c.z / c.x) - Math.PI / 2, this.rotation.z = -Math.acos(a.Vector3.Dot(new a.Vector3(0, 1, 0), this.upVector)), isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0) }, c.prototype.getTarget = function () { return this._currentTarget }, c.prototype.attachControl = function (b, c) {
			var d, e = this, f = this.getEngine(); this._attachedElement || (this._attachedElement = b, void 0 === this._onMouseDown && (this._onMouseDown = function (a) {
				d = { x: a.clientX, y: a.clientY }, c || a.preventDefault()
			}, this._onMouseUp = function (a) { d = null, c || a.preventDefault() }, this._onMouseOut = function (a) { d = null, e._keys = [], c || a.preventDefault() }, this._onMouseMove = function (a) { if (d || f.isPointerLock) { var b, g; f.isPointerLock ? (b = a.movementX || a.mozMovementX || a.webkitMovementX || a.msMovementX || 0, g = a.movementY || a.mozMovementY || a.webkitMovementY || a.msMovementY || 0) : (b = a.clientX - d.x, g = a.clientY - d.y), e.cameraRotation.y += b / e.angularSensibility, e.cameraRotation.x += g / e.angularSensibility, d = { x: a.clientX, y: a.clientY }, c || a.preventDefault() } }, this._onKeyDown = function (a) { if (-1 !== e.keysUp.indexOf(a.keyCode) || -1 !== e.keysDown.indexOf(a.keyCode) || -1 !== e.keysLeft.indexOf(a.keyCode) || -1 !== e.keysRight.indexOf(a.keyCode)) { var b = e._keys.indexOf(a.keyCode); -1 === b && e._keys.push(a.keyCode), c || a.preventDefault() } }, this._onKeyUp = function (a) { if (-1 !== e.keysUp.indexOf(a.keyCode) || -1 !== e.keysDown.indexOf(a.keyCode) || -1 !== e.keysLeft.indexOf(a.keyCode) || -1 !== e.keysRight.indexOf(a.keyCode)) { var b = e._keys.indexOf(a.keyCode); b >= 0 && e._keys.splice(b, 1), c || a.preventDefault() } }, this._onLostFocus = function () { e._keys = [] }, this._reset = function () { e._keys = [], d = null, e.cameraDirection = new a.Vector3(0, 0, 0), e.cameraRotation = new a.Vector2(0, 0) }), b.addEventListener("mousedown", this._onMouseDown, !1), b.addEventListener("mouseup", this._onMouseUp, !1), b.addEventListener("mouseout", this._onMouseOut, !1), b.addEventListener("mousemove", this._onMouseMove, !1), a.Tools.RegisterTopRootEvents([{ name: "keydown", handler: this._onKeyDown }, { name: "keyup", handler: this._onKeyUp }, { name: "blur", handler: this._onLostFocus }]))
		}, c.prototype.detachControl = function (b) { this._attachedElement == b && (b.removeEventListener("mousedown", this._onMouseDown), b.removeEventListener("mouseup", this._onMouseUp), b.removeEventListener("mouseout", this._onMouseOut), b.removeEventListener("mousemove", this._onMouseMove), a.Tools.UnregisterTopRootEvents([{ name: "keydown", handler: this._onKeyDown }, { name: "keyup", handler: this._onKeyUp }, { name: "blur", handler: this._onLostFocus }]), this._attachedElement = null, this._reset && this._reset()) }, c.prototype._collideWithWorld = function (b) { var c; c = this.parent ? a.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix()) : this.position, c.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition), this._collider.radius = this.ellipsoid, this.getScene()._getNewPosition(this._oldPosition, b, this._collider, 3, this._newPosition), this._newPosition.subtractToRef(this._oldPosition, this._diffPosition), this._diffPosition.length() > a.Engine.CollisionsEpsilon && (this.position.addInPlace(this._diffPosition), this.onCollide && this.onCollide(this._collider.collidedMesh)) }, c.prototype._checkInputs = function () { this._localDirection || (this._localDirection = a.Vector3.Zero(), this._transformedDirection = a.Vector3.Zero()); for (var b = 0; b < this._keys.length; b++) { var c = this._keys[b], d = this._computeLocalCameraSpeed(); -1 !== this.keysLeft.indexOf(c) ? this._localDirection.copyFromFloats(-d, 0, 0) : -1 !== this.keysUp.indexOf(c) ? this._localDirection.copyFromFloats(0, 0, d) : -1 !== this.keysRight.indexOf(c) ? this._localDirection.copyFromFloats(d, 0, 0) : -1 !== this.keysDown.indexOf(c) && this._localDirection.copyFromFloats(0, 0, -d), this.getViewMatrix().invertToRef(this._cameraTransformMatrix), a.Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection), this.cameraDirection.addInPlace(this._transformedDirection) } }, c.prototype._update = function () { this._checkInputs(); var b = this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0, c = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0; if (b) if (this.checkCollisions && this.getScene().collisionsEnabled) { if (this._collideWithWorld(this.cameraDirection), this.applyGravity) { var d = this.position; this._collideWithWorld(this.getScene().gravity), this._needMoveForGravity = 0 != a.Vector3.DistanceSquared(d, this.position) } } else this.position.addInPlace(this.cameraDirection); if (c && (this.rotation.x += this.cameraRotation.x, this.rotation.y += this.cameraRotation.y, !this.noRotationConstraint)) { var e = Math.PI / 2 * .95; this.rotation.x > e && (this.rotation.x = e), this.rotation.x < -e && (this.rotation.x = -e) } b && (Math.abs(this.cameraDirection.x) < a.Engine.Epsilon && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < a.Engine.Epsilon && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < a.Engine.Epsilon && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), c && (Math.abs(this.cameraRotation.x) < a.Engine.Epsilon && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < a.Engine.Epsilon && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)) }, c.prototype._getViewMatrix = function () { return a.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint), this.lockedTarget ? this._currentTarget.copyFrom(this._getLockedTargetPosition()) : (0 != this.upVector.x || 1 != this.upVector.y || 0 != this.upVector.z ? (a.Matrix.LookAtLHToRef(a.Vector3.Zero(), this._referencePoint, this.upVector, this._lookAtTemp), a.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix), this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix, this._tempMatrix), this._lookAtTemp.invert(), this._tempMatrix.multiplyToRef(this._lookAtTemp, this._cameraRotationMatrix)) : a.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix), a.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget)), a.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix), this._viewMatrix }, c
	}(a.Camera); a.FreeCamera = b
}(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { BABYLON.TouchCamera = function (a, b, c) { BABYLON.FreeCamera.call(this, a, b, c), this._offsetX = null, this._offsetY = null, this._pointerCount = 0, this._pointerPressed = [] }, BABYLON.TouchCamera.prototype = Object.create(BABYLON.FreeCamera.prototype), BABYLON.TouchCamera.prototype.angularSensibility = 2e5, BABYLON.TouchCamera.prototype.moveSensibility = 500, BABYLON.TouchCamera.prototype.attachControl = function (a, b) { var c, d = this; this._attachedCanvas || (this._attachedCanvas = a, void 0 === this._onPointerDown && (this._onPointerDown = function (a) { b || a.preventDefault(), d._pointerPressed.push(a.pointerId), 1 === d._pointerPressed.length && (c = { x: a.clientX, y: a.clientY }) }, this._onPointerUp = function (a) { b || a.preventDefault(); var e = d._pointerPressed.indexOf(a.pointerId); -1 !== e && (d._pointerPressed.splice(e, 1), 0 == e && (c = null, d._offsetX = null, d._offsetY = null)) }, this._onPointerMove = function (a) { if (b || a.preventDefault(), c) { var e = d._pointerPressed.indexOf(a.pointerId); 0 == e && (d._offsetX = a.clientX - c.x, d._offsetY = -(a.clientY - c.y)) } }, this._onLostFocus = function () { d._offsetX = null, d._offsetY = null }), a.addEventListener("pointerdown", this._onPointerDown), a.addEventListener("pointerup", this._onPointerUp), a.addEventListener("pointerout", this._onPointerUp), a.addEventListener("pointermove", this._onPointerMove), BABYLON.Tools.RegisterTopRootEvents([{ name: "blur", handler: this._onLostFocus }])) }, BABYLON.TouchCamera.prototype.detachControl = function (a) { this._attachedCanvas == a && (a.removeEventListener("pointerdown", this._onPointerDown), a.removeEventListener("pointerup", this._onPointerUp), a.removeEventListener("pointerout", this._onPointerUp), a.removeEventListener("pointermove", this._onPointerMove), BABYLON.Tools.UnregisterTopRootEvents([{ name: "blur", handler: this._onLostFocus }]), this._attachedCanvas = null) }, BABYLON.TouchCamera.prototype._checkInputs = function () { if (this._offsetX) if (this.cameraRotation.y += this._offsetX / this.angularSensibility, this._pointerPressed.length > 1) this.cameraRotation.x += -this._offsetY / this.angularSensibility; else { var a = this._computeLocalCameraSpeed(), b = new BABYLON.Vector3(0, 0, a * this._offsetY / this.moveSensibility); BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, 0, this._cameraRotationMatrix), this.cameraDirection.addInPlace(BABYLON.Vector3.TransformCoordinates(b, this._cameraRotationMatrix)) } } }(); var BABYLON = BABYLON || {}; !function () { BABYLON.DeviceOrientationCamera = function (a, b, c) { BABYLON.FreeCamera.call(this, a, b, c), this._offsetX = null, this._offsetY = null, this._orientationGamma = 0, this._orientationBeta = 0, this._initialOrientationGamma = 0, this._initialOrientationBeta = 0 }, BABYLON.DeviceOrientationCamera.prototype = Object.create(BABYLON.FreeCamera.prototype), BABYLON.DeviceOrientationCamera.prototype.angularSensibility = 1e4, BABYLON.DeviceOrientationCamera.prototype.moveSensibility = 50, BABYLON.DeviceOrientationCamera.prototype.attachControl = function (a) { if (!this._attachedCanvas) { this._attachedCanvas = a; var b = this; this._orientationChanged || (this._orientationChanged = function (a) { b._initialOrientationGamma || (b._initialOrientationGamma = a.gamma, b._initialOrientationBeta = a.beta), b._orientationGamma = a.gamma, b._orientationBeta = a.beta, b._offsetY = b._initialOrientationBeta - b._orientationBeta, b._offsetX = b._initialOrientationGamma - b._orientationGamma }), window.addEventListener("deviceorientation", this._orientationChanged) } }, BABYLON.DeviceOrientationCamera.prototype.detachControl = function (a) { this._attachedCanvas == a && (window.removeEventListener("deviceorientation", this._orientationChanged), this._attachedCanvas = null, this._orientationGamma = 0, this._orientationBeta = 0, this._initialOrientationGamma = 0, this._initialOrientationBeta = 0) }, BABYLON.DeviceOrientationCamera.prototype._checkInputs = function () { if (this._offsetX) { this.cameraRotation.y -= this._offsetX / this.angularSensibility; var a = this._computeLocalCameraSpeed(), b = new BABYLON.Vector3(0, 0, a * this._offsetY / this.moveSensibility); BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, 0, this._cameraRotationMatrix), this.cameraDirection.addInPlace(BABYLON.Vector3.TransformCoordinates(b, this._cameraRotationMatrix)) } } }(); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = a.Tools.GetPointerPrefix(), c = function (c) { function d(b, d, e, f, g, h) { c.call(this, b, a.Vector3.Zero(), h), this.alpha = d, this.beta = e, this.radius = f, this.target = g, this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.lowerAlphaLimit = null, this.upperAlphaLimit = null, this.lowerBetaLimit = .01, this.upperBetaLimit = Math.PI, this.lowerRadiusLimit = null, this.upperRadiusLimit = null, this.angularSensibility = 1e3, this.wheelPrecision = 3, this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39], this.zoomOnFactor = 1, this._keys = [], this._viewMatrix = new a.Matrix, this.getViewMatrix() } return __extends(d, c), d.prototype._getTargetPosition = function () { return this.target.position || this.target }, d.prototype._initCache = function () { c.prototype._initCache.call(this), this._cache.target = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.alpha = void 0, this._cache.beta = void 0, this._cache.radius = void 0 }, d.prototype._updateCache = function (a) { a || c.prototype._updateCache.call(this), this._cache.target.copyFrom(this._getTargetPosition()), this._cache.alpha = this.alpha, this._cache.beta = this.beta, this._cache.radius = this.radius }, d.prototype._isSynchronizedViewMatrix = function () { return c.prototype._isSynchronizedViewMatrix.call(this) ? this._cache.target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius : !1 }, d.prototype.attachControl = function (c, d) { var e, f, g = this; if (!this._attachedElement) { this._attachedElement = c; var h = this.getEngine(); void 0 === this._onPointerDown && (this._onPointerDown = function (a) { f || (f = a.pointerId, e = { x: a.clientX, y: a.clientY }, d || a.preventDefault()) }, this._onPointerUp = function (a) { e = null, f = null, d || a.preventDefault() }, this._onPointerMove = function (a) { if (e && f === a.pointerId) { var b = a.clientX - e.x, c = a.clientY - e.y; g.inertialAlphaOffset -= b / g.angularSensibility, g.inertialBetaOffset -= c / g.angularSensibility, e = { x: a.clientX, y: a.clientY }, d || a.preventDefault() } }, this._onMouseMove = function (a) { if (h.isPointerLock) { var b = a.movementX || a.mozMovementX || a.webkitMovementX || a.msMovementX || 0, c = a.movementY || a.mozMovementY || a.webkitMovementY || a.msMovementY || 0; g.inertialAlphaOffset -= b / g.angularSensibility, g.inertialBetaOffset -= c / g.angularSensibility, d || a.preventDefault() } }, this._wheel = function (a) { var b = 0; a.wheelDelta ? b = a.wheelDelta / (40 * g.wheelPrecision) : a.detail && (b = -a.detail / g.wheelPrecision), b && (g.inertialRadiusOffset += b), a.preventDefault && (d || a.preventDefault()) }, this._onKeyDown = function (a) { if (-1 !== g.keysUp.indexOf(a.keyCode) || -1 !== g.keysDown.indexOf(a.keyCode) || -1 !== g.keysLeft.indexOf(a.keyCode) || -1 !== g.keysRight.indexOf(a.keyCode)) { var b = g._keys.indexOf(a.keyCode); -1 === b && g._keys.push(a.keyCode), a.preventDefault && (d || a.preventDefault()) } }, this._onKeyUp = function (a) { if (-1 !== g.keysUp.indexOf(a.keyCode) || -1 !== g.keysDown.indexOf(a.keyCode) || -1 !== g.keysLeft.indexOf(a.keyCode) || -1 !== g.keysRight.indexOf(a.keyCode)) { var b = g._keys.indexOf(a.keyCode); b >= 0 && g._keys.splice(b, 1), a.preventDefault && (d || a.preventDefault()) } }, this._onLostFocus = function () { g._keys = [], f = null }, this._onGestureStart = function (a) { void 0 !== window.MSGesture && (g._MSGestureHandler || (g._MSGestureHandler = new MSGesture, g._MSGestureHandler.target = c), g._MSGestureHandler.addPointer(a.pointerId)) }, this._onGesture = function (a) { g.radius *= a.scale, a.preventDefault && (d || (a.stopPropagation(), a.preventDefault())) }, this._reset = function () { g._keys = [], g.inertialAlphaOffset = 0, g.inertialBetaOffset = 0, e = null, f = null }), c.addEventListener(b + "down", this._onPointerDown, !1), c.addEventListener(b + "up", this._onPointerUp, !1), c.addEventListener(b + "out", this._onPointerUp, !1), c.addEventListener(b + "move", this._onPointerMove, !1), c.addEventListener("mousemove", this._onMouseMove, !1), c.addEventListener("MSPointerDown", this._onGestureStart, !1), c.addEventListener("MSGestureChange", this._onGesture, !1), c.addEventListener("mousewheel", this._wheel, !1), c.addEventListener("DOMMouseScroll", this._wheel, !1), a.Tools.RegisterTopRootEvents([{ name: "keydown", handler: this._onKeyDown }, { name: "keyup", handler: this._onKeyUp }, { name: "blur", handler: this._onLostFocus }]) } }, d.prototype.detachControl = function (c) { this._attachedElement == c && (c.removeEventListener(b + "down", this._onPointerDown), c.removeEventListener(b + "up", this._onPointerUp), c.removeEventListener(b + "out", this._onPointerUp), c.removeEventListener(b + "move", this._onPointerMove), c.removeEventListener("mousemove", this._onMouseMove), c.removeEventListener("MSPointerDown", this._onGestureStart), c.removeEventListener("MSGestureChange", this._onGesture), c.removeEventListener("mousewheel", this._wheel), c.removeEventListener("DOMMouseScroll", this._wheel), a.Tools.UnregisterTopRootEvents([{ name: "keydown", handler: this._onKeyDown }, { name: "keyup", handler: this._onKeyUp }, { name: "blur", handler: this._onLostFocus }]), this._MSGestureHandler = null, this._attachedElement = null, this._reset && this._reset()) }, d.prototype._update = function () { for (var b = 0; b < this._keys.length; b++) { var c = this._keys[b]; -1 !== this.keysLeft.indexOf(c) ? this.inertialAlphaOffset -= .01 : -1 !== this.keysUp.indexOf(c) ? this.inertialBetaOffset -= .01 : -1 !== this.keysRight.indexOf(c) ? this.inertialAlphaOffset += .01 : -1 !== this.keysDown.indexOf(c) && (this.inertialBetaOffset += .01) } (0 != this.inertialAlphaOffset || 0 != this.inertialBetaOffset || 0 != this.inertialRadiusOffset) && (this.alpha += this.inertialAlphaOffset, this.beta += this.inertialBetaOffset, this.radius -= this.inertialRadiusOffset, this.inertialAlphaOffset *= this.inertia, this.inertialBetaOffset *= this.inertia, this.inertialRadiusOffset *= this.inertia, Math.abs(this.inertialAlphaOffset) < a.Engine.Epsilon && (this.inertialAlphaOffset = 0), Math.abs(this.inertialBetaOffset) < a.Engine.Epsilon && (this.inertialBetaOffset = 0), Math.abs(this.inertialRadiusOffset) < a.Engine.Epsilon && (this.inertialRadiusOffset = 0)), this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit && (this.alpha = this.lowerAlphaLimit), this.upperAlphaLimit && this.alpha > this.upperAlphaLimit && (this.alpha = this.upperAlphaLimit), this.lowerBetaLimit && this.beta < this.lowerBetaLimit && (this.beta = this.lowerBetaLimit), this.upperBetaLimit && this.beta > this.upperBetaLimit && (this.beta = this.upperBetaLimit), this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit && (this.radius = this.lowerRadiusLimit), this.upperRadiusLimit && this.radius > this.upperRadiusLimit && (this.radius = this.upperRadiusLimit) }, d.prototype.setPosition = function (a) { var b = a.subtract(this._getTargetPosition()); this.radius = b.length(), this.alpha = Math.atan(b.z / b.x), this.beta = Math.acos(b.y / this.radius) }, d.prototype._getViewMatrix = function () { var b = Math.cos(this.alpha), c = Math.sin(this.alpha), d = Math.cos(this.beta), e = Math.sin(this.beta), f = this._getTargetPosition(); return f.addToRef(new a.Vector3(this.radius * b * e, this.radius * d, this.radius * c * e), this.position), a.Matrix.LookAtLHToRef(this.position, f, this.upVector, this._viewMatrix), this._viewMatrix }, d.prototype.zoomOn = function (b) { b = b || this.getScene().meshes; var c = a.Mesh.MinMax(b), d = a.Vector3.Distance(c.min, c.max); this.radius = d * this.zoomOnFactor, this.focusOn({ min: c.min, max: c.max, distance: d }) }, d.prototype.focusOn = function (b) { var c, d; void 0 === b.min ? (c = b || this.getScene().meshes, c = a.Mesh.MinMax(c), d = a.Vector3.Distance(c.min, c.max)) : (c = b, d = b.distance), this.target = a.Mesh.Center(c), this.maxZ = 2 * d }, d }(a.Camera); a.ArcRotateCamera = c }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function (a, b, c) { a.x < b.x && (b.x = a.x), a.y < b.y && (b.y = a.y), a.z < b.z && (b.z = a.z), a.x > c.x && (c.x = a.x), a.y > c.y && (c.y = a.y), a.z > c.z && (c.z = a.z) }, c = function () {
		function c(b) { this.autoClear = !0, this.clearColor = new a.Color3(.2, .2, .3), this.ambientColor = new a.Color3(0, 0, 0), this.forceWireframe = !1, this.fogMode = a.Scene.FOGMODE_NONE, this.fogColor = new a.Color3(.2, .2, .3), this.fogDensity = .1, this.fogStart = 0, this.fogEnd = 1e3, this.lightsEnabled = !0, this.lights = new Array, this.cameras = new Array, this.activeCameras = new Array, this.meshes = new Array, this._geometries = new Array, this.materials = new Array, this.multiMaterials = new Array, this.defaultMaterial = new a.StandardMaterial("default material", this), this.texturesEnabled = !0, this.textures = new Array, this.particlesEnabled = !0, this.particleSystems = new Array, this.spriteManagers = new Array, this.layers = new Array, this.skeletons = new Array, this.lensFlareSystems = new Array, this.collisionsEnabled = !0, this.gravity = new a.Vector3(0, -9, 0), this.postProcessesEnabled = !0, this.renderTargetsEnabled = !0, this.customRenderTargets = new Array, this.importedMeshesFiles = new Array, this._totalVertices = 0, this._activeVertices = 0, this._activeParticles = 0, this._lastFrameDuration = 0, this._evaluateActiveMeshesDuration = 0, this._renderTargetsDuration = 0, this._particlesDuration = 0, this._renderDuration = 0, this._spritesDuration = 0, this._animationRatio = 0, this._renderId = 0, this._executeWhenReadyTimeoutId = -1, this._toBeDisposed = new a.SmartArray(256), this._onReadyCallbacks = new Array, this._pendingData = [], this._onBeforeRenderCallbacks = new Array, this._activeMeshes = new a.SmartArray(256), this._processedMaterials = new a.SmartArray(256), this._renderTargets = new a.SmartArray(256), this._activeParticleSystems = new a.SmartArray(256), this._activeSkeletons = new a.SmartArray(32), this._activeAnimatables = new Array, this._transformMatrix = a.Matrix.Zero(), this._scaledPosition = a.Vector3.Zero(), this._scaledVelocity = a.Vector3.Zero(), this._engine = b, b.scenes.push(this), this._renderingManager = new a.RenderingManager(this), this.postProcessManager = new a.PostProcessManager(this), this._boundingBoxRenderer = new a.BoundingBoxRenderer(this), this.attachControl() } return c.prototype.getBoundingBoxRenderer = function () { return this._boundingBoxRenderer }, c.prototype.getEngine = function () { return this._engine }, c.prototype.getTotalVertices = function () { return this._totalVertices }, c.prototype.getActiveVertices = function () { return this._activeVertices }, c.prototype.getActiveParticles = function () { return this._activeParticles }, c.prototype.getLastFrameDuration = function () { return this._lastFrameDuration }, c.prototype.getEvaluateActiveMeshesDuration = function () { return this._evaluateActiveMeshesDuration }, c.prototype.getActiveMeshes = function () { return this._activeMeshes }, c.prototype.getRenderTargetsDuration = function () { return this._renderTargetsDuration }, c.prototype.getRenderDuration = function () { return this._renderDuration }, c.prototype.getParticlesDuration = function () { return this._particlesDuration }, c.prototype.getSpritesDuration = function () { return this._spritesDuration }, c.prototype.getAnimationRatio = function () { return this._animationRatio }, c.prototype.getRenderId = function () { return this._renderId }, c.prototype.attachControl = function () { var b = this; this._onPointerMove = function (a) { var c = b._engine.getRenderingCanvas(), d = b.pick(a.offsetX || a.layerX, a.offsetY || a.layerY, function (a) { return a.actionManager && a.isPickable }); d.hit ? (b.setPointerOverMesh(d.pickedMesh), c.style.cursor = "pointer") : (b.setPointerOverMesh(null), c.style.cursor = "") }, this._onPointerDown = function (c) { var d = b.pick(c.offsetX || c.layerX, c.offsetY || c.layerY); d.hit && d.pickedMesh.actionManager && d.pickedMesh.actionManager.processTrigger(a.ActionManager.OnPickTrigger), b.onPointerDown && b.onPointerDown(c, d) }; var c = a.Tools.GetPointerPrefix(); this._engine.getRenderingCanvas().addEventListener(c + "move", this._onPointerMove, !1), this._engine.getRenderingCanvas().addEventListener(c + "down", this._onPointerDown, !1) }, c.prototype.detachControl = function () { var b = a.Tools.GetPointerPrefix(); this._engine.getRenderingCanvas().removeEventListener(b + "move", this._onPointerMove), this._engine.getRenderingCanvas().removeEventListener(b + "down", this._onPointerDown) }, c.prototype.isReady = function () { if (this._pendingData.length > 0) return !1; for (var b = 0; b < this._geometries.length; b++) { var c = this._geometries[b]; if (c.delayLoadState === a.Engine.DELAYLOADSTATE_LOADING) return !1 } for (var b = 0; b < this.meshes.length; b++) { var d = this.meshes[b], e = d.material; if (d.delayLoadState === a.Engine.DELAYLOADSTATE_LOADING) return !1; if (e && !e.isReady(d)) return !1 } return !0 }, c.prototype.registerBeforeRender = function (a) { this._onBeforeRenderCallbacks.push(a) }, c.prototype.unregisterBeforeRender = function (a) { var b = this._onBeforeRenderCallbacks.indexOf(a); b > -1 && this._onBeforeRenderCallbacks.splice(b, 1) }, c.prototype._addPendingData = function (a) { this._pendingData.push(a) }, c.prototype._removePendingData = function (a) { var b = this._pendingData.indexOf(a); -1 !== b && this._pendingData.splice(b, 1) }, c.prototype.getWaitingItemsCount = function () { return this._pendingData.length }, c.prototype.executeWhenReady = function (a) { var b = this; this._onReadyCallbacks.push(a), -1 === this._executeWhenReadyTimeoutId && (this._executeWhenReadyTimeoutId = setTimeout(function () { b._checkIsReady() }, 150)) }, c.prototype._checkIsReady = function () { var a = this; return this.isReady() ? (this._onReadyCallbacks.forEach(function (a) { a() }), this._onReadyCallbacks = [], void (this._executeWhenReadyTimeoutId = -1)) : void (this._executeWhenReadyTimeoutId = setTimeout(function () { a._checkIsReady() }, 150)) }, c.prototype.beginAnimation = function (b, c, d, e, f, g) { if (void 0 === f && (f = 1), b.animations) { this.stopAnimation(b); var h = new a.Internals.Animatable(b, c, d, e, f, g); this._activeAnimatables.push(h) } if (b.getAnimatables) for (var i = b.getAnimatables(), j = 0; j < i.length; j++) this.beginAnimation(i[j], c, d, e, f, g) }, c.prototype.beginDirectAnimation = function (b, c, d, e, f, g, h) { void 0 === g && (g = 1); var i = new a.Internals.Animatable(b, d, e, f, g, h, c); this._activeAnimatables.push(i) }, c.prototype.stopAnimation = function (a) { if (a.animations) for (var b = 0; b < this._activeAnimatables.length; b++) if (this._activeAnimatables[b].target === a) return void this._activeAnimatables.splice(b, 1); if (a.getAnimatables) { var c = a.getAnimatables(); for (b = 0; b < c.length; b++) this.stopAnimation(c[b]) } }, c.prototype._animate = function () { this._animationStartDate || (this._animationStartDate = (new Date).getTime()); for (var a = (new Date).getTime(), b = a - this._animationStartDate, c = 0; c < this._activeAnimatables.length; c++) this._activeAnimatables[c]._animate(b) || (this._activeAnimatables.splice(c, 1), c--) }, c.prototype.getViewMatrix = function () { return this._viewMatrix }, c.prototype.getProjectionMatrix = function () { return this._projectionMatrix }, c.prototype.getTransformMatrix = function () { return this._transformMatrix }, c.prototype.setTransformMatrix = function (a, b) { this._viewMatrix = a, this._projectionMatrix = b, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix) }, c.prototype.setActiveCameraByID = function (a) { var b = this.getCameraByID(a); return b ? (this.activeCamera = b, b) : null }, c.prototype.setActiveCameraByName = function (a) { var b = this.getCameraByName(a); return b ? (this.activeCamera = b, b) : null }, c.prototype.getMaterialByID = function (a) { for (var b = 0; b < this.materials.length; b++) if (this.materials[b].id === a) return this.materials[b]; return null }, c.prototype.getMaterialByName = function (a) { for (var b = 0; b < this.materials.length; b++) if (this.materials[b].name === a) return this.materials[b]; return null }, c.prototype.getCameraByID = function (a) { for (var b = 0; b < this.cameras.length; b++) if (this.cameras[b].id === a) return this.cameras[b]; return null }, c.prototype.getCameraByName = function (a) { for (var b = 0; b < this.cameras.length; b++) if (this.cameras[b].name === a) return this.cameras[b]; return null }, c.prototype.getLightByName = function (a) { for (var b = 0; b < this.lights.length; b++) if (this.lights[b].name === a) return this.lights[b]; return null }, c.prototype.getLightByID = function (a) { for (var b = 0; b < this.lights.length; b++) if (this.lights[b].id === a) return this.lights[b]; return null }, c.prototype.getGeometryByID = function (a) { for (var b = 0; b < this._geometries.length; b++) if (this._geometries[b].id === a) return this._geometries[b]; return null }, c.prototype.pushGeometry = function (a, b) { return !b && this.getGeometryByID(a.id) ? !1 : (this._geometries.push(a), !0) }, c.prototype.getGeometries = function () { return this._geometries }, c.prototype.getMeshByID = function (a) { for (var b = 0; b < this.meshes.length; b++) if (this.meshes[b].id === a) return this.meshes[b]; return null }, c.prototype.getLastMeshByID = function (a) { for (var b = this.meshes.length - 1; b >= 0; b--) if (this.meshes[b].id === a) return this.meshes[b]; return null }, c.prototype.getLastEntryByID = function (a) { for (var b = this.meshes.length - 1; b >= 0; b--) if (this.meshes[b].id === a) return this.meshes[b]; for (b = this.cameras.length - 1; b >= 0; b--) if (this.cameras[b].id === a) return this.cameras[b]; for (b = this.lights.length - 1; b >= 0; b--) if (this.lights[b].id === a) return this.lights[b]; return null }, c.prototype.getMeshByName = function (a) { for (var b = 0; b < this.meshes.length; b++) if (this.meshes[b].name === a) return this.meshes[b]; return null }, c.prototype.getLastSkeletonByID = function (a) { for (var b = this.skeletons.length - 1; b >= 0; b--) if (this.skeletons[b].id === a) return this.skeletons[b]; return null }, c.prototype.getSkeletonById = function (a) { for (var b = 0; b < this.skeletons.length; b++) if (this.skeletons[b].id === a) return this.skeletons[b]; return null }, c.prototype.getSkeletonByName = function (a) { for (var b = 0; b < this.skeletons.length; b++) if (this.skeletons[b].name === a) return this.skeletons[b]; return null }, c.prototype.isActiveMesh = function (a) { return -1 !== this._activeMeshes.indexOf(a) }, c.prototype._evaluateSubMesh = function (a, b) { if (1 == b.subMeshes.length || a.isInFrustum(this._frustumPlanes)) { var c = a.getMaterial(); c && (c.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(c) && (this._processedMaterials.push(c), this._renderTargets.concat(c.getRenderTargetTextures())), this._activeVertices += a.verticesCount, this._renderingManager.dispatch(a)) } }, c.prototype._evaluateActiveMeshes = function () { if (this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._boundingBoxRenderer.reset(), this._frustumPlanes ? a.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = a.Frustum.GetPlanes(this._transformMatrix), this._selectionOctree) for (var b = this._selectionOctree.select(this._frustumPlanes), c = 0; c < b.length; c++) for (var d = b.data[c], e = 0; e < d.meshes.length; e++) { var f = d.meshes[e]; if (Math.abs(f._renderId) !== this._renderId) { if (this._totalVertices += f.getTotalVertices(), !f.isReady()) continue; f.computeWorldMatrix(), f._renderId = 0 } if (f._renderId === this._renderId || 0 === f._renderId && f.isEnabled() && f.isVisible && f.visibility > 0 && f.isInFrustum(this._frustumPlanes)) { 0 === f._renderId && this._activeMeshes.push(f), f._renderId = this._renderId, f.showBoundingBox && this._boundingBoxRenderer.renderList.push(f), f.skeleton && this._activeSkeletons.pushNoDuplicate(f.skeleton); var g = d.subMeshes[e]; for (h = 0; h < g.length; h++) i = g[h], i._renderId !== this._renderId && (i._renderId = this._renderId, this._evaluateSubMesh(i, f)) } else f._renderId = -this._renderId } else for (e = 0; e < this.meshes.length; e++) if (f = this.meshes[e], this._totalVertices += f.getTotalVertices(), f.isReady() && (f.computeWorldMatrix(), f.isEnabled() && f.isVisible && f.visibility > 0 && f.isInFrustum(this._frustumPlanes) && (this._activeMeshes.push(f), f.skeleton && this._activeSkeletons.pushNoDuplicate(f.skeleton), f.showBoundingBox && this._boundingBoxRenderer.renderList.push(f), f.subMeshes))) for (var h = 0; h < f.subMeshes.length; h++) { var i = f.subMeshes[h]; this._evaluateSubMesh(i, f) } var j = (new Date).getTime(); if (this.particlesEnabled) for (var k = 0; k < this.particleSystems.length; k++) { var l = this.particleSystems[k]; (!l.emitter.position || l.emitter && l.emitter.isEnabled()) && (this._activeParticleSystems.push(l), l.animate()) } this._particlesDuration += (new Date).getTime() - j }, c.prototype.updateTransformMatrix = function (a) { this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(a)) }, c.prototype._renderForCamera = function (a) { var b = this._engine; if (this.activeCamera = a, !this.activeCamera) throw new Error("Active camera not set"); b.setViewport(this.activeCamera.viewport), this._renderId++, this.updateTransformMatrix(); var c = (new Date).getTime(); this._evaluateActiveMeshes(), this._evaluateActiveMeshesDuration += (new Date).getTime() - c; for (var d = 0; d < this._activeSkeletons.length; d++) { var e = this._activeSkeletons.data[d]; e.prepare() } for (var f = 0; f < this.customRenderTargets.length; f++) this._renderTargets.push(this.customRenderTargets[f]); var g = (new Date).getTime(); if (this.renderTargetsEnabled) for (var h = 0; h < this._renderTargets.length; h++) { var i = this._renderTargets.data[h]; this._renderId++, i.render() } this._renderTargets.length > 0 && b.restoreDefaultFramebuffer(), this._renderTargetsDuration = (new Date).getTime() - g, this.postProcessManager._prepareFrame(); var j = (new Date).getTime(); if (this.layers.length) { b.setDepthBuffer(!1); var k, l; for (k = 0; k < this.layers.length; k++) l = this.layers[k], l.isBackground && l.render(); b.setDepthBuffer(!0) } this._renderingManager.render(null, null, !0, !0), this._boundingBoxRenderer.render(); for (var m = 0; m < this.lensFlareSystems.length; m++) this.lensFlareSystems[m].render(); if (this.layers.length) { for (b.setDepthBuffer(!1), k = 0; k < this.layers.length; k++) l = this.layers[k], l.isBackground || l.render(); b.setDepthBuffer(!0) } this._renderDuration += (new Date).getTime() - j, this.postProcessManager._finalizeFrame(a.isIntermediate), this.activeCamera._updateFromScene(), this._renderTargets.reset() }, c.prototype._processSubCameras = function (a) { if (0 == a.subCameras.length) return void this._renderForCamera(a); for (var b = 0; b < a.subCameras.length; b++) this._renderForCamera(a.subCameras[b]); this.activeCamera = a, this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix()), this.activeCamera._updateFromScene() }, c.prototype.render = function () {
			var b = (new Date).getTime(); this._particlesDuration = 0, this._spritesDuration = 0, this._activeParticles = 0, this._renderDuration = 0, this._evaluateActiveMeshesDuration = 0, this._totalVertices = 0, this._activeVertices = 0, this.actionManager && this.actionManager.processTrigger(a.ActionManager.OnEveryFrameTrigger), this.beforeRender && this.beforeRender(); for (var c = 0; c < this._onBeforeRenderCallbacks.length; c++) this._onBeforeRenderCallbacks[c](); var d = a.Tools.GetDeltaTime(); this._animationRatio = .06 * d, this._animate(), this._physicsEngine && this._physicsEngine._runOneStep(d / 1e3), this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe, !0); for (var e = 0; e < this.lights.length; e++) {
				var f = this.lights[e], g = f.getShadowGenerator(); f.isEnabled() && g && -1 !== g.getShadowMap().getScene().textures.indexOf(g.getShadowMap()) && this._renderTargets.push(g.getShadowMap())
			} if (this.activeCameras.length > 0) for (var h = this._renderId, i = 0; i < this.activeCameras.length; i++) this._renderId = h, this._processSubCameras(this.activeCameras[i]); else this._processSubCameras(this.activeCamera); this.afterRender && this.afterRender(); for (var j = 0; j < this._toBeDisposed.length; j++) this._toBeDisposed.data[j].dispose(), this._toBeDisposed[j] = null; this._toBeDisposed.reset(), this._lastFrameDuration = (new Date).getTime() - b
		}, c.prototype.dispose = function () { this.beforeRender = null, this.afterRender = null, this.skeletons = [], this._boundingBoxRenderer.dispose(), this.detachControl(); var a, b = this._engine.getRenderingCanvas(); for (a = 0; a < this.cameras.length; a++) this.cameras[a].detachControl(b); for (; this.lights.length;) this.lights[0].dispose(); for (; this.meshes.length;) this.meshes[0].dispose(!0); for (; this.cameras.length;) this.cameras[0].dispose(); for (; this.materials.length;) this.materials[0].dispose(); for (; this.particleSystems.length;) this.particleSystems[0].dispose(); for (; this.spriteManagers.length;) this.spriteManagers[0].dispose(); for (; this.layers.length;) this.layers[0].dispose(); for (; this.textures.length;) this.textures[0].dispose(); this.postProcessManager.dispose(), this._physicsEngine && this.disablePhysicsEngine(), a = this._engine.scenes.indexOf(this), this._engine.scenes.splice(a, 1), this._engine.wipeCaches() }, c.prototype._getNewPosition = function (a, b, c, d, e) { a.divideToRef(c.radius, this._scaledPosition), b.divideToRef(c.radius, this._scaledVelocity), c.retry = 0, c.initialVelocity = this._scaledVelocity, c.initialPosition = this._scaledPosition, this._collideWithWorld(this._scaledPosition, this._scaledVelocity, c, d, e), e.multiplyInPlace(c.radius) }, c.prototype._collideWithWorld = function (b, c, d, e, f) { var g = 10 * a.Engine.CollisionsEpsilon; if (d.retry >= e) return void f.copyFrom(b); d._initialize(b, c, g); for (var h = 0; h < this.meshes.length; h++) { var i = this.meshes[h]; i.isEnabled() && i.checkCollisions && i._checkCollision(d) } return d.collisionFound ? ((0 != c.x || 0 != c.y || 0 != c.z) && d._getResponse(b, c), c.length() <= g ? void f.copyFrom(b) : (d.retry++, void this._collideWithWorld(b, c, d, e, f))) : void b.addToRef(c, f) }, c.prototype.createOrUpdateSelectionOctree = function () { this._selectionOctree || (this._selectionOctree = new a.Octree); for (var c = new a.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), d = new a.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), e = 0; e < this.meshes.length; e++) { var f = this.meshes[e]; f.computeWorldMatrix(!0); var g = f.getBoundingInfo().boundingBox.minimumWorld, h = f.getBoundingInfo().boundingBox.maximumWorld; b(g, c, d), b(h, c, d) } this._selectionOctree.update(c, d, this.meshes) }, c.prototype.createPickingRay = function (b, c, d, e) { var f = this._engine; if (!e) { if (!this.activeCamera) throw new Error("Active camera not set"); e = this.activeCamera } var g = e.viewport, h = g.toGlobal(f); return b = b / this._engine.getHardwareScalingLevel() - h.x, c = c / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - h.y - h.height), a.Ray.CreateNew(b, c, h.width, h.height, d ? d : a.Matrix.Identity(), e.getViewMatrix(), e.getProjectionMatrix()) }, c.prototype._internalPick = function (b, c, d) { for (var e = null, f = 0; f < this.meshes.length; f++) { var g = this.meshes[f]; if (c) { if (!c(g)) continue } else if (!g.isEnabled() || !g.isVisible || !g.isPickable) continue; var h = g.getWorldMatrix(), i = b(h), j = g.intersects(i, d); if (j.hit && (d || null == e || !(j.distance >= e.distance)) && (e = j, d)) break } return e || new a.PickingInfo }, c.prototype.pick = function (a, b, c, d, e) { var f = this; return this._internalPick(function (c) { return f.createPickingRay(a, b, c, e) }, c, d) }, c.prototype.pickWithRay = function (b, c, d) { var e = this; return this._internalPick(function (c) { return e._pickWithRayInverseMatrix || (e._pickWithRayInverseMatrix = a.Matrix.Identity()), c.invertToRef(e._pickWithRayInverseMatrix), a.Ray.Transform(b, e._pickWithRayInverseMatrix) }, c, d) }, c.prototype.setPointerOverMesh = function (b) { this._pointerOverMesh !== b && (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.processTrigger(a.ActionManager.OnPointerOutTrigger), this._pointerOverMesh = b, this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.processTrigger(a.ActionManager.OnPointerOverTrigger)) }, c.prototype.getPointerOverMesh = function () { return this._pointerOverMesh }, c.prototype.getPhysicsEngine = function () { return this._physicsEngine }, c.prototype.enablePhysics = function (b, c) { return this._physicsEngine ? !0 : (this._physicsEngine = new a.PhysicsEngine(c), this._physicsEngine.isSupported() ? (this._physicsEngine._initialize(b), !0) : (this._physicsEngine = null, !1)) }, c.prototype.disablePhysicsEngine = function () { this._physicsEngine && (this._physicsEngine.dispose(), this._physicsEngine = void 0) }, c.prototype.isPhysicsEnabled = function () { return void 0 !== this._physicsEngine }, c.prototype.setGravity = function (a) { this._physicsEngine && this._physicsEngine._setGravity(a) }, c.prototype.createCompoundImpostor = function (a, b) { if (a.parts && (b = a, a = a.parts), !this._physicsEngine) return null; for (var c = 0; c < a.length; c++) { var d = a[c].mesh; d._physicImpostor = a[c].impostor, d._physicsMass = b.mass / a.length, d._physicsFriction = b.friction, d._physicRestitution = b.restitution } return this._physicsEngine._registerMeshesAsCompound(a, b) }, c.prototype.deleteCompoundImpostor = function (b) { for (var c = 0; c < b.parts.length; c++) { var d = b.parts[c].mesh; d._physicImpostor = a.PhysicsEngine.NoImpostor, this._physicsEngine._unregisterMesh(d) } }, c.prototype._getByTags = function (b, c) { if (void 0 === c) return b; var d = []; for (var e in b) { var f = b[e]; a.Tags.MatchesQuery(f, c) && d.push(f) } return d }, c.prototype.getMeshesByTags = function (a) { return this._getByTags(this.meshes, a) }, c.prototype.getCamerasByTags = function (a) { return this._getByTags(this.cameras, a) }, c.prototype.getLightsByTags = function (a) { return this._getByTags(this.lights, a) }, c.prototype.getMaterialByTags = function (a) { return this._getByTags(this.materials, a).concat(this._getByTags(this.multiMaterials, a)) }, c.FOGMODE_NONE = 0, c.FOGMODE_EXP = 1, c.FOGMODE_EXP2 = 2, c.FOGMODE_LINEAR = 3, c
	}(); a.Scene = c
}(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(c, d, e, f, g) { switch (this._engine = c instanceof a.Mesh ? c.getScene().getEngine() : c, this._updatable = f, this._data = d, g || this.create(), this._kind = e, e) { case b.PositionKind: this._strideSize = 3; break; case b.NormalKind: this._strideSize = 3; break; case b.UVKind: this._strideSize = 2; break; case b.UV2Kind: this._strideSize = 2; break; case b.ColorKind: this._strideSize = 3; break; case b.MatricesIndicesKind: this._strideSize = 4; break; case b.MatricesWeightsKind: this._strideSize = 4 } } return b.prototype.isUpdatable = function () { return this._updatable }, b.prototype.getData = function () { return this._data }, b.prototype.getBuffer = function () { return this._buffer }, b.prototype.getStrideSize = function () { return this._strideSize }, b.prototype.create = function (a) { (a || !this._buffer) && (a = a || this._data, this._buffer || (this._buffer = this._updatable ? this._engine.createDynamicVertexBuffer(4 * a.length) : this._engine.createVertexBuffer(a)), this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, a), this._data = a)) }, b.prototype.update = function (a) { this.create(a) }, b.prototype.dispose = function () { this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null) }, Object.defineProperty(b, "PositionKind", { get: function () { return b._PositionKind }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "NormalKind", { get: function () { return b._NormalKind }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "UVKind", { get: function () { return b._UVKind }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "UV2Kind", { get: function () { return b._UV2Kind }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ColorKind", { get: function () { return b._ColorKind }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "MatricesIndicesKind", { get: function () { return b._MatricesIndicesKind }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "MatricesWeightsKind", { get: function () { return b._MatricesWeightsKind }, enumerable: !0, configurable: !0 }), b._PositionKind = "position", b._NormalKind = "normal", b._UVKind = "uv", b._UV2Kind = "uv2", b._ColorKind = "color", b._MatricesIndicesKind = "matricesIndices", b._MatricesWeightsKind = "matricesWeights", b }(); a.VertexBuffer = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d) { b.call(this, c, d), this.position = new a.Vector3(0, 0, 0), this.rotation = new a.Vector3(0, 0, 0), this.rotationQuaternion = null, this.scaling = new a.Vector3(1, 1, 1), this.delayLoadState = a.Engine.DELAYLOADSTATE_NONE, this.material = null, this.isVisible = !0, this.isPickable = !0, this.visibility = 1, this.billboardMode = a.Mesh.BILLBOARDMODE_NONE, this.checkCollisions = !1, this.receiveShadows = !1, this._isDisposed = !1, this.onDispose = null, this.skeleton = null, this.renderingGroupId = 0, this.infiniteDistance = !1, this.showBoundingBox = !1, this._positions = null, this._localScaling = a.Matrix.Zero(), this._localRotation = a.Matrix.Zero(), this._localTranslation = a.Matrix.Zero(), this._localBillboard = a.Matrix.Zero(), this._localPivotScaling = a.Matrix.Zero(), this._localPivotScalingRotation = a.Matrix.Zero(), this._localWorld = a.Matrix.Zero(), this._worldMatrix = a.Matrix.Zero(), this._rotateYByPI = a.Matrix.RotationY(Math.PI), this._collisionsTransformMatrix = a.Matrix.Zero(), this._collisionsScalingMatrix = a.Matrix.Zero(), this._absolutePosition = a.Vector3.Zero(), this._isDirty = !1, this._physicImpostor = a.PhysicsEngine.NoImpostor, this._pivotMatrix = a.Matrix.Identity(), this._renderId = 0, this._onBeforeRenderCallbacks = [], this._animationStarted = !1, d.meshes.push(this) } return __extends(c, b), Object.defineProperty(c, "BILLBOARDMODE_NONE", { get: function () { return c._BILLBOARDMODE_NONE }, enumerable: !0, configurable: !0 }), Object.defineProperty(c, "BILLBOARDMODE_X", { get: function () { return c._BILLBOARDMODE_X }, enumerable: !0, configurable: !0 }), Object.defineProperty(c, "BILLBOARDMODE_Y", { get: function () { return c._BILLBOARDMODE_Y }, enumerable: !0, configurable: !0 }), Object.defineProperty(c, "BILLBOARDMODE_Z", { get: function () { return c._BILLBOARDMODE_Z }, enumerable: !0, configurable: !0 }), Object.defineProperty(c, "BILLBOARDMODE_ALL", { get: function () { return c._BILLBOARDMODE_ALL }, enumerable: !0, configurable: !0 }), c.prototype.getBoundingInfo = function () { return this._boundingInfo }, c.prototype.getWorldMatrix = function () { return this._currentRenderId !== this.getScene().getRenderId() && this.computeWorldMatrix(), this._worldMatrix }, c.prototype.rotate = function (b, c, d) { if (this.rotationQuaternion || (this.rotationQuaternion = a.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation = a.Vector3.Zero()), d && 0 != d) { if (this.parent) { var e = this.parent.getWorldMatrix().clone(); e.invert(), b = a.Vector3.TransformNormal(b, e) } f = a.Quaternion.RotationAxis(b, c), this.rotationQuaternion = f.multiply(this.rotationQuaternion) } else { var f = a.Quaternion.RotationAxis(b, c); this.rotationQuaternion = this.rotationQuaternion.multiply(f) } }, c.prototype.translate = function (a, b, c) { var d = a.scale(b); if (c && 0 != c) this.setAbsolutePosition(this.getAbsolutePosition().add(d)); else { var e = this.getPositionExpressedInLocalSpace().add(d); this.setPositionWithLocalVector(e) } }, c.prototype.getAbsolutePosition = function () { return this.computeWorldMatrix(), this._absolutePosition }, c.prototype.setAbsolutePosition = function (b) { if (b) { var c, d, e; if (void 0 === b.x) { if (arguments.length < 3) return; c = arguments[0], d = arguments[1], e = arguments[2] } else c = b.x, d = b.y, e = b.z; if (this.parent) { var f = this.parent.getWorldMatrix().clone(); f.invert(); var g = new a.Vector3(c, d, e); this.position = a.Vector3.TransformCoordinates(g, f) } else this.position.x = c, this.position.y = d, this.position.z = e } }, c.prototype.getTotalVertices = function () { return this._geometry ? this._geometry.getTotalVertices() : 0 }, c.prototype.getVerticesData = function (a) { return this._geometry ? this._geometry.getVerticesData(a) : null }, c.prototype.getVertexBuffer = function (a) { return this._geometry ? this._geometry.getVertexBuffer(a) : void 0 }, c.prototype.isVerticesDataPresent = function (a) { return this._geometry ? this._geometry.isVerticesDataPresent(a) : this._delayInfo ? -1 !== this._delayInfo.indexOf(a) : !1 }, c.prototype.getVerticesDataKinds = function () { if (!this._geometry) { var a = []; if (this._delayInfo) for (var b in this._delayInfo) a.push(b); return a } return this._geometry.getVerticesDataKinds() }, c.prototype.getTotalIndices = function () { return this._geometry ? this._geometry.getTotalIndices() : 0 }, c.prototype.getIndices = function () { return this._geometry ? this._geometry.getIndices() : [] }, c.prototype.setPivotMatrix = function (a) { this._pivotMatrix = a, this._cache.pivotMatrixUpdated = !0 }, c.prototype.getPivotMatrix = function () { return this._pivotMatrix }, c.prototype._isSynchronized = function () { if (this._isDirty) return !1; if (this.billboardMode !== c.BILLBOARDMODE_NONE) return !1; if (this._cache.pivotMatrixUpdated) return !1; if (this.infiniteDistance) return !1; if (!this._cache.position.equals(this.position)) return !1; if (this.rotationQuaternion) { if (!this._cache.rotationQuaternion.equals(this.rotationQuaternion)) return !1 } else if (!this._cache.rotation.equals(this.rotation)) return !1; return this._cache.scaling.equals(this.scaling) ? !0 : !1 }, c.prototype.isReady = function () { return this._isReady }, c.prototype.isAnimated = function () { return this._animationStarted }, c.prototype.isDisposed = function () { return this._isDisposed }, c.prototype._initCache = function () { b.prototype._initCache.call(this), this._cache.localMatrixUpdated = !1, this._cache.position = a.Vector3.Zero(), this._cache.scaling = a.Vector3.Zero(), this._cache.rotation = a.Vector3.Zero(), this._cache.rotationQuaternion = new a.Quaternion(0, 0, 0, 0) }, c.prototype.markAsDirty = function (a) { "rotation" === a && (this.rotationQuaternion = null), this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0 }, c.prototype.refreshBoundingInfo = function () { var b = this.getVerticesData(a.VertexBuffer.PositionKind); if (b) { var c = a.Tools.ExtractMinAndMax(b, 0, this.getTotalVertices()); this._boundingInfo = new a.BoundingInfo(c.minimum, c.maximum) } if (this.subMeshes) for (var d = 0; d < this.subMeshes.length; d++) this.subMeshes[d].refreshBoundingInfo(); this._updateBoundingInfo() }, c.prototype._updateBoundingInfo = function () { if (this._boundingInfo = this._boundingInfo || new a.BoundingInfo(this._absolutePosition, this._absolutePosition), this._boundingInfo._update(this._worldMatrix), this.subMeshes) for (var b = 0; b < this.subMeshes.length; b++) { var c = this.subMeshes[b]; c.updateBoundingInfo(this._worldMatrix) } }, c.prototype.computeWorldMatrix = function (b) { if (!b && (this._currentRenderId == this.getScene().getRenderId() || this.isSynchronized(!0))) return this._worldMatrix; if (this._cache.position.copyFrom(this.position), this._cache.scaling.copyFrom(this.scaling), this._cache.pivotMatrixUpdated = !1, this._currentRenderId = this.getScene().getRenderId(), this._isDirty = !1, a.Matrix.ScalingToRef(this.scaling.x, this.scaling.y, this.scaling.z, this._localScaling), this.rotationQuaternion ? (this.rotationQuaternion.toRotationMatrix(this._localRotation), this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (a.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._localRotation), this._cache.rotation.copyFrom(this.rotation)), this.infiniteDistance && !this.parent) { var d = this.getScene().activeCamera, e = d.getWorldMatrix(), f = new a.Vector3(e.m[12], e.m[13], e.m[14]); a.Matrix.TranslationToRef(this.position.x + f.x, this.position.y + f.y, this.position.z + f.z, this._localTranslation) } else a.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._localTranslation); if (this._pivotMatrix.multiplyToRef(this._localScaling, this._localPivotScaling), this._localPivotScaling.multiplyToRef(this._localRotation, this._localPivotScalingRotation), this.billboardMode !== c.BILLBOARDMODE_NONE) { var g = this.position.clone(), h = this.getScene().activeCamera.position.clone(); this.parent && this.parent.position && (g.addInPlace(this.parent.position), a.Matrix.TranslationToRef(g.x, g.y, g.z, this._localTranslation)), (this.billboardMode & c.BILLBOARDMODE_ALL) === c.BILLBOARDMODE_ALL ? h = this.getScene().activeCamera.position : (this.billboardMode & a.Mesh.BILLBOARDMODE_X && (h.x = g.x + a.Engine.Epsilon), this.billboardMode & a.Mesh.BILLBOARDMODE_Y && (h.y = g.y + .001), this.billboardMode & a.Mesh.BILLBOARDMODE_Z && (h.z = g.z + .001)), a.Matrix.LookAtLHToRef(g, h, a.Vector3.Up(), this._localBillboard), this._localBillboard.m[12] = this._localBillboard.m[13] = this._localBillboard.m[14] = 0, this._localBillboard.invert(), this._localPivotScalingRotation.multiplyToRef(this._localBillboard, this._localWorld), this._rotateYByPI.multiplyToRef(this._localWorld, this._localPivotScalingRotation) } return this._localPivotScalingRotation.multiplyToRef(this._localTranslation, this._localWorld), this.parent && this.parent.getWorldMatrix && this.billboardMode === a.Mesh.BILLBOARDMODE_NONE ? this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix) : this._worldMatrix.copyFrom(this._localWorld), this._updateBoundingInfo(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._worldMatrix }, c.prototype._createGlobalSubMesh = function () { var b = this.getTotalVertices(); return b && this.getIndices() ? (this.subMeshes = [], new a.SubMesh(0, 0, b, 0, this.getTotalIndices(), this)) : null }, c.prototype.subdivide = function (b) { if (!(1 > b)) { var c = this.getTotalIndices(), d = c / b, e = 0; this.subMeshes = []; for (var f = 0; b > f; f++) a.SubMesh.CreateFromIndices(0, e, Math.min(d, c - e), this), e += d } }, c.prototype.setVerticesData = function (b, c, d) { if (this._geometry) this._geometry.setVerticesData(b, c, d); else { var e = new a.VertexData; e.set(b, c); var f = this.getScene(); new a.Geometry(a.Geometry.RandomId(), f.getEngine(), e, d, this) } }, c.prototype.updateVerticesData = function (a, b, c, d) { this._geometry && (d ? (this.makeGeometryUnique(), this.updateVerticesData(a, b, c, !1)) : this._geometry.updateVerticesData(a, b, c)) }, c.prototype.makeGeometryUnique = function () { if (this._geometry) { var b = this._geometry.copy(a.Geometry.RandomId()); b.applyToMesh(this) } }, c.prototype.setIndices = function (b) { if (this._geometry) this._geometry.setIndices(b); else { var c = new a.VertexData; c.indices = b; var d = this.getScene(); new a.Geometry(a.Geometry.RandomId(), d.getEngine(), c, !1, this) } }, c.prototype.bindAndDraw = function (a, b, c) { if (this._geometry && this._geometry.getVertexBuffers() && this._geometry.getIndexBuffer()) { var d = this.getScene().getEngine(), e = this._geometry.getIndexBuffer(), f = !0; c && (e = a.getLinesIndexBuffer(this.getIndices(), d), f = !1), d.bindMultiBuffers(this._geometry.getVertexBuffers(), e, b), d.draw(f, f ? a.indexStart : 0, f ? a.indexCount : a.linesIndexCount) } }, c.prototype.registerBeforeRender = function (a) { this._onBeforeRenderCallbacks.push(a) }, c.prototype.unregisterBeforeRender = function (a) { var b = this._onBeforeRenderCallbacks.indexOf(a); b > -1 && this._onBeforeRenderCallbacks.splice(b, 1) }, c.prototype.render = function (a) { if (this._geometry && this._geometry.getVertexBuffers() && this._geometry.getIndexBuffer()) { for (var b = 0; b < this._onBeforeRenderCallbacks.length; b++) this._onBeforeRenderCallbacks[b](); var c = this.getWorldMatrix(), d = a.getMaterial(); if (d && d.isReady(this)) { d._preBind(), d.bind(c, this); var e = this.getScene().getEngine(); this.bindAndDraw(a, d.getEffect(), e.forceWireframe || d.wireframe), d.unbind() } } }, c.prototype.getEmittedParticleSystems = function () { for (var a = new Array, b = 0; b < this.getScene().particleSystems.length; b++) { var c = this.getScene().particleSystems[b]; c.emitter === this && a.push(c) } return a }, c.prototype.getHierarchyEmittedParticleSystems = function () { var a = new Array, b = this.getDescendants(); b.push(this); for (var c = 0; c < this.getScene().particleSystems.length; c++) { var d = this.getScene().particleSystems[c]; -1 !== b.indexOf(d.emitter) && a.push(d) } return a }, c.prototype.getChildren = function () { for (var a = [], b = 0; b < this.getScene().meshes.length; b++) { var c = this.getScene().meshes[b]; c.parent == this && a.push(c) } return a }, c.prototype.isInFrustum = function (b) { if (this.delayLoadState === a.Engine.DELAYLOADSTATE_LOADING) return !1; if (!this._boundingInfo.isInFrustum(b)) return !1; var c = this, d = this.getScene(); return this._geometry ? this._geometry.load(d) : c.delayLoadState === a.Engine.DELAYLOADSTATE_NOTLOADED && (c.delayLoadState = a.Engine.DELAYLOADSTATE_LOADING, d._addPendingData(c), a.Tools.LoadFile(this.delayLoadingFile, function (b) { c._delayLoadingFunction(JSON.parse(b), c), c.delayLoadState = a.Engine.DELAYLOADSTATE_LOADED, d._removePendingData(c) }, function () { }, d.database)), !0 }, c.prototype.setMaterialByID = function (a) { for (var b = this.getScene().materials, c = 0; c < b.length; c++) if (b[c].id == a) return void (this.material = b[c]); var d = this.getScene().multiMaterials; for (c = 0; c < d.length; c++) if (d[c].id == a) return void (this.material = d[c]) }, c.prototype.getAnimatables = function () { var a = []; return this.material && a.push(this.material), a }, c.prototype.setPositionWithLocalVector = function (b) { this.computeWorldMatrix(), this.position = a.Vector3.TransformNormal(b, this._localWorld) }, c.prototype.getPositionExpressedInLocalSpace = function () { this.computeWorldMatrix(); var b = this._localWorld.clone(); return b.invert(), a.Vector3.TransformNormal(this.position, b) }, c.prototype.locallyTranslate = function (b) { this.computeWorldMatrix(), this.position = a.Vector3.TransformCoordinates(b, this._localWorld) }, c.prototype.bakeTransformIntoVertices = function (b) { if (this.isVerticesDataPresent(a.VertexBuffer.PositionKind)) { this._resetPointsArrayCache(); for (var c = this.getVerticesData(a.VertexBuffer.PositionKind), d = [], e = 0; e < c.length; e += 3) a.Vector3.TransformCoordinates(a.Vector3.FromArray(c, e), b).toArray(d, e); if (this.setVerticesData(d, a.VertexBuffer.PositionKind, this.getVertexBuffer(a.VertexBuffer.PositionKind).isUpdatable()), this.isVerticesDataPresent(a.VertexBuffer.NormalKind)) { for (c = this.getVerticesData(a.VertexBuffer.NormalKind), e = 0; e < c.length; e += 3) a.Vector3.TransformNormal(a.Vector3.FromArray(c, e), b).toArray(d, e); this.setVerticesData(d, a.VertexBuffer.NormalKind, this.getVertexBuffer(a.VertexBuffer.NormalKind).isUpdatable()) } } }, c.prototype.lookAt = function (b, c, d, e) { c = c || 0, d = d || 0, e = e || 0; var f = b.subtract(this.position), g = -Math.atan2(f.z, f.x) - Math.PI / 2, h = Math.sqrt(f.x * f.x + f.z * f.z), i = Math.atan2(f.y, h); this.rotationQuaternion = a.Quaternion.RotationYawPitchRoll(g + c, i + d, e) }, c.prototype._resetPointsArrayCache = function () { this._positions = null }, c.prototype._generatePointsArray = function () { if (!this._positions) { this._positions = []; for (var b = this.getVerticesData(a.VertexBuffer.PositionKind), c = 0; c < b.length; c += 3) this._positions.push(a.Vector3.FromArray(b, c)) } }, c.prototype._collideForSubMesh = function (b, c, d) { if (this._generatePointsArray(), !b._lastColliderWorldVertices || !b._lastColliderTransformMatrix.equals(c)) { b._lastColliderTransformMatrix = c.clone(), b._lastColliderWorldVertices = [], b._trianglePlanes = []; for (var e = b.verticesStart, f = b.verticesStart + b.verticesCount, g = e; f > g; g++) b._lastColliderWorldVertices.push(a.Vector3.TransformCoordinates(this._positions[g], c)) } d._collide(b, b._lastColliderWorldVertices, this.getIndices(), b.indexStart, b.indexStart + b.indexCount, b.verticesStart) }, c.prototype._processCollisionsForSubModels = function (a, b) { for (var c = 0; c < this.subMeshes.length; c++) { var d = this.subMeshes[c]; this.subMeshes.length > 1 && !d._checkCollision(a) || this._collideForSubMesh(d, b, a) } }, c.prototype._checkCollision = function (b) { this._boundingInfo._checkCollision(b) && (a.Matrix.ScalingToRef(1 / b.radius.x, 1 / b.radius.y, 1 / b.radius.z, this._collisionsScalingMatrix), this._worldMatrix.multiplyToRef(this._collisionsScalingMatrix, this._collisionsTransformMatrix), this._processCollisionsForSubModels(b, this._collisionsTransformMatrix)) }, c.prototype.intersectsMesh = function (a, b) { return this._boundingInfo && a._boundingInfo ? this._boundingInfo.intersects(a._boundingInfo, b) : !1 }, c.prototype.intersectsPoint = function (a) { return this._boundingInfo ? this._boundingInfo.intersectsPoint(a) : !1 }, c.prototype.intersects = function (b, c) { var d = new a.PickingInfo; if (!this._boundingInfo || !b.intersectsSphere(this._boundingInfo.boundingSphere) || !b.intersectsBox(this._boundingInfo.boundingBox)) return d; this._generatePointsArray(); for (var e = null, f = 0; f < this.subMeshes.length; f++) { var g = this.subMeshes[f]; if (!(this.subMeshes.length > 1) || g.canIntersects(b)) { var h = g.intersects(b, this._positions, this.getIndices(), c); if (h && (c || !e || h.distance < e.distance) && (e = h, c)) break } } if (e) { var i = this.getWorldMatrix(), j = a.Vector3.TransformCoordinates(b.origin, i), k = b.direction.clone(); k.normalize(), k = k.scale(e.distance); var l = a.Vector3.TransformNormal(k, i), m = j.add(l); return d.hit = !0, d.distance = a.Vector3.Distance(j, m), d.pickedPoint = m, d.pickedMesh = this, d.bu = e.bu, d.bv = e.bv, d.faceId = e.faceId, d } return d }, c.prototype.clone = function (b, c, d) { var e = new a.Mesh(b, this.getScene()); this._geometry.applyToMesh(e), a.Tools.DeepCopy(this, e, ["name", "material", "skeleton"], []); var f = a.Tools.ExtractMinAndMax(this.getVerticesData(a.VertexBuffer.PositionKind), 0, this.getTotalVertices()); if (e._boundingInfo = new a.BoundingInfo(f.minimum, f.maximum), e.material = this.material, c && (e.parent = c), !d) for (var g = 0; g < this.getScene().meshes.length; g++) { var h = this.getScene().meshes[g]; h.parent == this && h.clone(h.name, e) } for (g = 0; g < this.getScene().particleSystems.length; g++) { var i = this.getScene().particleSystems[g]; i.emitter == this && i.clone(i.name, e) } return e.computeWorldMatrix(!0), e }, c.prototype.dispose = function (b) { this._geometry && this._geometry.releaseForMesh(this), this.getPhysicsImpostor() != a.PhysicsEngine.NoImpostor && this.setPhysicsState(a.PhysicsEngine.NoImpostor); var c = this.getScene().meshes.indexOf(this); if (this.getScene().meshes.splice(c, 1), b) for (c = 0; c < this.getScene().meshes.length; c++) { var d = this.getScene().meshes[c]; d.parent === this && (d.parent = null, d.computeWorldMatrix(!0)) } else { for (c = 0; c < this.getScene().particleSystems.length; c++) this.getScene().particleSystems[c].emitter == this && (this.getScene().particleSystems[c].dispose(), c--); var e = this.getScene().meshes.slice(0); for (c = 0; c < e.length; c++) e[c].parent == this && e[c].dispose() } this._isDisposed = !0, this.onDispose && this.onDispose() }, c.prototype.setPhysicsState = function (b, c) { var d = this.getScene().getPhysicsEngine(); if (d) { if (b.impostor && (c = b, b = b.impostor), b = b || a.PhysicsEngine.NoImpostor, b === a.PhysicsEngine.NoImpostor) return void d._unregisterMesh(this); c.mass = c.mass || 0, c.friction = c.friction || .2, c.restitution = c.restitution || .9, this._physicImpostor = b, this._physicsMass = c.mass, this._physicsFriction = c.friction, this._physicRestitution = c.restitution, d._registerMesh(this, b, c) } }, c.prototype.getPhysicsImpostor = function () { return this._physicImpostor ? this._physicImpostor : a.PhysicsEngine.NoImpostor }, c.prototype.getPhysicsMass = function () { return this._physicsMass ? this._physicsMass : 0 }, c.prototype.getPhysicsFriction = function () { return this._physicsFriction ? this._physicsFriction : 0 }, c.prototype.getPhysicsRestitution = function () { return this._physicRestitution ? this._physicRestitution : 0 }, c.prototype.applyImpulse = function (a, b) { this._physicImpostor && this.getScene().getPhysicsEngine()._applyImpulse(this, a, b) }, c.prototype.setPhysicsLinkWith = function (a, b, c) { this._physicImpostor && this.getScene().getPhysicsEngine()._createLink(this, a, b, c) }, c.prototype.convertToFlatShadedMesh = function () { for (var b = this.getVerticesDataKinds(), c = [], d = [], e = [], f = !1, g = 0; g < b.length; g++) { var h = b[g], i = this.getVertexBuffer(h); h !== a.VertexBuffer.NormalKind ? (c[h] = i, d[h] = c[h].getData(), e[h] = []) : (f = i.isUpdatable(), b.splice(g, 1), g--) } var j = this.subMeshes.slice(0), k = this.getIndices(), l = this.getTotalIndices(); for (r = 0; l > r; r++) { var m = k[r]; for (g = 0; g < b.length; g++) { h = b[g]; for (var n = c[h].getStrideSize(), o = 0; n > o; o++) e[h].push(d[h][m * n + o]) } } for (var p = [], q = e[a.VertexBuffer.PositionKind], r = 0; l > r; r += 3) { k[r] = r, k[r + 1] = r + 1, k[r + 2] = r + 2; for (var s = a.Vector3.FromArray(q, 3 * r), t = a.Vector3.FromArray(q, 3 * (r + 1)), u = a.Vector3.FromArray(q, 3 * (r + 2)), v = s.subtract(t), w = u.subtract(t), x = a.Vector3.Normalize(a.Vector3.Cross(v, w)), y = 0; 3 > y; y++) p.push(x.x), p.push(x.y), p.push(x.z) } for (this.setIndices(k), this.setVerticesData(p, a.VertexBuffer.NormalKind, f), g = 0; g < b.length; g++) h = b[g], this.setVerticesData(e[h], h, c[h].isUpdatable()); this.subMeshes = []; for (var z = 0; z < j.length; z++) { var A = j[z]; new a.SubMesh(A.materialIndex, A.indexStart, A.indexCount, A.indexStart, A.indexCount, this) } }, c.CreateBox = function (b, c, d, e) { var f = new a.Mesh(b, d), g = a.VertexData.CreateBox(c); return g.applyToMesh(f, e), f }, c.CreateSphere = function (b, c, d, e, f) { var g = new a.Mesh(b, e), h = a.VertexData.CreateSphere(c, d); return h.applyToMesh(g, f), g }, c.CreateCylinder = function (b, c, d, e, f, g, h) { var i = new a.Mesh(b, g), j = a.VertexData.CreateCylinder(c, d, e, f); return j.applyToMesh(i, h), i }, c.CreateTorus = function (b, c, d, e, f, g) { var h = new a.Mesh(b, f), i = a.VertexData.CreateTorus(c, d, e); return i.applyToMesh(h, g), h }, c.CreateTorusKnot = function (b, c, d, e, f, g, h, i, j) { var k = new a.Mesh(b, i), l = a.VertexData.CreateTorusKnot(c, d, e, f, g, h); return l.applyToMesh(k, j), k }, c.CreatePlane = function (b, c, d, e) { var f = new a.Mesh(b, d), g = a.VertexData.CreatePlane(c); return g.applyToMesh(f, e), f }, c.CreateGround = function (b, c, d, e, f, g) { var h = new a.Mesh(b, f), i = a.VertexData.CreateGround(c, d, e); return i.applyToMesh(h, g), h }, c.CreateGroundFromHeightMap = function (b, c, d, e, f, g, h, i, j) { var k = new a.Mesh(b, i), l = function (b) { var c = document.createElement("canvas"), i = c.getContext("2d"), l = b.width, m = b.height; c.width = l, c.height = m, i.drawImage(b, 0, 0); var n = i.getImageData(0, 0, l, m).data, o = a.VertexData.CreateGroundFromHeightMap(d, e, f, g, h, n, l, m); o.applyToMesh(k, j), k._isReady = !0 }; return a.Tools.LoadImage(c, l, function () { }, i.database), k._isReady = !1, k }, c.MinMax = function (a) { var b = null, c = null; for (var d in a) { var e = a[d], f = e.getBoundingInfo().boundingBox; b ? (b.MinimizeInPlace(f.minimumWorld), c.MaximizeInPlace(f.maximumWorld)) : (b = f.minimumWorld, c = f.maximumWorld) } return { min: b, max: c } }, c.Center = function (b) { var c = void 0 !== b.min ? b : a.Mesh.MinMax(b); return a.Vector3.Center(c.min, c.max) }, c._BILLBOARDMODE_NONE = 0, c._BILLBOARDMODE_X = 1, c._BILLBOARDMODE_Y = 2, c._BILLBOARDMODE_Z = 4, c._BILLBOARDMODE_ALL = 7, c }(a.Node); a.Mesh = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a, b, c, d, e, f) { this.materialIndex = a, this.verticesStart = b, this.verticesCount = c, this.indexStart = d, this.indexCount = e, this._mesh = f, f.subMeshes.push(this), this.refreshBoundingInfo() } return b.prototype.getBoundingInfo = function () { return this._boundingInfo }, b.prototype.getMesh = function () { return this._mesh }, b.prototype.getMaterial = function () { var a = this._mesh.material; return a && a.getSubMaterial ? a.getSubMaterial(this.materialIndex) : a ? a : this._mesh.getScene().defaultMaterial }, b.prototype.refreshBoundingInfo = function () { var b = this._mesh.getVerticesData(a.VertexBuffer.PositionKind); if (!b) return void (this._boundingInfo = this._mesh._boundingInfo); var c = a.Tools.ExtractMinAndMax(b, this.verticesStart, this.verticesCount); this._boundingInfo = new a.BoundingInfo(c.minimum, c.maximum) }, b.prototype._checkCollision = function (a) { return this._boundingInfo._checkCollision(a) }, b.prototype.updateBoundingInfo = function (a) { this._boundingInfo || this.refreshBoundingInfo(), this._boundingInfo._update(a) }, b.prototype.isInFrustum = function (a) { return this._boundingInfo.isInFrustum(a) }, b.prototype.render = function () { this._mesh.render(this) }, b.prototype.getLinesIndexBuffer = function (a, b) { if (!this._linesIndexBuffer) { for (var c = [], d = this.indexStart; d < this.indexStart + this.indexCount; d += 3) c.push(a[d], a[d + 1], a[d + 1], a[d + 2], a[d + 2], a[d]); this._linesIndexBuffer = b.createIndexBuffer(c), this.linesIndexCount = c.length } return this._linesIndexBuffer }, b.prototype.canIntersects = function (a) { return a.intersectsBox(this._boundingInfo.boundingBox) }, b.prototype.intersects = function (a, b, c, d) { for (var e = null, f = this.indexStart; f < this.indexStart + this.indexCount; f += 3) { var g = b[c[f]], h = b[c[f + 1]], i = b[c[f + 2]], j = a.intersectsTriangle(g, h, i); if (j && (d || !e || j.distance < e.distance) && (e = j, e.faceId = f / 3, d)) break } return e }, b.prototype.clone = function (a) { return new b(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, a) }, b.CreateFromIndices = function (b, c, d, e) { for (var f = Number.MAX_VALUE, g = -Number.MAX_VALUE, h = e.getIndices(), i = c; c + d > i; i++) { var j = h[i]; f > j ? f = j : j > g && (g = j) } return new a.SubMesh(b, f, g - f, c, d, e) }, b }(); a.SubMesh = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function () {
		function b(b) { this.delayLoadState = a.Engine.DELAYLOADSTATE_NONE, this.hasAlpha = !1, this.level = 1, this.isCube = !1, this._scene = b, this._scene.textures.push(this) } return b.prototype.getScene = function () {
			return this._scene
		}, b.prototype.getInternalTexture = function () { return this._texture }, b.prototype.isReady = function () { return this.delayLoadState === a.Engine.DELAYLOADSTATE_NOTLOADED ? !0 : this._texture ? this._texture.isReady : !1 }, b.prototype.getSize = function () { return this._texture._width ? { width: this._texture._width, height: this._texture._height } : this._texture._size ? { width: this._texture._size, height: this._texture._size } : { width: 0, height: 0 } }, b.prototype.getBaseSize = function () { return this.isReady() ? this._texture._size ? { width: this._texture._size, height: this._texture._size } : { width: this._texture._baseWidth, height: this._texture._baseHeight } : { width: 0, height: 0 } }, b.prototype._getFromCache = function (a, b) { for (var c = this._scene.getEngine().getLoadedTexturesCache(), d = 0; d < c.length; d++) { var e = c[d]; if (e.url === a && e.noMipmap === b) return e.references++, e } return null }, b.prototype.delayLoad = function () { }, b.prototype.releaseInternalTexture = function () { if (this._texture) { var a = this._scene.getEngine().getLoadedTexturesCache(); if (this._texture.references--, 0 == this._texture.references) { var b = a.indexOf(this._texture); a.splice(b, 1), this._scene.getEngine()._releaseTexture(this._texture), delete this._texture } } }, b.prototype.dispose = function () { var a = this._scene.textures.indexOf(this); a >= 0 && this._scene.textures.splice(a, 1), void 0 !== this._texture && (this.releaseInternalTexture(), this.onDispose && this.onDispose()) }, b
	}(); a.BaseTexture = b
}(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c) { this.index = b, this._opaqueSubMeshes = new a.SmartArray(256), this._transparentSubMeshes = new a.SmartArray(256), this._alphaTestSubMeshes = new a.SmartArray(256), this._scene = c } return b.prototype.render = function (b, c) { if (b) return b(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, c), !0; if (0 === this._opaqueSubMeshes.length && 0 === this._alphaTestSubMeshes.length && 0 === this._transparentSubMeshes.length) return !1; var d, e, f = this._scene.getEngine(); for (d = 0; d < this._opaqueSubMeshes.length; d++) e = this._opaqueSubMeshes.data[d], this._activeVertices += e.verticesCount, e.render(); for (f.setAlphaTesting(!0), d = 0; d < this._alphaTestSubMeshes.length; d++) e = this._alphaTestSubMeshes.data[d], this._activeVertices += e.verticesCount, e.render(); if (f.setAlphaTesting(!1), c && c(), this._transparentSubMeshes.length) { for (d = 0; d < this._transparentSubMeshes.length; d++) e = this._transparentSubMeshes.data[d], e._distanceToCamera = e.getBoundingInfo().boundingSphere.centerWorld.subtract(this._scene.activeCamera.position).length(); var g = this._transparentSubMeshes.data.slice(0, this._transparentSubMeshes.length); for (g.sort(function (a, b) { return a._distanceToCamera < b._distanceToCamera ? 1 : a._distanceToCamera > b._distanceToCamera ? -1 : 0 }), f.setAlphaMode(a.Engine.ALPHA_COMBINE), d = 0; d < g.length; d++) e = g[d], this._activeVertices += e.verticesCount, e.render(); f.setAlphaMode(a.Engine.ALPHA_DISABLE) } return !0 }, b.prototype.prepare = function () { this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset() }, b.prototype.dispatch = function (a) { var b = a.getMaterial(), c = a.getMesh(); b.needAlphaBlending() || c.visibility < 1 ? (b.alpha > 0 || c.visibility < 1) && this._transparentSubMeshes.push(a) : b.needAlphaTesting() ? this._alphaTestSubMeshes.push(a) : this._opaqueSubMeshes.push(a) }, b }(); a.RenderingGroup = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a) { this._renderingGroups = new Array, this._scene = a } return b.prototype._renderParticles = function (a, b) { if (0 !== this._scene._activeParticleSystems.length) { for (var c = (new Date).getTime(), d = 0; d < this._scene._activeParticleSystems.length; d++) { var e = this._scene._activeParticleSystems.data[d]; e.renderingGroupId === a && (this._clearDepthBuffer(), e.emitter.position && b && -1 === b.indexOf(e.emitter) || (this._scene._activeParticles += e.render())) } this._scene._particlesDuration += (new Date).getTime() - c } }, b.prototype._renderSprites = function (a) { if (0 !== this._scene.spriteManagers.length) { for (var b = (new Date).getTime(), c = 0; c < this._scene.spriteManagers.length; c++) { var d = this._scene.spriteManagers[c]; d.renderingGroupId === a && (this._clearDepthBuffer(), d.render()) } this._scene._spritesDuration += (new Date).getTime() - b } }, b.prototype._clearDepthBuffer = function () { this._depthBufferAlreadyCleaned || (this._scene.getEngine().clear(0, !1, !0), this._depthBufferAlreadyCleaned = !0) }, b.prototype.render = function (b, c, d, e) { for (var f = this, g = 0; g < a.RenderingManager.MAX_RENDERINGGROUPS; g++) { this._depthBufferAlreadyCleaned = !1; var h = this._renderingGroups[g]; h ? (this._clearDepthBuffer(), h.render(b, function () { e && f._renderSprites(g) }) || this._renderingGroups.splice(g, 1)) : e && this._renderSprites(g), d && this._renderParticles(g, c) } }, b.prototype.reset = function () { for (var a in this._renderingGroups) { var b = this._renderingGroups[a]; b.prepare() } }, b.prototype.dispatch = function (b) { var c = b.getMesh(), d = c.renderingGroupId || 0; this._renderingGroups[d] || (this._renderingGroups[d] = new a.RenderingGroup(d, this._scene)), this._renderingGroups[d].dispatch(b) }, b.MAX_RENDERINGGROUPS = 4, b }(); a.RenderingManager = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f) { b.call(this, d), this.uOffset = 0, this.vOffset = 0, this.uScale = 1, this.vScale = 1, this.uAng = 0, this.vAng = 0, this.wAng = 0, this.wrapU = a.Texture.WRAP_ADDRESSMODE, this.wrapV = a.Texture.WRAP_ADDRESSMODE, this.coordinatesIndex = 0, this.coordinatesMode = a.Texture.EXPLICIT_MODE, this.anisotropicFilteringLevel = 4, this.animations = new Array, this.isRenderTarget = !1, this.name = c, this.url = c, this._noMipmap = e, this._invertY = f, c && (this._texture = this._getFromCache(c, e), this._texture || (d.useDelayedTextureLoading ? this.delayLoadState = a.Engine.DELAYLOADSTATE_NOTLOADED : this._texture = d.getEngine().createTexture(c, e, f, d))) } return __extends(c, b), c.prototype.delayLoad = function () { this.delayLoadState == a.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = a.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap), this._texture || (this._texture = this.getScene().getEngine().createTexture(this.url, this._noMipmap, this._invertY, this.getScene()))) }, c.prototype._prepareRowForTextureGeneration = function (b, c, d, e) { b -= this.uOffset + .5, c -= this.vOffset + .5, d -= .5, a.Vector3.TransformCoordinatesFromFloatsToRef(b, c, d, this._rowGenerationMatrix, e), e.x *= this.uScale, e.y *= this.vScale, e.x += .5, e.y += .5, e.z += .5 }, c.prototype._computeTextureMatrix = function () { return this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng ? this._cachedTextureMatrix : (this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedTextureMatrix || (this._cachedTextureMatrix = a.Matrix.Zero(), this._rowGenerationMatrix = new a.Matrix, this._t0 = a.Vector3.Zero(), this._t1 = a.Vector3.Zero(), this._t2 = a.Vector3.Zero()), a.Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), a.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix.m[0] = this._t1.x, this._cachedTextureMatrix.m[1] = this._t1.y, this._cachedTextureMatrix.m[2] = this._t1.z, this._cachedTextureMatrix.m[4] = this._t2.x, this._cachedTextureMatrix.m[5] = this._t2.y, this._cachedTextureMatrix.m[6] = this._t2.z, this._cachedTextureMatrix.m[8] = this._t0.x, this._cachedTextureMatrix.m[9] = this._t0.y, this._cachedTextureMatrix.m[10] = this._t0.z, this._cachedTextureMatrix) }, c.prototype._computeReflectionTextureMatrix = function () { if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) return this._cachedTextureMatrix; switch (this._cachedTextureMatrix || (this._cachedTextureMatrix = a.Matrix.Zero(), this._projectionModeMatrix = a.Matrix.Zero()), this.coordinatesMode) { case a.Texture.SPHERICAL_MODE: a.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix[0] = -.5 * this.uScale, this._cachedTextureMatrix[5] = -.5 * this.vScale, this._cachedTextureMatrix[12] = .5 + this.uOffset, this._cachedTextureMatrix[13] = .5 + this.vOffset; break; case a.Texture.PLANAR_MODE: a.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix[0] = this.uScale, this._cachedTextureMatrix[5] = this.vScale, this._cachedTextureMatrix[12] = this.uOffset, this._cachedTextureMatrix[13] = this.vOffset; break; case a.Texture.PROJECTION_MODE: a.Matrix.IdentityToRef(this._projectionModeMatrix), this._projectionModeMatrix.m[0] = .5, this._projectionModeMatrix.m[5] = -.5, this._projectionModeMatrix.m[10] = 0, this._projectionModeMatrix.m[12] = .5, this._projectionModeMatrix.m[13] = .5, this._projectionModeMatrix.m[14] = 1, this._projectionModeMatrix.m[15] = 1, this.getScene().getProjectionMatrix().multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix); break; default: a.Matrix.IdentityToRef(this._cachedTextureMatrix) } return this._cachedTextureMatrix }, c.prototype.clone = function () { var b = new a.Texture(this._texture.url, this.getScene(), this._noMipmap, this._invertY); return b.hasAlpha = this.hasAlpha, b.level = this.level, b.uOffset = this.uOffset, b.vOffset = this.vOffset, b.uScale = this.uScale, b.vScale = this.vScale, b.uAng = this.uAng, b.vAng = this.vAng, b.wAng = this.wAng, b.wrapU = this.wrapU, b.wrapV = this.wrapV, b.coordinatesIndex = this.coordinatesIndex, b.coordinatesMode = this.coordinatesMode, b }, c.NEAREST_SAMPLINGMODE = 1, c.BILINEAR_SAMPLINGMODE = 2, c.TRILINEAR_SAMPLINGMODE = 3, c.EXPLICIT_MODE = 0, c.SPHERICAL_MODE = 1, c.PLANAR_MODE = 2, c.CUBIC_MODE = 3, c.PROJECTION_MODE = 4, c.SKYBOX_MODE = 5, c.CLAMP_ADDRESSMODE = 0, c.WRAP_ADDRESSMODE = 1, c.MIRROR_ADDRESSMODE = 2, c }(a.BaseTexture); a.Texture = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f) { b.call(this, d), this.coordinatesMode = a.Texture.CUBIC_MODE, this.name = c, this.url = c, this._noMipmap = f, this.hasAlpha = !1, this._texture = this._getFromCache(c, f), e || (e = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"]), this._extensions = e, this._texture || (d.useDelayedTextureLoading ? this.delayLoadState = a.Engine.DELAYLOADSTATE_NOTLOADED : this._texture = d.getEngine().createCubeTexture(c, d, e, f)), this.isCube = !0, this._textureMatrix = a.Matrix.Identity() } return __extends(c, b), c.prototype.delayLoad = function () { this.delayLoadState == a.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = a.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap), this._texture || (this._texture = this.getScene().getEngine().createCubeTexture(this.url, this.getScene(), this._extensions))) }, c.prototype._computeReflectionTextureMatrix = function () { return this._textureMatrix }, c }(a.BaseTexture); a.CubeTexture = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f, g) { b.call(this, null, e, !f), this.renderList = new Array, this.renderParticles = !0, this.renderSprites = !1, this.coordinatesMode = a.Texture.PROJECTION_MODE, this.name = c, this.isRenderTarget = !0, this._size = d, this._generateMipMaps = f, this._doNotChangeAspectratio = g, this._texture = e.getEngine().createRenderTargetTexture(d, f), this._renderingManager = new a.RenderingManager(e) } return __extends(c, b), c.prototype.getRenderSize = function () { return this._size }, c.prototype.resize = function (a, b) { this.releaseInternalTexture(), this._texture = this.getScene().getEngine().createRenderTargetTexture(a, b) }, c.prototype.render = function () { var a = this.getScene(), b = a.getEngine(); if (this._waitingRenderList) { this.renderList = []; for (var c = 0; c < this._waitingRenderList.length; c++) { var d = this._waitingRenderList[c]; this.renderList.push(a.getMeshByID(d)) } delete this._waitingRenderList } if (this.renderList && 0 != this.renderList.length) { b.bindFramebuffer(this._texture), b.clear(a.clearColor, !0, !0), this._renderingManager.reset(); for (var e = 0; e < this.renderList.length; e++) { var f = this.renderList[e]; if (f && f.isEnabled() && f.isVisible && f.subMeshes) for (var g = 0; g < f.subMeshes.length; g++) { var h = f.subMeshes[g]; a._activeVertices += h.verticesCount, this._renderingManager.dispatch(h) } } this._doNotChangeAspectratio || a.updateTransformMatrix(!0), this.onBeforeRender && this.onBeforeRender(), this._renderingManager.render(this.customRenderFunction, this.renderList, this.renderParticles, this.renderSprites), this.onAfterRender && this.onAfterRender(), b.unBindFramebuffer(this._texture), this._doNotChangeAspectratio || a.updateTransformMatrix(!0) } }, c.prototype.clone = function () { var b = this.getSize(), c = new a.RenderTargetTexture(this.name, b.width, this.getScene(), this._generateMipMaps); return c.hasAlpha = this.hasAlpha, c.level = this.level, c.coordinatesMode = this.coordinatesMode, c.renderList = this.renderList.slice(0), c }, c }(a.Texture); a.RenderTargetTexture = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f) { var g = this; b.call(this, c, d, e, f, !0), this.mirrorPlane = new a.Plane(0, 1, 0, 1), this._transformMatrix = a.Matrix.Zero(), this._mirrorMatrix = a.Matrix.Zero(), this.onBeforeRender = function () { a.Matrix.ReflectionToRef(g.mirrorPlane, g._mirrorMatrix), g._savedViewMatrix = e.getViewMatrix(), g._mirrorMatrix.multiplyToRef(g._savedViewMatrix, g._transformMatrix), e.setTransformMatrix(g._transformMatrix, e.getProjectionMatrix()), e.clipPlane = g.mirrorPlane, e.getEngine().cullBackFaces = !1 }, this.onAfterRender = function () { e.setTransformMatrix(g._savedViewMatrix, e.getProjectionMatrix()), e.getEngine().cullBackFaces = !0, delete e.clipPlane } } return __extends(c, b), c.prototype.clone = function () { var b = this.getSize(), c = new a.MirrorTexture(this.name, b.width, this.getScene(), this._generateMipMaps); return c.hasAlpha = this.hasAlpha, c.level = this.level, c.mirrorPlane = this.mirrorPlane.clone(), c.renderList = this.renderList.slice(0), c }, c }(a.RenderTargetTexture); a.MirrorTexture = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f) { b.call(this, null, e, !f), this.name = c, this.wrapU = a.Texture.CLAMP_ADDRESSMODE, this.wrapV = a.Texture.CLAMP_ADDRESSMODE, this._generateMipMaps = f, d.getContext ? (this._canvas = d, this._texture = e.getEngine().createDynamicTexture(d.width, d.height, f)) : (this._canvas = document.createElement("canvas"), this._texture = d.width ? e.getEngine().createDynamicTexture(d.width, d.height, f) : e.getEngine().createDynamicTexture(d, d, f)); var g = this.getSize(); this._canvas.width = g.width, this._canvas.height = g.height, this._context = this._canvas.getContext("2d") } return __extends(c, b), c.prototype.getContext = function () { return this._context }, c.prototype.update = function (a) { this.getScene().getEngine().updateDynamicTexture(this._texture, this._canvas, void 0 === a ? !0 : a) }, c.prototype.drawText = function (a, b, c, d, e, f, g) { var h = this.getSize(); if (f && (this._context.fillStyle = f, this._context.fillRect(0, 0, h.width, h.height)), this._context.font = d, null === b) { var i = this._context.measureText(a); b = (h.width - i.width) / 2 } this._context.fillStyle = e, this._context.fillText(a, b, c), this.update(g) }, c.prototype.clone = function () { var b = this.getSize(), c = new a.DynamicTexture(this.name, b.width, this.getScene(), this._generateMipMaps); return c.hasAlpha = this.hasAlpha, c.level = this.level, c.wrapU = this.wrapU, c.wrapV = this.wrapV, c }, c }(a.Texture); a.DynamicTexture = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f, g, h) { var i = this; b.call(this, null, f, !g, h), this._autoLaunch = !0, this.name = c, this.wrapU = a.Texture.WRAP_ADDRESSMODE, this.wrapV = a.Texture.WRAP_ADDRESSMODE, this._texture = f.getEngine().createDynamicTexture(e, e, g); var j = this.getSize(); this.video = document.createElement("video"), this.video.width = j.width, this.video.height = j.height, this.video.autoplay = !1, this.video.loop = !0, this.video.addEventListener("canplaythrough", function () { i._texture && (i._texture.isReady = !0) }), d.forEach(function (a) { var b = document.createElement("source"); b.src = a, i.video.appendChild(b) }), this._lastUpdate = (new Date).getTime() } return __extends(c, b), c.prototype.update = function () { this._autoLaunch && (this._autoLaunch = !1, this.video.play()); var a = (new Date).getTime(); return a - this._lastUpdate < 15 ? !1 : (this._lastUpdate = a, this.getScene().getEngine().updateVideoTexture(this._texture, this.video, this._invertY), !0) }, c }(a.Texture); a.VideoTexture = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function () {
		function b(a, b, c, d, e, f, g, h, i) { var j = this; this._isReady = !1, this._compilationError = "", this._valueCache = [], this._engine = e, this.name = a, this.defines = f, this._uniformsNames = c.concat(d), this._samplers = d, this._attributesNames = b, this.onError = i, this.onCompiled = h; var k, l; a.vertexElement ? (k = document.getElementById(a.vertexElement), l = document.getElementById(a.fragmentElement)) : (k = a.vertexElement || a.vertex || a, l = a.fragmentElement || a.fragment || a), this._loadVertexShader(k, function (a) { j._loadFragmentShader(l, function (c) { j._prepareEffect(a, c, b, f, g) }) }) } return b.prototype.isReady = function () { return this._isReady }, b.prototype.getProgram = function () { return this._program }, b.prototype.getAttributesNames = function () { return this._attributesNames }, b.prototype.getAttribute = function (a) { return this._attributes[a] }, b.prototype.getAttributesCount = function () { return this._attributes.length }, b.prototype.getUniformIndex = function (a) { return this._uniformsNames.indexOf(a) }, b.prototype.getUniform = function (a) { return this._uniforms[this._uniformsNames.indexOf(a)] }, b.prototype.getSamplers = function () { return this._samplers }, b.prototype.getCompilationError = function () { return this._compilationError }, b.prototype._loadVertexShader = function (b, c) { if (b instanceof HTMLElement) { var d = a.Tools.GetDOMTextContent(b); return void c(d) } if (a.Effect.ShadersStore[b + "VertexShader"]) return void c(a.Effect.ShadersStore[b + "VertexShader"]); var e; e = "." === b[0] ? b : a.Engine.ShadersRepository + b, a.Tools.LoadFile(e + ".vertex.fx", c) }, b.prototype._loadFragmentShader = function (b, c) { if (b instanceof HTMLElement) { var d = a.Tools.GetDOMTextContent(b); return void c(d) } if (a.Effect.ShadersStore[b + "PixelShader"]) return void c(a.Effect.ShadersStore[b + "PixelShader"]); var e; e = "." === b[0] ? b : a.Engine.ShadersRepository + b, a.Tools.LoadFile(e + ".fragment.fx", c) }, b.prototype._prepareEffect = function (b, c, d, e, f, g) { try { var h = this._engine; this._program = h.createShaderProgram(b, c, e), this._uniforms = h.getUniforms(this._program, this._uniformsNames), this._attributes = h.getAttributes(this._program, d); for (var i = 0; i < this._samplers.length; i++) { var j = this.getUniform(this._samplers[i]); null == j && (this._samplers.splice(i, 1), i--) } h.bindSamplers(this), this._isReady = !0, this.onCompiled && this.onCompiled(this) } catch (k) { if (!g && f) { for (i = 0; i < f.length; i++) e = e.replace(f[i], ""); this._prepareEffect(b, c, d, e, f, !0) } else a.Tools.Error("Unable to compile effect: " + this.name), a.Tools.Error("Defines: " + e), a.Tools.Error("Optional defines: " + f), a.Tools.Error("Error: " + k.message), this._compilationError = k.message, this.onError && this.onError(this, this._compilationError) } }, b.prototype._bindTexture = function (a, b) { this._engine._bindTexture(this._samplers.indexOf(a), b) }, b.prototype.setTexture = function (a, b) { this._engine.setTexture(this._samplers.indexOf(a), b) }, b.prototype.setTextureFromPostProcess = function (a, b) { this._engine.setTextureFromPostProcess(this._samplers.indexOf(a), b) }, b.prototype._cacheFloat2 = function (a, b, c) { return this._valueCache[a] ? (this._valueCache[a][0] = b, void (this._valueCache[a][1] = c)) : void (this._valueCache[a] = [b, c]) }, b.prototype._cacheFloat3 = function (a, b, c, d) { return this._valueCache[a] ? (this._valueCache[a][0] = b, this._valueCache[a][1] = c, void (this._valueCache[a][2] = d)) : void (this._valueCache[a] = [b, c, d]) }, b.prototype._cacheFloat4 = function (a, b, c, d, e) { return this._valueCache[a] ? (this._valueCache[a][0] = b, this._valueCache[a][1] = c, this._valueCache[a][2] = d, void (this._valueCache[a][3] = e)) : void (this._valueCache[a] = [b, c, d, e]) }, b.prototype.setArray = function (a, b) { return this._engine.setArray(this.getUniform(a), b), this }, b.prototype.setMatrices = function (a, b) { return this._engine.setMatrices(this.getUniform(a), b), this }, b.prototype.setMatrix = function (a, b) { return this._engine.setMatrix(this.getUniform(a), b), this }, b.prototype.setFloat = function (a, b) { return this._valueCache[a] && this._valueCache[a] === b ? this : (this._valueCache[a] = b, this._engine.setFloat(this.getUniform(a), b), this) }, b.prototype.setBool = function (a, b) { return this._valueCache[a] && this._valueCache[a] === b ? this : (this._valueCache[a] = b, this._engine.setBool(this.getUniform(a), b ? 1 : 0), this) }, b.prototype.setVector2 = function (a, b) { return this._valueCache[a] && this._valueCache[a][0] == b.x && this._valueCache[a][1] == b.y ? this : (this._cacheFloat2(a, b.x, b.y), this._engine.setFloat2(this.getUniform(a), b.x, b.y), this) }, b.prototype.setFloat2 = function (a, b, c) { return this._valueCache[a] && this._valueCache[a][0] == b && this._valueCache[a][1] == c ? this : (this._cacheFloat2(a, b, c), this._engine.setFloat2(this.getUniform(a), b, c), this) }, b.prototype.setVector3 = function (a, b) { return this._valueCache[a] && this._valueCache[a][0] == b.x && this._valueCache[a][1] == b.y && this._valueCache[a][2] == b.z ? this : (this._cacheFloat3(a, b.x, b.y, b.z), this._engine.setFloat3(this.getUniform(a), b.x, b.y, b.z), this) }, b.prototype.setFloat3 = function (a, b, c, d) { return this._valueCache[a] && this._valueCache[a][0] == b && this._valueCache[a][1] == c && this._valueCache[a][2] == d ? this : (this._cacheFloat3(a, b, c, d), this._engine.setFloat3(this.getUniform(a), b, c, d), this) }, b.prototype.setFloat4 = function (a, b, c, d, e) { return this._valueCache[a] && this._valueCache[a][0] == b && this._valueCache[a][1] == c && this._valueCache[a][2] == d && this._valueCache[a][3] == e ? this : (this._cacheFloat4(a, b, c, d, e), this._engine.setFloat4(this.getUniform(a), b, c, d, e), this) }, b.prototype.setColor3 = function (a, b) { return this._valueCache[a] && this._valueCache[a][0] == b.r && this._valueCache[a][1] == b.g && this._valueCache[a][2] == b.b ? this : (this._cacheFloat3(a, b.r, b.g, b.b), this._engine.setColor3(this.getUniform(a), b), this) }, b.prototype.setColor4 = function (a, b, c) { return this._valueCache[a] && this._valueCache[a][0] == b.r && this._valueCache[a][1] == b.g && this._valueCache[a][2] == b.b && this._valueCache[a][3] == c ? this : (this._cacheFloat4(a, b.r, b.g, b.b, c), this._engine.setColor4(this.getUniform(a), b, c), this) }, b.ShadersStore = { anaglyphPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D leftSampler;\n\nvoid main(void)\n{\n    vec4 leftFrag = texture2D(leftSampler, vUV);\n    leftFrag = vec4(1.0, leftFrag.g, leftFrag.b, 1.0);\n\n	vec4 rightFrag = texture2D(textureSampler, vUV);\n    rightFrag = vec4(rightFrag.r, 1.0, 1.0, 1.0);\n\n    gl_FragColor = vec4(rightFrag.rgb * leftFrag.rgb, 1.0);\n}", blackAndWhitePixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nvoid main(void) \n{\n	float luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));\n	gl_FragColor = vec4(luminance, luminance, luminance, 1.0);\n}", blurPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Parameters\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\n\nvoid main(void)\n{\n	float weights[7];\n	weights[0] = 0.05;\n	weights[1] = 0.1;\n	weights[2] = 0.2;\n	weights[3] = 0.3;\n	weights[4] = 0.2;\n	weights[5] = 0.1;\n	weights[6] = 0.05;\n\n	vec2 texelSize = vec2(1.0 / screenSize.x, 1.0 / screenSize.y);\n	vec2 texelStep = texelSize * direction * blurWidth;\n	vec2 start = vUV - 3.0 * texelStep;\n\n	vec4 baseColor = vec4(0., 0., 0., 0.);\n	vec2 texelOffset = vec2(0., 0.);\n\n	for (int i = 0; i < 7; i++)\n	{\n		baseColor += texture2D(textureSampler, start + texelOffset) * weights[i];\n		texelOffset += texelStep;\n	}\n\n	gl_FragColor = baseColor;\n}", colorPixelShader: "precision mediump float;\n\nuniform vec3 color;\n\nvoid main(void) {\n	gl_FragColor = vec4(color, 1.);\n}", colorVertexShader: "precision mediump float;\n\n// Attributes\nattribute vec3 position;\n\n// Uniforms\nuniform mat4 worldViewProjection;\n\nvoid main(void) {\n	gl_Position = worldViewProjection * vec4(position, 1.0);\n}", convolutionPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform float kernel[9];\n\nvoid main(void)\n{\n	vec2 onePixel = vec2(1.0, 1.0) / screenSize;\n	vec4 colorSum =\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, -1)) * kernel[0] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, -1)) * kernel[1] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, -1)) * kernel[2] +\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, 0)) * kernel[3] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, 0)) * kernel[4] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, 0)) * kernel[5] +\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, 1)) * kernel[6] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, 1)) * kernel[7] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, 1)) * kernel[8];\n\n	float kernelWeight =\n		kernel[0] +\n		kernel[1] +\n		kernel[2] +\n		kernel[3] +\n		kernel[4] +\n		kernel[5] +\n		kernel[6] +\n		kernel[7] +\n		kernel[8];\n\n	if (kernelWeight <= 0.0) {\n		kernelWeight = 1.0;\n	}\n\n	gl_FragColor = vec4((colorSum / kernelWeight).rgb, 1);\n}", defaultPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_EXPLICIT	0.\n#define MAP_SPHERICAL	1.\n#define MAP_PLANAR		2.\n#define MAP_CUBIC		3.\n#define MAP_PROJECTION	4.\n#define MAP_SKYBOX		5.\n\n// Constants\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec4 vSpecularColor;\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\nuniform vec3 vLightSpecular0;\n#ifdef SHADOW0\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\nuniform float darkness0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\nuniform vec3 vLightSpecular1;\n#ifdef SHADOW1\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\nuniform float darkness1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\nuniform vec3 vLightSpecular2;\n#ifdef SHADOW2\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\nuniform float darkness2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\nuniform vec3 vLightSpecular3;\n#ifdef SHADOW3\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\nuniform float darkness3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Reflection\n#ifdef REFLECTION\nvarying vec3 vPositionUVW;\nuniform samplerCube reflectionCubeSampler;\nuniform sampler2D reflection2DSampler;\nuniform vec3 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform mat4 view;\n\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\n{\n	if (mode == MAP_SPHERICAL)\n	{\n		vec3 coords = vec3(view * vec4(worldNormal, 0.0));\n\n		return vec3(reflectionMatrix * vec4(coords, 1.0));\n	}\n	else if (mode == MAP_PLANAR)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n		return vec3(reflectionMatrix * vec4(coords, 1));\n	}\n	else if (mode == MAP_CUBIC)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = reflect(viewDir, worldNormal);\n\n		return vec3(reflectionMatrix * vec4(coords, 0));\n	}\n	else if (mode == MAP_PROJECTION)\n	{\n		return vec3(reflectionMatrix * (view * worldPos));\n	}\n	else if (mode == MAP_SKYBOX)\n	{\n		return vPositionUVW;\n	}\n\n	return vec3(0, 0, 0);\n}\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n	const vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\n	return dot(color, bitShift);\n}\n\nfloat unpackHalf(vec2 color)\n{\n	return color.x + (color.y / 255.0);\n}\n\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float shadow = unpack(texture2D(shadowSampler, uv));\n\n	if (depth.z > shadow)\n	{\n		return darkness;\n	}\n	return 1.;\n}\n\n// Thanks to http://devmaster.net/\nfloat ChebychevInequality(vec2 moments, float t)\n{\n	if (t <= moments.x)\n	{\n		return 1.0;\n	}\n\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, 0.);\n\n	float d = t - moments.x;\n	return variance / (variance + d * d);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	vec4 texel = texture2D(shadowSampler, uv);\n\n	vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n	return clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\n}\n#endif\n\n// Bump\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform sampler2D bumpSampler;\n\n// Thanks to http://www.thetenthplanet.de/archives/1180\nmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\n{\n	// get edge vectors of the pixel triangle\n	vec3 dp1 = dFdx(p);\n	vec3 dp2 = dFdy(p);\n	vec2 duv1 = dFdx(uv);\n	vec2 duv2 = dFdy(uv);\n\n	// solve the linear system\n	vec3 dp2perp = cross(dp2, normal);\n	vec3 dp1perp = cross(normal, dp1);\n	vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n	vec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\n\n	// construct a scale-invariant frame \n	float invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\n	return mat3(tangent * invmax, binormal * invmax, normal);\n}\n\nvec3 perturbNormal(vec3 viewDir)\n{\n	vec3 map = texture2D(bumpSampler, vBumpUV).xyz * vBumpInfos.y;\n	map = map * 255. / 127. - 128. / 127.;\n	mat3 TBN = cotangent_frame(vNormalW, -viewDir, vBumpUV);\n	return normalize(TBN * map);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nstruct lightingInfo\n{\n	vec3 diffuse;\n	vec3 specular;\n};\n\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range) {\n	lightingInfo result;\n\n	vec3 lightVectorW;\n	float attenuation = 1.0;\n	if (lightData.w == 0.)\n	{\n		vec3 direction = lightData.xyz - vPositionW;\n\n		attenuation =  max(0., 1.0 - length(direction) / range);\n		lightVectorW = normalize(direction);\n	}\n	else\n	{\n		lightVectorW = normalize(-lightData.xyz);\n	}\n\n	// diffuse\n	float ndl = max(0., dot(vNormal, lightVectorW));\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightVectorW);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, max(1., vSpecularColor.a));\n\n	result.diffuse = ndl * diffuseColor * attenuation;\n	result.specular = specComp * specularColor * attenuation;\n\n	return result;\n}\n\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range) {\n	lightingInfo result;\n\n	vec3 direction = lightData.xyz - vPositionW;\n	vec3 lightVectorW = normalize(direction);\n	float attenuation = max(0., 1.0 - length(direction) / range);\n\n	// diffuse\n	float cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\n	float spotAtten = 0.0;\n\n	if (cosAngle >= lightDirection.w)\n	{\n		cosAngle = max(0., pow(cosAngle, lightData.w));\n		spotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\n\n		// Diffuse\n		float ndl = max(0., dot(vNormal, -lightDirection.xyz));\n\n		// Specular\n		vec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\n		float specComp = max(0., dot(vNormal, angleW));\n		specComp = pow(specComp, vSpecularColor.a);\n\n		result.diffuse = ndl * spotAtten * diffuseColor * attenuation;\n		result.specular = specComp * specularColor * spotAtten * attenuation;\n\n		return result;\n	}\n\n	result.diffuse = vec3(0.);\n	result.specular = vec3(0.);\n\n	return result;\n}\n\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor) {\n	lightingInfo result;\n\n	// Diffuse\n	float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, vSpecularColor.a);\n\n	result.diffuse = mix(groundColor, diffuseColor, ndl);\n	result.specular = specComp * specularColor;\n\n	return result;\n}\n\nvoid main(void) {\n	// Clip plane\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n\n	vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n	// Base color\n	vec4 baseColor = vec4(1., 1., 1., 1.);\n	vec3 diffuseColor = vDiffuseColor.rgb;\n\n	// Alpha\n	float alpha = vDiffuseColor.a;\n\n#ifdef VERTEXCOLOR\n	diffuseColor *= vColor;\n#endif\n\n#ifdef DIFFUSE\n	baseColor = texture2D(diffuseSampler, vDiffuseUV);\n\n#ifdef ALPHATEST\n	if (baseColor.a < 0.4)\n		discard;\n#endif\n\n#ifdef ALPHAFROMDIFFUSE\n	alpha *= baseColor.a;\n#endif\n\n	baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n	// Bump\n	vec3 normalW = vNormalW;\n\n#ifdef BUMP\n	normalW = perturbNormal(viewDirectionW);\n#endif\n\n	// Ambient color\n	vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n	baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n#endif\n\n	// Lighting\n	vec3 diffuseBase = vec3(0., 0., 0.);\n	vec3 specularBase = vec3(0., 0., 0.);\n	float shadow = 1.;\n\n#ifdef LIGHT0\n#ifdef SPOTLIGHT0\n	lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\n#endif\n#ifdef HEMILIGHT0\n	lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0);\n#endif\n#ifdef POINTDIRLIGHT0\n	lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n	shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\n#else\n	shadow = computeShadow(vPositionFromLight0, shadowSampler0, darkness0);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT1\n#ifdef SPOTLIGHT1\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\n#endif\n#ifdef HEMILIGHT1\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1);\n#endif\n#ifdef POINTDIRLIGHT1\n	info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n	shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\n#else\n	shadow = computeShadow(vPositionFromLight1, shadowSampler1, darkness1);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT2\n#ifdef SPOTLIGHT2\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\n#endif\n#ifdef HEMILIGHT2\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2);\n#endif\n#ifdef POINTDIRLIGHT2\n	info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n	shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\n#else\n	shadow = computeShadow(vPositionFromLight2, shadowSampler2, darkness2);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT3\n#ifdef SPOTLIGHT3\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\n#endif\n#ifdef HEMILIGHT3\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3);\n#endif\n#ifdef POINTDIRLIGHT3\n	info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n	shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\n#else\n	shadow = computeShadow(vPositionFromLight3, shadowSampler3, darkness3);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n	// Reflection\n	vec3 reflectionColor = vec3(0., 0., 0.);\n\n#ifdef REFLECTION\n	vec3 vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), normalW);\n\n	if (vReflectionInfos.z != 0.0)\n	{\n		reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y;\n	}\n	else\n	{\n		vec2 coords = vReflectionUVW.xy;\n\n		if (vReflectionInfos.x == MAP_PROJECTION)\n		{\n			coords /= vReflectionUVW.z;\n		}\n\n		coords.y = 1.0 - coords.y;\n\n		reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y;\n	}\n#endif\n\n#ifdef OPACITY\n	vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n	opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11) * opacityMap.a;\n	alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#endif\n\n	// Emissive\n	vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n	emissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\n#endif\n\n	// Specular map\n	vec3 specularColor = vSpecularColor.rgb;\n#ifdef SPECULAR\n	specularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\n#endif\n\n	// Composition\n	vec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\n	vec3 finalSpecular = specularBase * specularColor;\n\n	vec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = color;\n}", defaultVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec3 color;\n#endif\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniforms\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#ifdef LIGHT0\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#ifdef LIGHT1\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#ifdef LIGHT2\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#ifdef LIGHT3\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTION\nvarying vec3 vPositionUVW;\n#endif\n\nvoid main(void) {\n	mat4 finalWorld;\n\n#ifdef REFLECTION\n	vPositionUVW = position;\n#endif \n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n\n#ifdef BONES4\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = world * (m0 + m1 + m2 + m3);\n#else\n	finalWorld = world * (m0 + m1 + m2);\n#endif \n\n#else\n	finalWorld = world;\n#endif\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef SPECULAR\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef BUMP\n	if (vBumpInfos.x == 0.)\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Fog\n#ifdef FOG\n	fFogDistance = (view * worldPos).z;\n#endif\n\n	// Shadows\n#ifdef SHADOWS\n#ifdef LIGHT0\n	vPositionFromLight0 = lightMatrix0 * vec4(position, 1.0);\n#endif\n#ifdef LIGHT1\n	vPositionFromLight1 = lightMatrix1 * vec4(position, 1.0);\n#endif\n#ifdef LIGHT2\n	vPositionFromLight2 = lightMatrix2 * vec4(position, 1.0);\n#endif\n#ifdef LIGHT3\n	vPositionFromLight3 = lightMatrix3 * vec4(position, 1.0);\n#endif\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}", displayPassPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D passSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(passSampler, vUV);\n}", filterPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform mat4 kernelMatrix;\n\nvoid main(void)\n{\n	vec3 baseColor = texture2D(textureSampler, vUV).rgb;\n	vec3 updatedColor = (kernelMatrix * vec4(baseColor, 1.0)).rgb;\n\n	gl_FragColor = vec4(updatedColor, 1.0);\n}", fxaaPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 texelSize;\n\nvoid main(){\n	vec2 localTexelSize = texelSize;\n	vec3 rgbNW = texture2D(textureSampler, (vUV + vec2(-1.0, -1.0) * localTexelSize)).xyz;\n	vec3 rgbNE = texture2D(textureSampler, (vUV + vec2(1.0, -1.0) * localTexelSize)).xyz;\n	vec3 rgbSW = texture2D(textureSampler, (vUV + vec2(-1.0, 1.0) * localTexelSize)).xyz;\n	vec3 rgbSE = texture2D(textureSampler, (vUV + vec2(1.0, 1.0) * localTexelSize)).xyz;\n	vec3 rgbM = texture2D(textureSampler, vUV ).xyz;\n	vec3 luma = vec3(0.299, 0.587, 0.114);\n	float lumaNW = dot(rgbNW, luma);\n	float lumaNE = dot(rgbNE, luma);\n	float lumaSW = dot(rgbSW, luma);\n	float lumaSE = dot(rgbSE, luma);\n	float lumaM = dot(rgbM, luma);\n	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n	vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n	float dirReduce = max(\n		(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n		FXAA_REDUCE_MIN);\n\n	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n		max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n		dir * rcpDirMin)) * localTexelSize;\n\n	vec3 rgbA = 0.5 * (\n		texture2D(textureSampler, vUV + dir * (1.0 / 3.0 - 0.5)).xyz +\n		texture2D(textureSampler, vUV + dir * (2.0 / 3.0 - 0.5)).xyz);\n\n	vec3 rgbB = rgbA * 0.5 + 0.25 * (\n		texture2D(textureSampler, vUV + dir *  -0.5).xyz +\n		texture2D(textureSampler, vUV + dir * 0.5).xyz);\n	float lumaB = dot(rgbB, luma);\n	if ((lumaB < lumaMin) || (lumaB > lumaMax)) {\n		gl_FragColor = vec4(rgbA, 1.0);\n	}\n	else {\n		gl_FragColor = vec4(rgbB, 1.0);\n	}\n}", layerPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Color\nuniform vec4 color;\n\nvoid main(void) {\n	vec4 baseColor = texture2D(textureSampler, vUV);\n\n	gl_FragColor = baseColor * color;\n}", layerVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Uniforms\nuniform mat4 textureMatrix;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = vec2(textureMatrix * vec4(position * madd + madd, 1.0, 0.0));\n	gl_Position = vec4(position, 0.0, 1.0);\n}", legacydefaultPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_PROJECTION	4.\n\n// Constants\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec4 vSpecularColor;\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\nuniform vec3 vLightSpecular0;\n#ifdef SHADOW0\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\nuniform vec3 vLightSpecular1;\n#ifdef SHADOW1\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\nuniform vec3 vLightSpecular2;\n#ifdef SHADOW2\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\nuniform vec3 vLightSpecular3;\n#ifdef SHADOW3\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef REFLECTION\nvarying vec3 vReflectionUVW;\nuniform samplerCube reflectionCubeSampler;\nuniform sampler2D reflection2DSampler;\nuniform vec3 vReflectionInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n	const vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\n	return dot(color, bitShift);\n}\n\nfloat unpackHalf(vec2 color)\n{\n	return color.x + (color.y / 255.0);\n}\n\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float shadow = unpack(texture2D(shadowSampler, uv));\n\n	if (depth.z > shadow)\n	{\n		return 0.;\n	}\n	return 1.;\n}\n\n// Thanks to http://devmaster.net/\nfloat ChebychevInequality(vec2 moments, float t)\n{\n	if (t <= moments.x)\n	{\n		return 1.0;\n	}\n\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, 0.);\n\n	float d = t - moments.x;\n	return variance / (variance + d * d);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	vec4 texel = texture2D(shadowSampler, uv);\n\n	vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n	return clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nmat3 computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor) {\n	mat3 result;\n\n	vec3 lightVectorW;\n	if (lightData.w == 0.)\n	{\n		lightVectorW = normalize(lightData.xyz - vPositionW);\n	}\n	else\n	{\n		lightVectorW = normalize(-lightData.xyz);\n	}\n\n	// diffuse\n	float ndl = max(0., dot(vNormal, lightVectorW));\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightVectorW);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = max(0., pow(specComp, max(1.0, vSpecularColor.a)));\n\n	result[0] = ndl * diffuseColor.rgb;\n	result[1] = specComp * specularColor;\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nmat3 computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec4 diffuseColor, vec3 specularColor) {\n	mat3 result;\n\n	vec3 lightVectorW = normalize(lightData.xyz - vPositionW);\n\n	// diffuse\n	float cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\n	float spotAtten = 0.0;\n\n	if (cosAngle >= lightDirection.w)\n	{\n		cosAngle = max(0., pow(cosAngle, lightData.w));\n		spotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\n\n		// Diffuse\n		float ndl = max(0., dot(vNormal, -lightDirection.xyz));\n\n		// Specular\n		vec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\n		float specComp = max(0., dot(vNormal, angleW));\n		specComp = pow(specComp, vSpecularColor.a);\n\n		result[0] = ndl * spotAtten * diffuseColor.rgb;\n		result[1] = specComp * specularColor * spotAtten;\n		result[2] = vec3(0.);\n\n		return result;\n	}\n\n	result[0] = vec3(0.);\n	result[1] = vec3(0.);\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nmat3 computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor, vec3 groundColor) {\n	mat3 result;\n\n	// Diffuse\n	float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, vSpecularColor.a);\n\n	result[0] = mix(groundColor, diffuseColor.rgb, ndl);\n	result[1] = specComp * specularColor;\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nvoid main(void) {\n	// Clip plane\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n\n	vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n	// Base color\n	vec4 baseColor = vec4(1., 1., 1., 1.);\n	vec3 diffuseColor = vDiffuseColor.rgb;\n\n#ifdef VERTEXCOLOR\n	diffuseColor *= vColor;\n#endif\n\n#ifdef DIFFUSE\n	baseColor = texture2D(diffuseSampler, vDiffuseUV);\n\n#ifdef ALPHATEST\n	if (baseColor.a < 0.4)\n		discard;\n#endif\n\n	baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n	// Bump\n	vec3 normalW = vNormalW;\n\n	// Ambient color\n	vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n	baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n#endif\n\n	// Lighting\n	vec3 diffuseBase = vec3(0., 0., 0.);\n	vec3 specularBase = vec3(0., 0., 0.);\n	float shadow = 1.;\n\n#ifdef LIGHT0\n#ifdef SPOTLIGHT0\n	mat3 info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0, vLightSpecular0);\n#endif\n#ifdef HEMILIGHT0\n	mat3 info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0, vLightGround0);\n#endif\n#ifdef POINTDIRLIGHT0\n	mat3 info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n	shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\n#else\n	shadow = computeShadow(vPositionFromLight0, shadowSampler0);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT1\n#ifdef SPOTLIGHT1\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1, vLightSpecular1);\n#endif\n#ifdef HEMILIGHT1\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1, vLightGround1);\n#endif\n#ifdef POINTDIRLIGHT1\n	info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n	shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\n#else\n	shadow = computeShadow(vPositionFromLight1, shadowSampler1);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT2\n#ifdef SPOTLIGHT2\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2, vLightSpecular2);\n#endif\n#ifdef HEMILIGHT2\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2, vLightGround2);\n#endif\n#ifdef POINTDIRLIGHT2\n	info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n	shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\n#else\n	shadow = computeShadow(vPositionFromLight2, shadowSampler2);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT3\n#ifdef SPOTLIGHT3\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3, vLightSpecular3);\n#endif\n#ifdef HEMILIGHT3\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3, vLightGround3);\n#endif\n#ifdef POINTDIRLIGHT3\n	info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n	shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\n#else\n	shadow = computeShadow(vPositionFromLight3, shadowSampler3);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n	// Reflection\n	vec3 reflectionColor = vec3(0., 0., 0.);\n\n#ifdef REFLECTION\n	if (vReflectionInfos.z != 0.0)\n	{\n		reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y;\n	}\n	else\n	{\n		vec2 coords = vReflectionUVW.xy;\n\n		if (vReflectionInfos.x == MAP_PROJECTION)\n		{\n			coords /= vReflectionUVW.z;\n		}\n\n		coords.y = 1.0 - coords.y;\n\n		reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y;\n	}\n#endif\n\n	// Alpha\n	float alpha = vDiffuseColor.a;\n\n#ifdef OPACITY\n	vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n	opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11) * opacityMap.a;\n	alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#endif\n\n	// Emissive\n	vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n	emissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\n#endif\n\n	// Specular map\n	vec3 specularColor = vSpecularColor.rgb;\n#ifdef SPECULAR\n	specularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\n#endif\n\n	// Composition\n	vec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\n	vec3 finalSpecular = specularBase * specularColor;\n\n	vec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = color;\n}", legacydefaultVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_EXPLICIT	0.\n#define MAP_SPHERICAL	1.\n#define MAP_PLANAR		2.\n#define MAP_CUBIC		3.\n#define MAP_PROJECTION	4.\n#define MAP_SKYBOX		5.\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec3 color;\n#endif\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniforms\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef REFLECTION\nuniform vec3 vEyePosition;\nvarying vec3 vReflectionUVW;\nuniform vec3 vReflectionInfos;\nuniform mat4 reflectionMatrix;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#ifdef LIGHT0\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#ifdef LIGHT1\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#ifdef LIGHT2\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#ifdef LIGHT3\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTION\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\n{\n	if (mode == MAP_SPHERICAL)\n	{\n		vec3 coords = vec3(view * vec4(worldNormal, 0.0));\n\n		return vec3(reflectionMatrix * vec4(coords, 1.0));\n	}\n	else if (mode == MAP_PLANAR)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n		return vec3(reflectionMatrix * vec4(coords, 1));\n	}\n	else if (mode == MAP_CUBIC)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = reflect(viewDir, worldNormal);\n\n		return vec3(reflectionMatrix * vec4(coords, 0));\n	}\n	else if (mode == MAP_PROJECTION)\n	{\n		return vec3(reflectionMatrix * (view * worldPos));\n	}\n	else if (mode == MAP_SKYBOX)\n	{\n		return position;\n	}\n\n	return vec3(0, 0, 0);\n}\n#endif\n\nvoid main(void) {\n	mat4 finalWorld;\n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n\n#ifdef BONES4\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = world * (m0 + m1 + m2 + m3);\n#else\n	finalWorld = world * (m0 + m1 + m2);\n#endif \n\n#else\n	finalWorld = world;\n#endif\n\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef REFLECTION\n	vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), vNormalW);\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef SPECULAR\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef BUMP\n	if (vBumpInfos.x == 0.)\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Fog\n#ifdef FOG\n	fFogDistance = (view * worldPos).z;\n#endif\n\n	// Shadows\n#ifdef SHADOWS\n#ifdef LIGHT0\n	vPositionFromLight0 = lightMatrix0 * vec4(position, 1.0);\n#endif\n#ifdef LIGHT1\n	vPositionFromLight1 = lightMatrix1 * vec4(position, 1.0);\n#endif\n#ifdef LIGHT2\n	vPositionFromLight2 = lightMatrix2 * vec4(position, 1.0);\n#endif\n#ifdef LIGHT3\n	vPositionFromLight3 = lightMatrix3 * vec4(position, 1.0);\n#endif\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}", lensFlarePixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Color\nuniform vec4 color;\n\nvoid main(void) {\n	vec4 baseColor = texture2D(textureSampler, vUV);\n\n	gl_FragColor = baseColor * color;\n}", lensFlareVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Uniforms\nuniform mat4 viewportMatrix;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = position * madd + madd;\n	gl_Position = viewportMatrix * vec4(position, 0.0, 1.0);\n}", oculusDistortionCorrectionPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 LensCenter;\nuniform vec2 Scale;\nuniform vec2 ScaleIn;\nuniform vec4 HmdWarpParam;\n\nvec2 HmdWarp(vec2 in01) {\n\n	vec2 theta = (in01 - LensCenter) * ScaleIn; // Scales to [-1, 1]\n	float rSq = theta.x * theta.x + theta.y * theta.y;\n	vec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n	return LensCenter + Scale * rvector;\n}\n\n\n\nvoid main(void)\n{\n	vec2 tc = HmdWarp(vUV);\n	if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	else{\n		gl_FragColor = vec4(texture2D(textureSampler, tc).rgb, 1.0);\n	}\n}", particlesPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n	vec4 baseColor = texture2D(diffuseSampler, vUV);\n\n	gl_FragColor = (baseColor * textureMask + (vec4(1., 1., 1., 1.) - textureMask)) * vColor;\n}", particlesVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec4 color;\nattribute vec4 options;\n\n// Uniforms\nuniform mat4 view;\nuniform mat4 projection;\n\n// Output\nvarying vec2 vUV;\nvarying vec4 vColor;\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nuniform mat4 invView;\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {	\n	vec3 viewPos = (view * vec4(position, 1.0)).xyz; \n	vec3 cornerPos;\n	float size = options.y;\n	float angle = options.x;\n	vec2 offset = options.zw;\n\n	cornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\n\n	// Rotate\n	vec3 rotatedCorner;\n	rotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\n	rotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\n	rotatedCorner.z = 0.;\n\n	// Position\n	viewPos += rotatedCorner;\n	gl_Position = projection * vec4(viewPos, 1.0);   \n	\n	vColor = color;\n	vUV = offset;\n\n	// Clip plane\n#ifdef CLIPPLANE\n	vec4 worldPos = invView * vec4(viewPos, 1.0);\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n}", passPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nvoid main(void) \n{\n	gl_FragColor = texture2D(textureSampler, vUV);\n}", postprocessVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = position * madd + madd;\n	gl_Position = vec4(position, 0.0, 1.0);\n}", refractionPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D refractionSampler;\n\n// Parameters\nuniform vec3 baseColor;\nuniform float depth;\nuniform float colorLevel;\n\nvoid main() {\n	float ref = 1.0 - texture2D(refractionSampler, vUV).r;\n\n	vec2 uv = vUV - vec2(0.5);\n	vec2 offset = uv * depth * ref;\n	vec3 sourceColor = texture2D(textureSampler, vUV - offset).rgb;\n\n	gl_FragColor = vec4(sourceColor + sourceColor * ref * colorLevel, 1.0);\n}", shadowMapPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec4 pack(float depth)\n{\n	const vec4 bitOffset = vec4(255. * 255. * 255., 255. * 255., 255., 1.);\n	const vec4 bitMask = vec4(0., 1. / 255., 1. / 255., 1. / 255.);\n	\n	vec4 comp = mod(depth * bitOffset * vec4(254.), vec4(255.)) / vec4(254.);\n	comp -= comp.xxyz * bitMask;\n	\n	return comp;\n}\n\n// Thanks to http://devmaster.net/\nvec2 packHalf(float depth) \n{ \n	const vec2 bitOffset = vec2(1.0 / 255., 0.);\n	vec2 color = vec2(depth, fract(depth * 255.));\n\n	return color - (color.yy * bitOffset);\n}\n\n#ifndef VSM\nvarying vec4 vPosition;\n#endif\n\nvoid main(void)\n{\n#ifdef VSM\n	float moment1 = gl_FragCoord.z / gl_FragCoord.w;\n	float moment2 = moment1 * moment1;\n	gl_FragColor = vec4(packHalf(moment1), packHalf(moment2));\n#else\n	gl_FragColor = pack(vPosition.z / vPosition.w);\n#endif\n}", shadowMapVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attribute\nattribute vec3 position;\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniform\n#ifdef BONES\nuniform mat4 world;\nuniform mat4 mBones[BonesPerMesh];\nuniform mat4 viewProjection;\n#else\nuniform mat4 worldViewProjection;\n#endif\n\n#ifndef VSM\nvarying vec4 vPosition;\n#endif\n\nvoid main(void)\n{\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	mat4 finalWorld = world * (m0 + m1 + m2 + m3);\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n#else\n#ifndef VSM\n	vPosition = worldViewProjection * vec4(position, 1.0);\n#endif\n	gl_Position = worldViewProjection * vec4(position, 1.0);\n#endif\n}", spritesPixelShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform bool alphaTest;\n\nvarying vec4 vColor;\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return min(1., max(0., fogCoeff));\n}\n#endif\n\n\nvoid main(void) {\n	vec4 baseColor = texture2D(diffuseSampler, vUV);\n\n	if (alphaTest) \n	{\n		if (baseColor.a < 0.95)\n			discard;\n	}\n\n	baseColor *= vColor;\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	baseColor.rgb = fog * baseColor.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = baseColor;\n}", spritesVertexShader: "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec4 options;\nattribute vec4 cellInfo;\nattribute vec4 color;\n\n// Uniforms\nuniform vec2 textureInfos;\nuniform mat4 view;\nuniform mat4 projection;\n\n// Output\nvarying vec2 vUV;\nvarying vec4 vColor;\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\nvoid main(void) {	\n	vec3 viewPos = (view * vec4(position, 1.0)).xyz; \n	vec3 cornerPos;\n	\n	float angle = options.x;\n	float size = options.y;\n	vec2 offset = options.zw;\n	vec2 uvScale = textureInfos.xy;\n\n	cornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\n\n	// Rotate\n	vec3 rotatedCorner;\n	rotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\n	rotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\n	rotatedCorner.z = 0.;\n\n	// Position\n	viewPos += rotatedCorner;\n	gl_Position = projection * vec4(viewPos, 1.0);   \n\n	// Color\n	vColor = color;\n	\n	// Texture\n	vec2 uvOffset = vec2(abs(offset.x - cellInfo.x), 1.0 - abs(offset.y - cellInfo.y));\n\n	vUV = (uvOffset + cellInfo.zw) * uvScale;\n\n	// Fog\n#ifdef FOG\n	fFogDistance = viewPos.z;\n#endif\n}" }, b
	}(); a.Effect = b
}(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function a(a, b, c) { this.name = a, this.checkReadyOnEveryCall = !0, this.checkReadyOnlyOnce = !1, this.alpha = 1, this.wireframe = !1, this.backFaceCulling = !0, this._wasPreviouslyReady = !1, this.id = a, this._scene = b, c || b.materials.push(this) } return a.prototype.isReady = function () { return !0 }, a.prototype.getEffect = function () { return this._effect }, a.prototype.getScene = function () { return this._scene }, a.prototype.needAlphaBlending = function () { return this.alpha < 1 }, a.prototype.needAlphaTesting = function () { return !1 }, a.prototype.trackCreation = function () { }, a.prototype._preBind = function () { var a = this._scene.getEngine(); a.enableEffect(this._effect), a.setState(this.backFaceCulling) }, a.prototype.bind = function () { }, a.prototype.unbind = function () { }, a.prototype.dispose = function (a) { var b = this._scene.materials.indexOf(this); this._scene.materials.splice(b, 1), a && this._effect && (this._scene.getEngine()._releaseEffect(this._effect), this._effect = null), this.onDispose && this.onDispose() }, a }(); a.Material = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = 4, c = function (c) { function d(b, d) { var e = this; c.call(this, b, d), this.ambientColor = new a.Color3(0, 0, 0), this.diffuseColor = new a.Color3(1, 1, 1), this.specularColor = new a.Color3(1, 1, 1), this.specularPower = 64, this.emissiveColor = new a.Color3(0, 0, 0), this.useAlphaFromDiffuseTexture = !1, this._cachedDefines = null, this._renderTargets = new a.SmartArray(16), this._worldViewProjectionMatrix = a.Matrix.Zero(), this._lightMatrix = a.Matrix.Zero(), this._globalAmbientColor = new a.Color3(0, 0, 0), this._baseColor = new a.Color3, this._scaledDiffuse = new a.Color3, this._scaledSpecular = new a.Color3, this.getRenderTargetTextures = function () { return e._renderTargets.reset(), e.reflectionTexture && e.reflectionTexture.isRenderTarget && e._renderTargets.push(e.reflectionTexture), e._renderTargets } } return __extends(d, c), d.prototype.needAlphaBlending = function () { return this.alpha < 1 || null != this.opacityTexture || this._shouldUseAlphaFromDiffuseTexture() }, d.prototype.needAlphaTesting = function () { return null != this.diffuseTexture && this.diffuseTexture.hasAlpha }, d.prototype._shouldUseAlphaFromDiffuseTexture = function () { return null != this.diffuseTexture && this.diffuseTexture.hasAlpha && this.useAlphaFromDiffuseTexture }, d.prototype.isReady = function (c) { if (this.checkReadyOnlyOnce && this._wasPreviouslyReady) return !0; var d = this.getScene(); if (!this.checkReadyOnEveryCall && this._renderId === d.getRenderId()) return !0; var e = d.getEngine(), f = [], g = new Array; if (d.texturesEnabled) { if (this.diffuseTexture && a.StandardMaterial.DiffuseTextureEnabled) { if (!this.diffuseTexture.isReady()) return !1; f.push("#define DIFFUSE") } if (this.ambientTexture && a.StandardMaterial.AmbientTextureEnabled) { if (!this.ambientTexture.isReady()) return !1; f.push("#define AMBIENT") } if (this.opacityTexture && a.StandardMaterial.OpacityTextureEnabled) { if (!this.opacityTexture.isReady()) return !1; f.push("#define OPACITY") } if (this.reflectionTexture && a.StandardMaterial.ReflectionTextureEnabled) { if (!this.reflectionTexture.isReady()) return !1; f.push("#define REFLECTION") } if (this.emissiveTexture && a.StandardMaterial.EmissiveTextureEnabled) { if (!this.emissiveTexture.isReady()) return !1; f.push("#define EMISSIVE") } if (this.specularTexture && a.StandardMaterial.SpecularTextureEnabled) { if (!this.specularTexture.isReady()) return !1; f.push("#define SPECULAR"), g.push(f[f.length - 1]) } } if (d.getEngine().getCaps().standardDerivatives && this.bumpTexture && a.StandardMaterial.BumpTextureEnabled) { if (!this.bumpTexture.isReady()) return !1; f.push("#define BUMP"), g.push(f[f.length - 1]) } d.clipPlane && f.push("#define CLIPPLANE"), e.getAlphaTesting() && f.push("#define ALPHATEST"), this._shouldUseAlphaFromDiffuseTexture() && f.push("#define ALPHAFROMDIFFUSE"), d.fogMode !== a.Scene.FOGMODE_NONE && (f.push("#define FOG"), g.push(f[f.length - 1])); var h = !1, i = 0; if (d.lightsEnabled) for (var j = 0; j < d.lights.length; j++) { var k = d.lights[j]; if (k.isEnabled() && (!c || -1 === k.excludedMeshes.indexOf(c))) { f.push("#define LIGHT" + i), i > 0 && g.push(f[f.length - 1]); var l; l = k instanceof a.SpotLight ? "#define SPOTLIGHT" + i : k instanceof a.HemisphericLight ? "#define HEMILIGHT" + i : "#define POINTDIRLIGHT" + i, f.push(l), i > 0 && g.push(f[f.length - 1]); var m = k.getShadowGenerator(); if (c && c.receiveShadows && m && (f.push("#define SHADOW" + i), i > 0 && g.push(f[f.length - 1]), h || (f.push("#define SHADOWS"), h = !0), m.useVarianceShadowMap && (f.push("#define SHADOWVSM" + i), i > 0 && g.push(f[f.length - 1]))), i++, i == b) break } } var n = [a.VertexBuffer.PositionKind, a.VertexBuffer.NormalKind]; c && (c.isVerticesDataPresent(a.VertexBuffer.UVKind) && (n.push(a.VertexBuffer.UVKind), f.push("#define UV1")), c.isVerticesDataPresent(a.VertexBuffer.UV2Kind) && (n.push(a.VertexBuffer.UV2Kind), f.push("#define UV2")), c.isVerticesDataPresent(a.VertexBuffer.ColorKind) && (n.push(a.VertexBuffer.ColorKind), f.push("#define VERTEXCOLOR")), c.skeleton && c.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind) && c.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind) && (n.push(a.VertexBuffer.MatricesIndicesKind), n.push(a.VertexBuffer.MatricesWeightsKind), f.push("#define BONES"), f.push("#define BonesPerMesh " + c.skeleton.bones.length), f.push("#define BONES4"), g.push(f[f.length - 1]))); var o = f.join("\n"); if (this._cachedDefines != o) { this._cachedDefines = o; var p = "default"; d.getEngine().getCaps().standardDerivatives || (p = "legacydefault"), this._effect = d.getEngine().createEffect(p, n, ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vDiffuseColor", "vSpecularColor", "vEmissiveColor", "vLightData0", "vLightDiffuse0", "vLightSpecular0", "vLightDirection0", "vLightGround0", "lightMatrix0", "vLightData1", "vLightDiffuse1", "vLightSpecular1", "vLightDirection1", "vLightGround1", "lightMatrix1", "vLightData2", "vLightDiffuse2", "vLightSpecular2", "vLightDirection2", "vLightGround2", "lightMatrix2", "vLightData3", "vLightDiffuse3", "vLightSpecular3", "vLightDirection3", "vLightGround3", "lightMatrix3", "vFogInfos", "vFogColor", "vDiffuseInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vEmissiveInfos", "vSpecularInfos", "vBumpInfos", "mBones", "vClipPlane", "diffuseMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "specularMatrix", "bumpMatrix", "darkness0", "darkness1", "darkness2", "darkness3"], ["diffuseSampler", "ambientSampler", "opacitySampler", "reflectionCubeSampler", "reflection2DSampler", "emissiveSampler", "specularSampler", "bumpSampler", "shadowSampler0", "shadowSampler1", "shadowSampler2", "shadowSampler3"], o, g, this.onCompiled, this.onError) } return this._effect.isReady() ? (this._renderId = d.getRenderId(), this._wasPreviouslyReady = !0, !0) : !1 }, d.prototype.unbind = function () { this.reflectionTexture && this.reflectionTexture.isRenderTarget && this._effect.setTexture("reflection2DSampler", null) }, d.prototype.bind = function (c, d) { var e = this.getScene(); if (this._baseColor.copyFrom(this.diffuseColor), this._effect.setMatrix("world", c), this._effect.setMatrix("viewProjection", e.getTransformMatrix()), d.skeleton && d.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind) && d.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind) && this._effect.setMatrices("mBones", d.skeleton.getTransformMatrices()), this.diffuseTexture && a.StandardMaterial.DiffuseTextureEnabled && (this._effect.setTexture("diffuseSampler", this.diffuseTexture), this._effect.setFloat2("vDiffuseInfos", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level), this._effect.setMatrix("diffuseMatrix", this.diffuseTexture._computeTextureMatrix()), this._baseColor.copyFromFloats(1, 1, 1)), this.ambientTexture && a.StandardMaterial.AmbientTextureEnabled && (this._effect.setTexture("ambientSampler", this.ambientTexture), this._effect.setFloat2("vAmbientInfos", this.ambientTexture.coordinatesIndex, this.ambientTexture.level), this._effect.setMatrix("ambientMatrix", this.ambientTexture._computeTextureMatrix())), this.opacityTexture && a.StandardMaterial.OpacityTextureEnabled && (this._effect.setTexture("opacitySampler", this.opacityTexture), this._effect.setFloat2("vOpacityInfos", this.opacityTexture.coordinatesIndex, this.opacityTexture.level), this._effect.setMatrix("opacityMatrix", this.opacityTexture._computeTextureMatrix())), this.reflectionTexture && a.StandardMaterial.ReflectionTextureEnabled && (this.reflectionTexture.isCube ? this._effect.setTexture("reflectionCubeSampler", this.reflectionTexture) : this._effect.setTexture("reflection2DSampler", this.reflectionTexture), this._effect.setMatrix("reflectionMatrix", this.reflectionTexture._computeReflectionTextureMatrix()), this._effect.setFloat3("vReflectionInfos", this.reflectionTexture.coordinatesMode, this.reflectionTexture.level, this.reflectionTexture.isCube ? 1 : 0)), this.emissiveTexture && a.StandardMaterial.EmissiveTextureEnabled && (this._effect.setTexture("emissiveSampler", this.emissiveTexture), this._effect.setFloat2("vEmissiveInfos", this.emissiveTexture.coordinatesIndex, this.emissiveTexture.level), this._effect.setMatrix("emissiveMatrix", this.emissiveTexture._computeTextureMatrix())), this.specularTexture && a.StandardMaterial.SpecularTextureEnabled && (this._effect.setTexture("specularSampler", this.specularTexture), this._effect.setFloat2("vSpecularInfos", this.specularTexture.coordinatesIndex, this.specularTexture.level), this._effect.setMatrix("specularMatrix", this.specularTexture._computeTextureMatrix())), this.bumpTexture && e.getEngine().getCaps().standardDerivatives && a.StandardMaterial.BumpTextureEnabled && (this._effect.setTexture("bumpSampler", this.bumpTexture), this._effect.setFloat2("vBumpInfos", this.bumpTexture.coordinatesIndex, this.bumpTexture.level), this._effect.setMatrix("bumpMatrix", this.bumpTexture._computeTextureMatrix())), e.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), this._effect.setVector3("vEyePosition", e.activeCamera.position), this._effect.setColor3("vAmbientColor", this._globalAmbientColor), this._effect.setColor4("vDiffuseColor", this._baseColor, this.alpha * d.visibility), this._effect.setColor4("vSpecularColor", this.specularColor, this.specularPower), this._effect.setColor3("vEmissiveColor", this.emissiveColor), e.lightsEnabled) for (var f = 0, g = 0; g < e.lights.length; g++) { var h = e.lights[g]; if (h.isEnabled() && (!d || -1 === h.excludedMeshes.indexOf(d))) { h instanceof a.PointLight ? h.transferToEffect(this._effect, "vLightData" + f) : h instanceof a.DirectionalLight ? h.transferToEffect(this._effect, "vLightData" + f) : h instanceof a.SpotLight ? h.transferToEffect(this._effect, "vLightData" + f, "vLightDirection" + f) : h instanceof a.HemisphericLight && h.transferToEffect(this._effect, "vLightData" + f, "vLightGround" + f), h.diffuse.scaleToRef(h.intensity, this._scaledDiffuse), h.specular.scaleToRef(h.intensity, this._scaledSpecular), this._effect.setColor4("vLightDiffuse" + f, this._scaledDiffuse, h.range), this._effect.setColor3("vLightSpecular" + f, this._scaledSpecular); var i = h.getShadowGenerator(); if (d.receiveShadows && i && (c.multiplyToRef(i.getTransformMatrix(), this._lightMatrix), this._effect.setMatrix("lightMatrix" + f, this._lightMatrix), this._effect.setTexture("shadowSampler" + f, i.getShadowMap()), this._effect.setFloat("darkness" + f, i.getDarkness())), f++, f == b) break } } if (e.clipPlane) { var j = e.clipPlane; this._effect.setFloat4("vClipPlane", j.normal.x, j.normal.y, j.normal.z, j.d) } (e.fogMode !== a.Scene.FOGMODE_NONE || this.reflectionTexture) && this._effect.setMatrix("view", e.getViewMatrix()), e.fogMode !== a.Scene.FOGMODE_NONE && (this._effect.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), this._effect.setColor3("vFogColor", e.fogColor)) }, d.prototype.getAnimatables = function () { var a = []; return this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0 && a.push(this.diffuseTexture), this.ambientTexture && this.ambientTexture.animations && this.ambientTexture.animations.length > 0 && a.push(this.ambientTexture), this.opacityTexture && this.opacityTexture.animations && this.opacityTexture.animations.length > 0 && a.push(this.opacityTexture), this.reflectionTexture && this.reflectionTexture.animations && this.reflectionTexture.animations.length > 0 && a.push(this.reflectionTexture), this.emissiveTexture && this.emissiveTexture.animations && this.emissiveTexture.animations.length > 0 && a.push(this.emissiveTexture), this.specularTexture && this.specularTexture.animations && this.specularTexture.animations.length > 0 && a.push(this.specularTexture), this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0 && a.push(this.bumpTexture), a }, d.prototype.dispose = function (a) { this.diffuseTexture && this.diffuseTexture.dispose(), this.ambientTexture && this.ambientTexture.dispose(), this.opacityTexture && this.opacityTexture.dispose(), this.reflectionTexture && this.reflectionTexture.dispose(), this.emissiveTexture && this.emissiveTexture.dispose(), this.specularTexture && this.specularTexture.dispose(), this.bumpTexture && this.bumpTexture.dispose(), c.prototype.dispose.call(this, a) }, d.prototype.clone = function (b) { var c = new a.StandardMaterial(b, this.getScene()); return c.checkReadyOnEveryCall = this.checkReadyOnEveryCall, c.alpha = this.alpha, c.wireframe = this.wireframe, c.backFaceCulling = this.backFaceCulling, this.diffuseTexture && this.diffuseTexture.clone && (c.diffuseTexture = this.diffuseTexture.clone()), this.ambientTexture && this.ambientTexture.clone && (c.ambientTexture = this.ambientTexture.clone()), this.opacityTexture && this.opacityTexture.clone && (c.opacityTexture = this.opacityTexture.clone()), this.reflectionTexture && this.reflectionTexture.clone && (c.reflectionTexture = this.reflectionTexture.clone()), this.emissiveTexture && this.emissiveTexture.clone && (c.emissiveTexture = this.emissiveTexture.clone()), this.specularTexture && this.specularTexture.clone && (c.specularTexture = this.specularTexture.clone()), this.bumpTexture && this.bumpTexture.clone && (c.bumpTexture = this.bumpTexture.clone()), c.ambientColor = this.ambientColor.clone(), c.diffuseColor = this.diffuseColor.clone(), c.specularColor = this.specularColor.clone(), c.specularPower = this.specularPower, c.emissiveColor = this.emissiveColor.clone(), c }, d.DiffuseTextureEnabled = !0, d.AmbientTextureEnabled = !0, d.OpacityTextureEnabled = !0, d.ReflectionTextureEnabled = !0, d.EmissiveTextureEnabled = !0, d.SpecularTextureEnabled = !0, d.BumpTextureEnabled = !0, d }(a.Material); a.StandardMaterial = c }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c) { a.call(this, b, c, !0), this.subMaterials = new Array, c.multiMaterials.push(this) } return __extends(b, a), b.prototype.getSubMaterial = function (a) { return 0 > a || a >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[a] }, b.prototype.isReady = function (a) { for (var b = 0; b < this.subMaterials.length; b++) { var c = this.subMaterials[b]; if (c && !this.subMaterials[b].isReady(a)) return !1 } return !0 }, b }(a.Material); a.MultiMaterial = b }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { function a(a) { var b = document.createElement("a"); b.href = a; var c = a.substring(a.lastIndexOf("/") + 1, a.length), d = a.substring(0, a.indexOf(c, 0)); return d } { var b = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction, window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange } BABYLON.Database = function (a) { this.currentSceneUrl = BABYLON.Database.ReturnFullUrlLocation(a), this.db = null, this.enableSceneOffline = !1, this.enableTexturesOffline = !1, this.manifestVersionFound = 0, this.mustUpdateRessources = !1, this.hasReachedQuota = !1, this.checkManifestFile() }, BABYLON.Database.isUASupportingBlobStorage = !0, BABYLON.Database.ReturnFullUrlLocation = function (b) { return -1 === b.indexOf("http:/") ? a(window.location.href) + b : b }, BABYLON.Database.prototype.checkManifestFile = function () { function a() { BABYLON.Tools.Log("Valid manifest file not found. Scene & textures will be loaded directly from the web server."), b.enableSceneOffline = !1, b.enableTexturesOffline = !1 } var b = this, c = this.currentSceneUrl + ".manifest", d = new XMLHttpRequest; d.open("GET", c, !1), d.addEventListener("load", function () { if (200 === d.status) try { var c = JSON.parse(d.response); b.enableSceneOffline = c.enableSceneOffline, b.enableTexturesOffline = c.enableTexturesOffline, c.version && !isNaN(parseInt(c.version)) && (b.manifestVersionFound = c.version) } catch (e) { a() } else a() }, !1), d.addEventListener("error", function () { a() }, !1); try { d.send() } catch (e) { BABYLON.Tools.Error("Error on XHR send request.") } }, BABYLON.Database.prototype.openAsync = function (a, c) { function d() { e.isSupported = !1, c && c() } var e = this; if (b && (this.enableSceneOffline || this.enableTexturesOffline)) if (this.db) a && a(); else { this.hasReachedQuota = !1, this.isSupported = !0; var f = b.open("babylonjs", 1); f.onerror = function () { d() }, f.onblocked = function () { BABYLON.Tools.Error("IDB request blocked. Please reload the page."), d() }, f.onsuccess = function () { e.db = f.result, a() }, f.onupgradeneeded = function (a) { e.db = a.target.result; try { { e.db.createObjectStore("scenes", { keyPath: "sceneUrl" }), e.db.createObjectStore("versions", { keyPath: "sceneUrl" }), e.db.createObjectStore("textures", { keyPath: "textureUrl" }) } } catch (b) { BABYLON.Tools.Error("Error while creating object stores. Exception: " + b.message), d() } } } else this.isSupported = !1, c && c() }, BABYLON.Database.prototype.loadImageFromDB = function (a, b) { var c = this, d = BABYLON.Database.ReturnFullUrlLocation(a), e = function () { c.hasReachedQuota || null === c.db ? b.src = a : c._saveImageIntoDBAsync(d, b) }; this.mustUpdateRessources ? e() : this._loadImageFromDBAsync(d, b, e) }, BABYLON.Database.prototype._loadImageFromDBAsync = function (a, b, c) { if (this.isSupported && null !== this.db) { var d, e = this.db.transaction(["textures"]); e.onabort = function () { b.src = a }, e.oncomplete = function () { var a; if (d) { var e = window.URL || window.webkitURL; a = e.createObjectURL(d.data, { oneTimeOnly: !0 }), b.src = a } else c() }; var f = e.objectStore("textures").get(a); f.onsuccess = function (a) { d = a.target.result }, f.onerror = function () { BABYLON.Tools.Error("Error loading texture " + a + " from DB."), b.src = a } } else BABYLON.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), b.src = a }, BABYLON.Database.prototype._saveImageIntoDBAsync = function (a, b) { if (this.isSupported) { var c = function () { var a; if (d) { var c = window.URL || window.webkitURL; try { a = c.createObjectURL(d, { oneTimeOnly: !0 }) } catch (e) { a = c.createObjectURL(d) } } b.src = a }; if (BABYLON.Database.isUASupportingBlobStorage) { var d, e = this, f = new XMLHttpRequest; f.open("GET", a, !0), f.responseType = "blob", f.addEventListener("load", function () { if (200 === f.status) { d = f.response; var g = e.db.transaction(["textures"], "readwrite"); g.onabort = function (a) { try { "QuotaExceededError" === a.srcElement.error.name && (e.hasReachedQuota = !0) } catch (b) { } c() }, g.oncomplete = function () { c() }; var h = {}; h.textureUrl = a, h.data = d; try { var i = g.objectStore("textures").put(h); i.onsuccess = function () { }, i.onerror = function () { c() } } catch (j) { 25 === j.code && (BABYLON.Database.isUASupportingBlobStorage = !1), b.src = a } } else b.src = a }, !1), f.addEventListener("error", function () { BABYLON.Tools.Error("Error in XHR request in BABYLON.Database."), b.src = a }, !1), f.send() } else b.src = a } else BABYLON.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), b.src = a }, BABYLON.Database.prototype._checkVersionFromDB = function (a, b) { var c = this, d = function () { c._saveVersionIntoDBAsync(a, b) }; this._loadVersionFromDBAsync(a, b, d) }, BABYLON.Database.prototype._loadVersionFromDBAsync = function (a, b, c) { if (this.isSupported) { var d, e = this; try { var f = this.db.transaction(["versions"]); f.oncomplete = function () { d ? e.manifestVersionFound > d.data ? (e.mustUpdateRessources = !0, c()) : b(d.data) : (e.mustUpdateRessources = !0, c()) }, f.onabort = function () { b(-1) }; var g = f.objectStore("versions").get(a); g.onsuccess = function (a) { d = a.target.result }, g.onerror = function () { BABYLON.Tools.Error("Error loading version for scene " + a + " from DB."), b(-1) } } catch (h) { BABYLON.Tools.Error("Error while accessing 'versions' object store (READ OP). Exception: " + h.message), b(-1) } } else BABYLON.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), b(-1) }, BABYLON.Database.prototype._saveVersionIntoDBAsync = function (a, b) { if (this.isSupported && !this.hasReachedQuota) { var c = this; try { var d = this.db.transaction(["versions"], "readwrite"); d.onabort = function (a) { try { "QuotaExceededError" === a.srcElement.error.name && (c.hasReachedQuota = !0) } catch (d) { } b(-1) }, d.oncomplete = function () { b(c.manifestVersionFound) }; var e = {}; e.sceneUrl = a, e.data = this.manifestVersionFound; var f = d.objectStore("versions").put(e); f.onsuccess = function () { }, f.onerror = function () { BABYLON.Tools.Error("Error in DB add version request in BABYLON.Database.") } } catch (g) { BABYLON.Tools.Error("Error while accessing 'versions' object store (WRITE OP). Exception: " + g.message), b(-1) } } else b(-1) }, BABYLON.Database.prototype.loadSceneFromDB = function (a, b, c, d) { var e = this, f = BABYLON.Database.ReturnFullUrlLocation(a), g = function () { e._saveSceneIntoDBAsync(f, b, c) }; this._checkVersionFromDB(f, function (a) { -1 !== a ? e.mustUpdateRessources ? e._saveSceneIntoDBAsync(f, b, c) : e._loadSceneFromDBAsync(f, b, g) : d() }) }, BABYLON.Database.prototype._loadSceneFromDBAsync = function (a, b, c) { if (this.isSupported) { var d, e = this.db.transaction(["scenes"]); e.oncomplete = function () { d ? b(d.data) : c() }, e.onabort = function () { c() }; var f = e.objectStore("scenes").get(a); f.onsuccess = function (a) { d = a.target.result }, f.onerror = function () { BABYLON.Tools.Error("Error loading scene " + a + " from DB."), c() } } else BABYLON.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), b() }, BABYLON.Database.prototype._saveSceneIntoDBAsync = function (a, b, c) { if (this.isSupported) { var d, e = new XMLHttpRequest, f = this; e.open("GET", a, !0), e.onprogress = c, e.addEventListener("load", function () { if (200 === e.status) if (d = e.responseText, f.hasReachedQuota) b(d); else { var c = f.db.transaction(["scenes"], "readwrite"); c.onabort = function (a) { try { "QuotaExceededError" === a.srcElement.error.name && (f.hasReachedQuota = !0) } catch (c) { } b(d) }, c.oncomplete = function () { b(d) }; var g = {}; g.sceneUrl = a, g.data = d, g.version = f.manifestVersionFound; try { var h = c.objectStore("scenes").put(g); h.onsuccess = function () { }, h.onerror = function () { BABYLON.Tools.Error("Error in DB add scene request in BABYLON.Database.") } } catch (i) { b(d) } } else b() }, !1), e.addEventListener("error", function () { BABYLON.Tools.Error("error on XHR request."), b() }, !1), e.send() } else BABYLON.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), b() } }(); var BABYLON; !function (a) { var b = function () { function b(b, c, d, e, f, g) { this.name = b, this.cellSize = e, this.sprites = new Array, this.renderingGroupId = 0, this._vertexDeclaration = [3, 4, 4, 4], this._vertexStrideSize = 60, this._capacity = d, this._spriteTexture = new a.Texture(c, f, !0, !1), this._spriteTexture.wrapU = a.Texture.CLAMP_ADDRESSMODE, this._spriteTexture.wrapV = a.Texture.CLAMP_ADDRESSMODE, this._epsilon = void 0 === g ? .01 : g, this._scene = f, this._scene.spriteManagers.push(this), this._vertexDeclaration = [3, 4, 4, 4], this._vertexStrideSize = 60, this._vertexBuffer = f.getEngine().createDynamicVertexBuffer(d * this._vertexStrideSize * 4); for (var h = [], i = 0, j = 0; d > j; j++) h.push(i), h.push(i + 1), h.push(i + 2), h.push(i), h.push(i + 2), h.push(i + 3), i += 4; this._indexBuffer = f.getEngine().createIndexBuffer(h), this._vertices = new Float32Array(d * this._vertexStrideSize), this._effectBase = this._scene.getEngine().createEffect("sprites", ["position", "options", "cellInfo", "color"], ["view", "projection", "textureInfos", "alphaTest"], ["diffuseSampler"], ""), this._effectFog = this._scene.getEngine().createEffect("sprites", ["position", "options", "cellInfo", "color"], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor"], ["diffuseSampler"], "#define FOG") } return b.prototype._appendSpriteVertex = function (a, b, c, d, e) { var f = 15 * a; 0 == c ? c = this._epsilon : 1 == c && (c = 1 - this._epsilon), 0 == d ? d = this._epsilon : 1 == d && (d = 1 - this._epsilon), this._vertices[f] = b.position.x, this._vertices[f + 1] = b.position.y, this._vertices[f + 2] = b.position.z, this._vertices[f + 3] = b.angle, this._vertices[f + 4] = b.size, this._vertices[f + 5] = c, this._vertices[f + 6] = d, this._vertices[f + 7] = b.invertU ? 1 : 0, this._vertices[f + 8] = b.invertV ? 1 : 0; var g = b.cellIndex / e >> 0; this._vertices[f + 9] = b.cellIndex - g * e, this._vertices[f + 10] = g, this._vertices[f + 11] = b.color.r, this._vertices[f + 12] = b.color.g, this._vertices[f + 13] = b.color.b, this._vertices[f + 14] = b.color.a }, b.prototype.render = function () { if (this._effectBase.isReady() && this._effectFog.isReady() && this._spriteTexture && this._spriteTexture.isReady()) { for (var b = this._scene.getEngine(), c = this._spriteTexture.getBaseSize(), d = a.Tools.GetDeltaTime(), e = Math.min(this._capacity, this.sprites.length), f = c.width / this.cellSize, g = 0, h = 0; e > h; h++) { var i = this.sprites[h]; i && (i._animate(d), this._appendSpriteVertex(g++, i, 0, 0, f), this._appendSpriteVertex(g++, i, 1, 0, f), this._appendSpriteVertex(g++, i, 1, 1, f), this._appendSpriteVertex(g++, i, 0, 1, f)) } b.updateDynamicVertexBuffer(this._vertexBuffer, this._vertices, e * this._vertexStrideSize); var j = this._effectBase; this._scene.fogMode !== a.Scene.FOGMODE_NONE && (j = this._effectFog), b.enableEffect(j); var k = this._scene.getViewMatrix(); j.setTexture("diffuseSampler", this._spriteTexture), j.setMatrix("view", k), j.setMatrix("projection", this._scene.getProjectionMatrix()), j.setFloat2("textureInfos", this.cellSize / c.width, this.cellSize / c.height), this._scene.fogMode !== a.Scene.FOGMODE_NONE && (j.setFloat4("vFogInfos", this._scene.fogMode, this._scene.fogStart, this._scene.fogEnd, this._scene.fogDensity), j.setColor3("vFogColor", this._scene.fogColor)), b.bindBuffers(this._vertexBuffer, this._indexBuffer, this._vertexDeclaration, this._vertexStrideSize, j), j.setBool("alphaTest", !0), b.setColorWrite(!1), b.draw(!0, 0, 6 * e), b.setColorWrite(!0), j.setBool("alphaTest", !1), b.setAlphaMode(a.Engine.ALPHA_COMBINE), b.draw(!0, 0, 6 * e), b.setAlphaMode(a.Engine.ALPHA_DISABLE) } }, b.prototype.dispose = function () { this._vertexBuffer && (this._scene.getEngine()._releaseBuffer(this._vertexBuffer), this._vertexBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this._spriteTexture && (this._spriteTexture.dispose(), this._spriteTexture = null); var a = this._scene.spriteManagers.indexOf(this); this._scene.spriteManagers.splice(a, 1), this.onDispose && this.onDispose() }, b }(); a.SpriteManager = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c) { this.name = b, this.color = new a.Color4(1, 1, 1, 1), this.size = 1, this.angle = 0, this.cellIndex = 0, this.invertU = 0, this.invertV = 0, this.animations = new Array, this._animationStarted = !1, this._loopAnimation = !1, this._fromIndex = 0, this._toIndex = 0, this._delay = 0, this._direction = 1, this._frameCount = 0, this._time = 0, this._manager = c, this._manager.sprites.push(this), this.position = a.Vector3.Zero() } return b.prototype.playAnimation = function (a, b, c, d) { this._fromIndex = a, this._toIndex = b, this._loopAnimation = c, this._delay = d, this._animationStarted = !0, this._direction = b > a ? 1 : -1, this.cellIndex = a, this._time = 0 }, b.prototype.stopAnimation = function () { this._animationStarted = !1 }, b.prototype._animate = function (a) { this._animationStarted && (this._time += a, this._time > this._delay && (this._time = this._time % this._delay, this.cellIndex += this._direction, this.cellIndex == this._toIndex && (this._loopAnimation ? this.cellIndex = this._fromIndex : (this._animationStarted = !1, this.disposeWhenFinishedAnimating && this.dispose())))) }, b.prototype.dispose = function () { for (var a = 0; a < this._manager.sprites.length; a++) this._manager.sprites[a] == this && this._manager.sprites.splice(a, 1) }, b }(); a.Sprite = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c, d, e, f) { this.name = b, this._vertexDeclaration = [2], this._vertexStrideSize = 8, this.texture = c ? new a.Texture(c, d, !0) : null, this.isBackground = void 0 === e ? !0 : e, this.color = void 0 === f ? new a.Color4(1, 1, 1, 1) : f, this._scene = d, this._scene.layers.push(this); var g = []; g.push(1, 1), g.push(-1, 1), g.push(-1, -1), g.push(1, -1), this._vertexBuffer = d.getEngine().createVertexBuffer(g); var h = []; h.push(0), h.push(1), h.push(2), h.push(0), h.push(2), h.push(3), this._indexBuffer = d.getEngine().createIndexBuffer(h), this._effect = this._scene.getEngine().createEffect("layer", ["position"], ["textureMatrix", "color"], ["textureSampler"], "") } return b.prototype.render = function () { if (this._effect.isReady() && this.texture && this.texture.isReady()) { var b = this._scene.getEngine(); b.enableEffect(this._effect), b.setState(!1), this._effect.setTexture("textureSampler", this.texture), this._effect.setMatrix("textureMatrix", this.texture._computeTextureMatrix()), this._effect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a), b.bindBuffers(this._vertexBuffer, this._indexBuffer, this._vertexDeclaration, this._vertexStrideSize, this._effect), b.setAlphaMode(a.Engine.ALPHA_COMBINE), b.draw(!0, 0, 6), b.setAlphaMode(a.Engine.ALPHA_DISABLE) } }, b.prototype.dispose = function () { this._vertexBuffer && (this._scene.getEngine()._releaseBuffer(this._vertexBuffer), this._vertexBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this.texture && (this.texture.dispose(), this.texture = null); var a = this._scene.layers.indexOf(this); this._scene.layers.splice(a, 1), this.onDispose && this.onDispose() }, b }(); a.Layer = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b() { this.position = a.Vector3.Zero(), this.direction = a.Vector3.Zero(), this.color = new a.Color4(0, 0, 0, 0), this.colorStep = new a.Color4(0, 0, 0, 0), this.lifeTime = 1, this.age = 0, this.size = 0, this.angle = 0, this.angularSpeed = 0 } return b }(); a.Particle = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function (a, b) { if (a == b) return a; var c = Math.random(); return c * (b - a) + a }, c = function () {
		function c(b, c, d) { this.name = b, this.renderingGroupId = 0, this.emitter = null, this.emitRate = 10, this.manualEmitCount = -1, this.updateSpeed = .01, this.targetStopDuration = 0, this.disposeOnStop = !1, this.minEmitPower = 1, this.maxEmitPower = 1, this.minLifeTime = 1, this.maxLifeTime = 1, this.minSize = 1, this.maxSize = 1, this.minAngularSpeed = 0, this.maxAngularSpeed = 0, this.blendMode = a.ParticleSystem.BLENDMODE_ONEONE, this.forceDepthWrite = !1, this.gravity = a.Vector3.Zero(), this.direction1 = new a.Vector3(0, 1, 0), this.direction2 = new a.Vector3(0, 1, 0), this.minEmitBox = new a.Vector3(-.5, -.5, -.5), this.maxEmitBox = new a.Vector3(.5, .5, .5), this.color1 = new a.Color4(1, 1, 1, 1), this.color2 = new a.Color4(1, 1, 1, 1), this.colorDead = new a.Color4(0, 0, 0, 1), this.textureMask = new a.Color4(1, 1, 1, 1), this.particles = new Array, this._vertexDeclaration = [3, 4, 4], this._vertexStrideSize = 44, this._stockParticles = new Array, this._newPartsExcess = 0, this._scaledColorStep = new a.Color4(0, 0, 0, 0), this._colorDiff = new a.Color4(0, 0, 0, 0), this._scaledDirection = a.Vector3.Zero(), this._scaledGravity = a.Vector3.Zero(), this._currentRenderId = -1, this._started = !0, this._stopped = !1, this._actualFrame = 0, this.id = b, this._capacity = c, this._scene = d, d.particleSystems.push(this), this._vertexBuffer = d.getEngine().createDynamicVertexBuffer(c * this._vertexStrideSize * 4); for (var e = [], f = 0, g = 0; c > g; g++) e.push(f), e.push(f + 1), e.push(f + 2), e.push(f), e.push(f + 2), e.push(f + 3), f += 4; this._indexBuffer = d.getEngine().createIndexBuffer(e), this._vertices = new Float32Array(c * this._vertexStrideSize) } return c.prototype.getCapacity = function () { return this._capacity }, c.prototype.isAlive = function () { return this._alive }, c.prototype.start = function () { this._started = !0, this._stopped = !1, this._actualFrame = 0 }, c.prototype.stop = function () { this._stopped = !0 }, c.prototype._appendParticleVertex = function (a, b, c, d) { var e = 11 * a; this._vertices[e] = b.position.x, this._vertices[e + 1] = b.position.y, this._vertices[e + 2] = b.position.z, this._vertices[e + 3] = b.color.r, this._vertices[e + 4] = b.color.g, this._vertices[e + 5] = b.color.b, this._vertices[e + 6] = b.color.a, this._vertices[e + 7] = b.angle, this._vertices[e + 8] = b.size, this._vertices[e + 9] = c, this._vertices[e + 10] = d }, c.prototype._update = function (c) {
			this._alive = this.particles.length > 0; for (var d = 0; d < this.particles.length; d++) {
				var e = this.particles[d]; e.age += this._scaledUpdateSpeed, e.age >= e.lifeTime ? (this._stockParticles.push(this.particles.splice(d, 1)[0]), d--) : (e.colorStep.scaleToRef(this._scaledUpdateSpeed, this._scaledColorStep), e.color.addInPlace(this._scaledColorStep), e.color.a < 0 && (e.color.a = 0), e.direction.scaleToRef(this._scaledUpdateSpeed, this._scaledDirection), e.position.addInPlace(this._scaledDirection), e.angle += e.angularSpeed * this._scaledUpdateSpeed, this.gravity.scaleToRef(this._scaledUpdateSpeed, this._scaledGravity), e.direction.addInPlace(this._scaledGravity))
			} var f; for (f = this.emitter.position ? this.emitter.getWorldMatrix() : a.Matrix.Translation(this.emitter.x, this.emitter.y, this.emitter.z), d = 0; c > d && this.particles.length != this._capacity; d++) { 0 !== this._stockParticles.length ? (e = this._stockParticles.pop(), e.age = 0) : e = new a.Particle, this.particles.push(e); var g = b(this.minEmitPower, this.maxEmitPower), h = b(this.direction1.x, this.direction2.x), i = b(this.direction1.y, this.direction2.y), j = b(this.direction1.z, this.direction2.z); a.Vector3.TransformNormalFromFloatsToRef(h * g, i * g, j * g, f, e.direction), e.lifeTime = b(this.minLifeTime, this.maxLifeTime), e.size = b(this.minSize, this.maxSize), e.angularSpeed = b(this.minAngularSpeed, this.maxAngularSpeed), h = b(this.minEmitBox.x, this.maxEmitBox.x), i = b(this.minEmitBox.y, this.maxEmitBox.y), j = b(this.minEmitBox.z, this.maxEmitBox.z), a.Vector3.TransformCoordinatesFromFloatsToRef(h, i, j, f, e.position); var k = b(0, 1); a.Color4.LerpToRef(this.color1, this.color2, k, e.color), this.colorDead.subtractToRef(e.color, this._colorDiff), this._colorDiff.scaleToRef(1 / e.lifeTime, e.colorStep) }
		}, c.prototype._getEffect = function () { var a = []; this._scene.clipPlane && a.push("#define CLIPPLANE"); var b = a.join("\n"); return this._cachedDefines != b && (this._cachedDefines = b, this._effect = this._scene.getEngine().createEffect("particles", ["position", "color", "options"], ["invView", "view", "projection", "vClipPlane", "textureMask"], ["diffuseSampler"], b)), this._effect }, c.prototype.animate = function () { if (this._started) { var a = this._getEffect(); if (this.emitter && a.isReady() && this.particleTexture && this.particleTexture.isReady() && this._currentRenderId !== this._scene.getRenderId()) { this._currentRenderId = this._scene.getRenderId(), this._scaledUpdateSpeed = this.updateSpeed * this._scene.getAnimationRatio(); var b; this.manualEmitCount > -1 ? (b = this.manualEmitCount, this.manualEmitCount = 0) : b = this.emitRate; var c = b * this._scaledUpdateSpeed >> 0; this._newPartsExcess += b * this._scaledUpdateSpeed - c, this._newPartsExcess > 1 && (c += this._newPartsExcess >> 0, this._newPartsExcess -= this._newPartsExcess >> 0), this._alive = !1, this._stopped ? c = 0 : (this._actualFrame += this._scaledUpdateSpeed, this.targetStopDuration && this._actualFrame >= this.targetStopDuration && this.stop()), this._update(c), this._stopped && (this._alive || (this._started = !1, this.disposeOnStop && this._scene._toBeDisposed.push(this))); for (var d = 0, e = 0; e < this.particles.length; e++) { var f = this.particles[e]; this._appendParticleVertex(d++, f, 0, 0), this._appendParticleVertex(d++, f, 1, 0), this._appendParticleVertex(d++, f, 1, 1), this._appendParticleVertex(d++, f, 0, 1) } var g = this._scene.getEngine(); g.updateDynamicVertexBuffer(this._vertexBuffer, this._vertices, this.particles.length * this._vertexStrideSize) } } }, c.prototype.render = function () { var b = this._getEffect(); if (!(this.emitter && b.isReady() && this.particleTexture && this.particleTexture.isReady() && this.particles.length)) return 0; var c = this._scene.getEngine(); c.enableEffect(b); var d = this._scene.getViewMatrix(); if (b.setTexture("diffuseSampler", this.particleTexture), b.setMatrix("view", d), b.setMatrix("projection", this._scene.getProjectionMatrix()), b.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a), this._scene.clipPlane) { var e = this._scene.clipPlane, f = d.clone(); f.invert(), b.setMatrix("invView", f), b.setFloat4("vClipPlane", e.normal.x, e.normal.y, e.normal.z, e.d) } return c.bindBuffers(this._vertexBuffer, this._indexBuffer, this._vertexDeclaration, this._vertexStrideSize, b), c.setAlphaMode(this.blendMode === a.ParticleSystem.BLENDMODE_ONEONE ? a.Engine.ALPHA_ADD : a.Engine.ALPHA_COMBINE), this.forceDepthWrite && c.setDepthWrite(!0), c.draw(!0, 0, 6 * this.particles.length), c.setAlphaMode(a.Engine.ALPHA_DISABLE), this.particles.length }, c.prototype.dispose = function () { this._vertexBuffer && (this._scene.getEngine()._releaseBuffer(this._vertexBuffer), this._vertexBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this.particleTexture && (this.particleTexture.dispose(), this.particleTexture = null); var a = this._scene.particleSystems.indexOf(this); this._scene.particleSystems.splice(a, 1), this.onDispose && this.onDispose() }, c.prototype.clone = function (b, c) { var d = new a.ParticleSystem(b, this._capacity, this._scene); return a.Tools.DeepCopy(this, d, ["particles"], ["_vertexDeclaration", "_vertexStrideSize"]), void 0 === c && (c = this.emitter), d.emitter = c, this.particleTexture && (d.particleTexture = new a.Texture(this.particleTexture.url, this._scene)), d.start(), d }, c.BLENDMODE_ONEONE = 0, c.BLENDMODE_STANDARD = 1, c
	}(); a.ParticleSystem = c
}(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a, c, d, e, f) { this.name = a, this.targetProperty = c, this.framePerSecond = d, this.dataType = e, this.loopMode = f, this._offsetsCache = {}, this._highLimitsCache = {}, this.targetPropertyPath = c.split("."), this.dataType = e, this.loopMode = void 0 === f ? b.ANIMATIONLOOPMODE_CYCLE : f } return b.prototype.getKeys = function () { return this._keys }, b.prototype.floatInterpolateFunction = function (a, b, c) { return a + (b - a) * c }, b.prototype.quaternionInterpolateFunction = function (b, c, d) { return a.Quaternion.Slerp(b, c, d) }, b.prototype.vector3InterpolateFunction = function (b, c, d) { return a.Vector3.Lerp(b, c, d) }, b.prototype.color3InterpolateFunction = function (b, c, d) { return a.Color3.Lerp(b, c, d) }, b.prototype.clone = function () { var a = new b(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode); return a.setKeys(this._keys), a }, b.prototype.setKeys = function (a) { this._keys = a.slice(0), this._offsetsCache = {}, this._highLimitsCache = {} }, b.prototype._interpolate = function (a, c, d, e, f) { if (d === b.ANIMATIONLOOPMODE_CONSTANT && c > 0) return f.clone ? f.clone() : f; this.currentFrame = a; for (var g = 0; g < this._keys.length; g++) if (this._keys[g + 1].frame >= a) { var h = this._keys[g].value, i = this._keys[g + 1].value, j = (a - this._keys[g].frame) / (this._keys[g + 1].frame - this._keys[g].frame); switch (this.dataType) { case b.ANIMATIONTYPE_FLOAT: switch (d) { case b.ANIMATIONLOOPMODE_CYCLE: case b.ANIMATIONLOOPMODE_CONSTANT: return this.floatInterpolateFunction(h, i, j); case b.ANIMATIONLOOPMODE_RELATIVE: return e * c + this.floatInterpolateFunction(h, i, j) } break; case b.ANIMATIONTYPE_QUATERNION: var k = null; switch (d) { case b.ANIMATIONLOOPMODE_CYCLE: case b.ANIMATIONLOOPMODE_CONSTANT: k = this.quaternionInterpolateFunction(h, i, j); break; case b.ANIMATIONLOOPMODE_RELATIVE: k = this.quaternionInterpolateFunction(h, i, j).add(e.scale(c)) } return k; case b.ANIMATIONTYPE_VECTOR3: switch (d) { case b.ANIMATIONLOOPMODE_CYCLE: case b.ANIMATIONLOOPMODE_CONSTANT: return this.vector3InterpolateFunction(h, i, j); case b.ANIMATIONLOOPMODE_RELATIVE: return this.vector3InterpolateFunction(h, i, j).add(e.scale(c)) } case b.ANIMATIONTYPE_COLOR3: switch (d) { case b.ANIMATIONLOOPMODE_CYCLE: case b.ANIMATIONLOOPMODE_CONSTANT: return this.color3InterpolateFunction(h, i, j); case b.ANIMATIONLOOPMODE_RELATIVE: return this.color3InterpolateFunction(h, i, j).add(e.scale(c)) } case b.ANIMATIONTYPE_MATRIX: switch (d) { case b.ANIMATIONLOOPMODE_CYCLE: case b.ANIMATIONLOOPMODE_CONSTANT: case b.ANIMATIONLOOPMODE_RELATIVE: return h } } break } return this._keys[this._keys.length - 1].value }, b.prototype.animate = function (a, c, d, e, f, g) { if (!this.targetPropertyPath || this.targetPropertyPath.length < 1) return !1; var h = !0; if (0 != this._keys[0].frame) { var i = { frame: 0, value: this._keys[0].value }; this._keys.splice(0, 0, i) } (d < this._keys[0].frame || d > this._keys[this._keys.length - 1].frame) && (d = this._keys[0].frame), (e < this._keys[0].frame || e > this._keys[this._keys.length - 1].frame) && (e = this._keys[this._keys.length - 1].frame); var j = e - d, k = c * this.framePerSecond * g / 1e3; if (k > j && !f) l = 0, h = !1, m = this._keys[this._keys.length - 1].value; else { var l = 0, m = 0; if (this.loopMode != b.ANIMATIONLOOPMODE_CYCLE) { var n = e.toString() + d.toString(); if (!this._offsetsCache[n]) { var o = this._interpolate(d, 0, b.ANIMATIONLOOPMODE_CYCLE), p = this._interpolate(e, 0, b.ANIMATIONLOOPMODE_CYCLE); switch (this.dataType) { case b.ANIMATIONTYPE_FLOAT: this._offsetsCache[n] = p - o; break; case b.ANIMATIONTYPE_QUATERNION: this._offsetsCache[n] = p.subtract(o); break; case b.ANIMATIONTYPE_VECTOR3: this._offsetsCache[n] = p.subtract(o); case b.ANIMATIONTYPE_COLOR3: this._offsetsCache[n] = p.subtract(o) } this._highLimitsCache[n] = p } m = this._highLimitsCache[n], l = this._offsetsCache[n] } } var q = k / j >> 0, r = h ? d + k % j : e, s = this._interpolate(r, q, this.loopMode, l, m); if (this.targetPropertyPath.length > 1) { for (var t = a[this.targetPropertyPath[0]], u = 1; u < this.targetPropertyPath.length - 1; u++) t = t[this.targetPropertyPath[u]]; t[this.targetPropertyPath[this.targetPropertyPath.length - 1]] = s } else a[this.targetPropertyPath[0]] = s; return a.markAsDirty && a.markAsDirty(this.targetProperty), h }, Object.defineProperty(b, "ANIMATIONTYPE_FLOAT", { get: function () { return b._ANIMATIONTYPE_FLOAT }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONTYPE_VECTOR3", { get: function () { return b._ANIMATIONTYPE_VECTOR3 }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONTYPE_QUATERNION", { get: function () { return b._ANIMATIONTYPE_QUATERNION }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONTYPE_MATRIX", { get: function () { return b._ANIMATIONTYPE_MATRIX }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONTYPE_COLOR3", { get: function () { return b._ANIMATIONTYPE_COLOR3 }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONLOOPMODE_RELATIVE", { get: function () { return b._ANIMATIONLOOPMODE_RELATIVE }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONLOOPMODE_CYCLE", { get: function () { return b._ANIMATIONLOOPMODE_CYCLE }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "ANIMATIONLOOPMODE_CONSTANT", { get: function () { return b._ANIMATIONLOOPMODE_CONSTANT }, enumerable: !0, configurable: !0 }), b._ANIMATIONTYPE_FLOAT = 0, b._ANIMATIONTYPE_VECTOR3 = 1, b._ANIMATIONTYPE_QUATERNION = 2, b._ANIMATIONTYPE_MATRIX = 3, b._ANIMATIONTYPE_COLOR3 = 4, b._ANIMATIONLOOPMODE_RELATIVE = 0, b._ANIMATIONLOOPMODE_CYCLE = 1, b._ANIMATIONLOOPMODE_CONSTANT = 2, b }(); a.Animation = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { !function (a) { var b = function () { function a(a, b, c, d, e, f, g) { "undefined" == typeof b && (b = 0), "undefined" == typeof c && (c = 100), "undefined" == typeof d && (d = !1), "undefined" == typeof e && (e = 1), this.target = a, this.fromFrame = b, this.toFrame = c, this.loopAnimation = d, this.speedRatio = e, this.onAnimationEnd = f, this.animationStarted = !1, this._animations = g } return a.prototype._animate = function (a) { this._localDelayOffset || (this._localDelayOffset = a); for (var b = !1, c = this._animations || this.target.animations, d = 0; d < c.length; d++) { var e = c[d].animate(this.target, a - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this.speedRatio); b = b || e } return !b && this.onAnimationEnd && this.onAnimationEnd(), b }, a }(); a.Animatable = b }(a.Internals || (a.Internals = {})); a.Internals }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b) { this._maxBlockCapacity = b || 64, this._selection = new a.SmartArray(256) } return b.prototype.update = function (a, c, d) { b._CreateBlocks(a, c, d, this._maxBlockCapacity, this) }, b.prototype.addMesh = function (a) { for (var b = 0; b < this.blocks.length; b++) { var c = this.blocks[b]; c.addMesh(a) } }, b.prototype.select = function (a) { this._selection.reset(); for (var b = 0; b < this.blocks.length; b++) { var c = this.blocks[b]; c.select(a, this._selection) } return this._selection }, b._CreateBlocks = function (b, c, d, e, f) { f.blocks = []; for (var g = new a.Vector3((c.x - b.x) / 2, (c.y - b.y) / 2, (c.z - b.z) / 2), h = 0; 2 > h; h++) for (var i = 0; 2 > i; i++) for (var j = 0; 2 > j; j++) { var k = b.add(g.multiplyByFloats(h, i, j)), l = b.add(g.multiplyByFloats(h + 1, i + 1, j + 1)), m = new a.OctreeBlock(k, l, e); m.addEntries(d), f.blocks.push(m) } }, b }(); a.Octree = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a, b, c) { this.meshes = new Array, this.subMeshes = new Array, this._boundingVectors = new Array, this._capacity = c, this._minPoint = a, this._maxPoint = b, this._boundingVectors.push(a.clone()), this._boundingVectors.push(b.clone()), this._boundingVectors.push(a.clone()), this._boundingVectors[2].x = b.x, this._boundingVectors.push(a.clone()), this._boundingVectors[3].y = b.y, this._boundingVectors.push(a.clone()), this._boundingVectors[4].z = b.z, this._boundingVectors.push(b.clone()), this._boundingVectors[5].z = a.z, this._boundingVectors.push(b.clone()), this._boundingVectors[6].x = a.x, this._boundingVectors.push(b.clone()), this._boundingVectors[7].y = a.y } return b.prototype.addMesh = function (b) { if (this.blocks) for (var c = 0; c < this.blocks.length; c++) { var d = this.blocks[c]; d.addMesh(b) } else { if (b.getBoundingInfo().boundingBox.intersectsMinMax(this._minPoint, this._maxPoint)) { var e = this.meshes.length; if (this.meshes.push(b), this.subMeshes[e] = [], b.subMeshes) for (var f = 0; f < b.subMeshes.length; f++) { var g = b.subMeshes[f]; (1 === b.subMeshes.length || g.getBoundingInfo().boundingBox.intersectsMinMax(this._minPoint, this._maxPoint)) && this.subMeshes[e].push(g) } } this.subMeshes.length > this._capacity && a.Octree._CreateBlocks(this._minPoint, this._maxPoint, this.meshes, this._capacity, this) } }, b.prototype.addEntries = function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; this.addMesh(c) } }, b.prototype.select = function (b, c) { if (this.blocks) for (var d = 0; d < this.blocks.length; d++) { var e = this.blocks[d]; e.select(b, c) } else a.BoundingBox.IsInFrustum(this._boundingVectors, b) && c.push(this) }, b }(); a.OctreeBlock = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c, d, e) { this.name = b, this.children = new Array, this.animations = new Array, this._worldTransform = new a.Matrix, this._absoluteTransform = new a.Matrix, this._invertedAbsoluteTransform = new a.Matrix, this._skeleton = c, this._matrix = e, this._baseMatrix = e, c.bones.push(this), d ? (this._parent = d, d.children.push(this)) : this._parent = null, this._updateDifferenceMatrix() } return b.prototype.getParent = function () { return this._parent }, b.prototype.getLocalMatrix = function () { return this._matrix }, b.prototype.getBaseMatrix = function () { return this._baseMatrix }, b.prototype.getWorldMatrix = function () { return this._worldTransform }, b.prototype.getInvertedAbsoluteTransform = function () { return this._invertedAbsoluteTransform }, b.prototype.getAbsoluteMatrix = function () { for (var a = this._matrix.clone(), b = this._parent; b;) a = a.multiply(b.getLocalMatrix()), b = b.getParent(); return a }, b.prototype.updateMatrix = function (a) { this._matrix = a, this._skeleton._markAsDirty(), this._updateDifferenceMatrix() }, b.prototype._updateDifferenceMatrix = function () { this._parent ? this._matrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform) : this._absoluteTransform.copyFrom(this._matrix), this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform); for (var a = 0; a < this.children.length; a++) this.children[a]._updateDifferenceMatrix() }, b.prototype.markAsDirty = function () { this._skeleton._markAsDirty() }, b }(); a.Bone = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a, b, c) { this.name = a, this.id = b, this.bones = new Array, this._isDirty = !0, this.bones = [], this._scene = c, c.skeletons.push(this) } return b.prototype.getTransformMatrices = function () { return this._transformMatrices }, b.prototype._markAsDirty = function () { this._isDirty = !0 }, b.prototype.prepare = function () { if (this._isDirty) { this._transformMatrices && this._transformMatrices.length === 16 * this.bones.length || (this._transformMatrices = new Float32Array(16 * this.bones.length)); for (var a = 0; a < this.bones.length; a++) { var b = this.bones[a], c = b.getParent(); c ? b.getLocalMatrix().multiplyToRef(c.getWorldMatrix(), b.getWorldMatrix()) : b.getWorldMatrix().copyFrom(b.getLocalMatrix()), b.getInvertedAbsoluteTransform().multiplyToArray(b.getWorldMatrix(), this._transformMatrices, 16 * a) } this._isDirty = !1 } }, b.prototype.getAnimatables = function () { if (!this._animatables || this._animatables.length != this.bones.length) { this._animatables = []; for (var a = 0; a < this.bones.length; a++) this._animatables.push(this.bones[a]) } return this._animatables }, b.prototype.clone = function (b, c) { for (var d = new a.Skeleton(b, c || b, this._scene), e = 0; e < this.bones.length; e++) { var f = this.bones[e], g = null; if (f.getParent()) { var h = this.bones.indexOf(f.getParent()); g = d.bones[h] } var i = new a.Bone(f.name, d, g, f.getBaseMatrix()); a.Tools.DeepCopy(f.animations, i.animations) } return d }, b }(); a.Skeleton = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c, d, e, f, g, h, i, j) { this.name = b, this.width = -1, this.height = -1, this._reusable = !1, this._textures = new a.SmartArray(2), this._currentRenderTextureInd = 0, null != g ? (this._camera = g, this._scene = g.getScene(), g.attachPostProcess(this), this._engine = this._scene.getEngine()) : this._engine = i, this._renderRatio = f, this.renderTargetSamplingMode = h ? h : a.Texture.NEAREST_SAMPLINGMODE, this._reusable = j || !1, e = e || [], e.push("textureSampler"), this._effect = this._engine.createEffect({ vertex: "postprocess", fragment: c }, ["position"], d || [], e, "") } return b.prototype.isReusable = function () { return this._reusable }, b.prototype.activate = function (a) { a = a || this._camera; var b = a.getScene(), c = this._engine.getRenderingCanvas().width * this._renderRatio, d = this._engine.getRenderingCanvas().height * this._renderRatio; if (this.width !== c || this.height !== d) { if (this._textures.length > 0) { for (var e = 0; e < this._textures.length; e++) this._engine._releaseTexture(this._textures.data[e]); this._textures.reset() } this.width = c, this.height = d, this._textures.push(this._engine.createRenderTargetTexture({ width: this.width, height: this.height }, { generateMipMaps: !1, generateDepthBuffer: a._postProcesses.indexOf(this) === a._postProcessesTakenIndices[0], samplingMode: this.renderTargetSamplingMode })), this._reusable && this._textures.push(this._engine.createRenderTargetTexture({ width: this.width, height: this.height }, { generateMipMaps: !1, generateDepthBuffer: a._postProcesses.indexOf(this) === a._postProcessesTakenIndices[0], samplingMode: this.renderTargetSamplingMode })), this.onSizeChanged && this.onSizeChanged() } this._engine.bindFramebuffer(this._textures.data[this._currentRenderTextureInd]), this.onActivate && this.onActivate(a), this._engine.clear(b.clearColor, b.autoClear || b.forceWireframe, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2) }, b.prototype.apply = function () { return this._effect.isReady() ? (this._engine.enableEffect(this._effect), this._engine.setState(!1), this._engine.setAlphaMode(a.Engine.ALPHA_DISABLE), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._effect._bindTexture("textureSampler", this._textures.data[this._currentRenderTextureInd]), this.onApply && this.onApply(this._effect), this._effect) : null }, b.prototype.dispose = function (a) { if (a = a || this._camera, this._textures.length > 0) { for (var b = 0; b < this._textures.length; b++) this._engine._releaseTexture(this._textures.data[b]); this._textures.reset() } a.detachPostProcess(this); var c = a._postProcesses.indexOf(this); c === a._postProcessesTakenIndices[0] && a._postProcessesTakenIndices.length > 0 && (this._camera._postProcesses[a._postProcessesTakenIndices[0]].width = -1) }, b }(); a.PostProcess = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function a(a) { this._vertexDeclaration = [2], this._vertexStrideSize = 8, this._scene = a; var b = []; b.push(1, 1), b.push(-1, 1), b.push(-1, -1), b.push(1, -1), this._vertexBuffer = a.getEngine().createVertexBuffer(b); var c = []; c.push(0), c.push(1), c.push(2), c.push(0), c.push(2), c.push(3), this._indexBuffer = a.getEngine().createIndexBuffer(c) } return a.prototype._prepareFrame = function () { var a = this._scene.activeCamera._postProcesses, b = this._scene.activeCamera._postProcessesTakenIndices; 0 !== b.length && this._scene.postProcessesEnabled && a[this._scene.activeCamera._postProcessesTakenIndices[0]].activate(this._scene.activeCamera) }, a.prototype._finalizeFrame = function (a) { var b = this._scene.activeCamera._postProcesses, c = this._scene.activeCamera._postProcessesTakenIndices; if (0 !== c.length && this._scene.postProcessesEnabled) { for (var d = this._scene.getEngine(), e = 0; e < c.length && (e < c.length - 1 ? b[c[e + 1]].activate(this._scene.activeCamera) : d.restoreDefaultFramebuffer(), !a) ; e++) { var f = b[c[e]].apply(); f && (d.bindBuffers(this._vertexBuffer, this._indexBuffer, this._vertexDeclaration, this._vertexStrideSize, f), d.draw(!0, 0, 6)) } d.setDepthBuffer(!0), d.setDepthWrite(!0) } }, a.prototype.dispose = function () { this._vertexBuffer && (this._scene.getEngine()._releaseBuffer(this._vertexBuffer), this._vertexBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null) }, a }(); a.PostProcessManager = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g) { a.call(this, b, "pass", null, null, c, d, e, f, g) } return __extends(b, a), b }(a.PostProcess); a.PassPostProcess = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f, g, h, i, j) { "undefined" == typeof h && (h = a.Texture.BILINEAR_SAMPLINGMODE); var k = this; b.call(this, c, "blur", ["screenSize", "direction", "blurWidth"], null, f, g, h, i, j), this.direction = d, this.blurWidth = e, this.onApply = function (a) { a.setFloat2("screenSize", k.width, k.height), a.setVector2("direction", k.direction), a.setFloat("blurWidth", k.blurWidth) } } return __extends(c, b), c }(a.PostProcess); a.BlurPostProcess = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g, h) { var i = this; a.call(this, b, "filter", ["kernelMatrix"], null, d, e, f, g, h), this.kernelMatrix = c, this.onApply = function (a) { a.setMatrix("kernelMatrix", i.kernelMatrix) } } return __extends(b, a), b }(a.PostProcess); a.FilterPostProcess = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f, g, h, i, j, k, l) { var m = this; b.call(this, c, "refraction", ["baseColor", "depth", "colorLevel"], ["refractionSampler"], h, i, j, k, l), this.color = e, this.depth = f, this.colorLevel = g, this.onActivate = function (b) { m._refRexture = m._refRexture || new a.Texture(d, b.getScene()) }, this.onApply = function (a) { a.setColor3("baseColor", m.color), a.setFloat("depth", m.depth), a.setFloat("colorLevel", m.colorLevel), a.setTexture("refractionSampler", m._refRexture) } } return __extends(c, b), c.prototype.dispose = function (a) { this._refRexture && this._refRexture.dispose(), b.prototype.dispose.call(this, a) }, c }(a.PostProcess); a.RefractionPostProcess = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g) { a.call(this, b, "blackAndWhite", null, null, c, d, e, f, g) } return __extends(b, a), b }(a.PostProcess); a.BlackAndWhitePostProcess = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g, h) { var i = this; a.call(this, b, "convolution", ["kernel", "screenSize"], null, d, e, f, g, h), this.kernel = c, this.onApply = function (a) { a.setFloat2("screenSize", i.width, i.height), a.setArray("kernel", i.kernel) } } return __extends(b, a), b.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1], b.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0], b.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1], b.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0], b.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2], b.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0], b }(a.PostProcess); a.ConvolutionPostProcess = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g) { var h = this; a.call(this, b, "fxaa", ["texelSize"], null, c, d, e, f, g), this.onSizeChanged = function () { h.texelWidth = 1 / h.width, h.texelHeight = 1 / h.height }, this.onApply = function (a) { a.setFloat2("texelSize", h.texelWidth, h.texelHeight) } } return __extends(b, a), b }(a.PostProcess); a.FxaaPostProcess = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c, d, e, f) { this.size = b, this.position = c, this.dispose = function () { this.texture && this.texture.dispose(); var a = this._system.lensFlares.indexOf(this); this._system.lensFlares.splice(a, 1) }, this.color = d || new a.Color3(1, 1, 1), this.texture = e ? new a.Texture(e, f.getScene(), !0) : null, this._system = f, f.lensFlares.push(this) } return b }(); a.LensFlare = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a, b, c) { this.name = a, this.lensFlares = new Array, this.borderLimit = 300, this._vertexDeclaration = [2], this._vertexStrideSize = 8, this._scene = c, this._emitter = b, c.lensFlareSystems.push(this), this.meshesSelectionPredicate = function (a) { return a.material && a.isVisible && a.isEnabled() && a.checkCollisions }; var d = []; d.push(1, 1), d.push(-1, 1), d.push(-1, -1), d.push(1, -1), this._vertexBuffer = c.getEngine().createVertexBuffer(d); var e = []; e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = c.getEngine().createIndexBuffer(e), this._effect = this._scene.getEngine().createEffect("lensFlare", ["position"], ["color", "viewportMatrix"], ["textureSampler"], "") } return b.prototype.getScene = function () { return this._scene }, b.prototype.getEmitter = function () { return this._emitter }, b.prototype.getEmitterPosition = function () { return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position }, b.prototype.computeEffectivePosition = function (b) { var c = this.getEmitterPosition(); return c = a.Vector3.Project(c, a.Matrix.Identity(), this._scene.getTransformMatrix(), b), this._positionX = c.x, this._positionY = c.y, c = a.Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix()), c.z > 0 && this._positionX > b.x && this._positionX < b.x + b.width && this._positionY > b.y && this._positionY < b.y + b.height ? !0 : !1 }, b.prototype._isVisible = function () { var b = this.getEmitterPosition(), c = b.subtract(this._scene.activeCamera.position), d = c.length(); c.normalize(); var e = new a.Ray(this._scene.activeCamera.position, c), f = this._scene.pickWithRay(e, this.meshesSelectionPredicate, !0); return !f.hit || f.distance > d }, b.prototype.render = function () { if (!this._effect.isReady()) return !1; var b = this._scene.getEngine(), c = this._scene.activeCamera.viewport, d = c.toGlobal(b); if (!this.computeEffectivePosition(d)) return !1; if (!this._isVisible()) return !1; var e, f; e = this._positionX < this.borderLimit + d.x ? this.borderLimit + d.x - this._positionX : this._positionX > d.x + d.width - this.borderLimit ? this._positionX - d.x - d.width + this.borderLimit : 0, f = this._positionY < this.borderLimit + d.y ? this.borderLimit + d.y - this._positionY : this._positionY > d.y + d.height - this.borderLimit ? this._positionY - d.y - d.height + this.borderLimit : 0; var g = e > f ? e : f; g > this.borderLimit && (g = this.borderLimit); var h = 1 - g / this.borderLimit; if (0 > h) return !1; h > 1 && (h = 1); var i = d.x + d.width / 2, j = d.y + d.height / 2, k = i - this._positionX, l = j - this._positionY; b.enableEffect(this._effect), b.setState(!1), b.setDepthBuffer(!1), b.setAlphaMode(a.Engine.ALPHA_ADD), b.bindBuffers(this._vertexBuffer, this._indexBuffer, this._vertexDeclaration, this._vertexStrideSize, this._effect); for (var m = 0; m < this.lensFlares.length; m++) { var n = this.lensFlares[m], o = i - k * n.position, p = j - l * n.position, q = n.size, r = n.size * b.getAspectRatio(this._scene.activeCamera), s = 2 * (o / d.width) - 1, t = 1 - 2 * (p / d.height), u = a.Matrix.FromValues(q / 2, 0, 0, 0, 0, r / 2, 0, 0, 0, 0, 1, 0, s, t, 0, 1); this._effect.setMatrix("viewportMatrix", u), this._effect.setTexture("textureSampler", n.texture), this._effect.setFloat4("color", n.color.r * h, n.color.g * h, n.color.b * h, 1), b.draw(!0, 0, 6) } return b.setDepthBuffer(!0), b.setAlphaMode(a.Engine.ALPHA_DISABLE), !0 }, b.prototype.dispose = function () { for (this._vertexBuffer && (this._scene.getEngine()._releaseBuffer(this._vertexBuffer), this._vertexBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null) ; this.lensFlares.length;) this.lensFlares[0].dispose(); var a = this._scene.lensFlareSystems.indexOf(this); this._scene.lensFlareSystems.splice(a, 1) }, b }(); a.LensFlareSystem = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function a(a, b, c) { this.bu = a, this.bv = b, this.distance = c, this.faceId = 0 } return a }(); a.IntersectionInfo = b; var c = function () { function b() { this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1 } return b.prototype.getNormal = function () { if (!this.pickedMesh) return null; var b = this.pickedMesh.getIndices(), c = this.pickedMesh.getVerticesData(a.VertexBuffer.NormalKind), d = a.Vector3.FromArray(c, 3 * b[3 * this.faceId]), e = a.Vector3.FromArray(c, 3 * b[3 * this.faceId + 1]), f = a.Vector3.FromArray(c, 3 * b[3 * this.faceId + 2]); return d = d.scale(this.bu), e = e.scale(this.bv), f = f.scale(1 - this.bu - this.bv), new a.Vector3(d.x + e.x + f.x, d.y + e.y + f.y, d.z + e.z + f.z) }, b }(); a.PickingInfo = c }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { function a() { if (d.additionnalRenderLoopLogicCallback && d.additionnalRenderLoopLogicCallback(), d.currentScene) { if (d.textureLoadingCallback) { var a = d.currentScene.getWaitingItemsCount(); a > 0 && d.textureLoadingCallback(a) } d.currentScene.render() } } function b(a) { a.stopPropagation(), a.preventDefault() } function c(a) { a.stopPropagation(), a.preventDefault(), d.loadFiles(a) } var d; BABYLON.FilesInput = function (a, b, c, e, f, g, h, i) { d = this, this.engine = a, this.canvas = c, this.currentScene = b, this.sceneLoadedCallback = e, this.progressCallback = f, this.additionnalRenderLoopLogicCallback = g, this.textureLoadingCallback = h, this.startingProcessingFilesCallback = i }, BABYLON.FilesInput.prototype.monitorElementForDragNDrop = function (a) { a && (this.elementToMonitor = a, this.elementToMonitor.addEventListener("dragenter", b, !1), this.elementToMonitor.addEventListener("dragover", b, !1), this.elementToMonitor.addEventListener("drop", c, !1)) }, BABYLON.FilesInput.prototype.loadFiles = function (b) { d.startingProcessingFilesCallback && d.startingProcessingFilesCallback(); var c, e; if (BABYLON.FilesTextures = {}, b && b.dataTransfer && b.dataTransfer.files && (e = b.dataTransfer.files), b && b.target && b.target.files && (e = b.target.files), e && e.length > 0) { for (var f = 0; f < e.length; f++) -1 !== e[f].name.indexOf(".babylon") && -1 === e[f].name.indexOf(".manifest") && -1 === e[f].name.indexOf(".incremental") && -1 === e[f].name.indexOf(".babylonmeshdata") && -1 === e[f].name.indexOf(".babylongeometrydata") ? c = e[f] : (0 == e[f].type.indexOf("image/jpeg") || 0 == e[f].type.indexOf("image/png")) && (BABYLON.FilesTextures[e[f].name] = e[f]); c ? (d.currentScene && (d.engine.stopRenderLoop(), d.currentScene.dispose()), BABYLON.SceneLoader.Load("file:", c, d.engine, function (b) { d.currentScene = b, d.currentScene.executeWhenReady(function () { d.currentScene.activeCamera && d.currentScene.activeCamera.attachControl(d.canvas), d.sceneLoadedCallback && d.sceneLoadedCallback(c, d.currentScene), d.engine.runRenderLoop(a) }) }, function (a) { d.progressCallback && d.progressCallback(a) })) : BABYLON.Tools.Error("Please provide a valid .babylon file.") } } }(); var BABYLON; !function (a) { var b = function () { function b(b) { this._currentPlugin = b || new a.CannonJSPlugin } return b.prototype._initialize = function (a) { this._currentPlugin.initialize(), this._setGravity(a) }, b.prototype._runOneStep = function (a) { a > .1 ? a = .1 : 0 >= a && (a = 1 / 60), this._currentPlugin.runOneStep(a) }, b.prototype._setGravity = function (b) { this.gravity = b || new a.Vector3(0, -9.82, 0), this._currentPlugin.setGravity(this.gravity) }, b.prototype._registerMesh = function (a, b, c) { return this._currentPlugin.registerMesh(a, b, c) }, b.prototype._registerMeshesAsCompound = function (a, b) { return this._currentPlugin.registerMeshesAsCompound(a, b) }, b.prototype._unregisterMesh = function (a) { this._currentPlugin.unregisterMesh(a) }, b.prototype._applyImpulse = function (a, b, c) { this._currentPlugin.applyImpulse(a, b, c) }, b.prototype._createLink = function (a, b, c, d) { return this._currentPlugin.createLink(a, b, c, d) }, b.prototype.dispose = function () { this._currentPlugin.dispose() }, b.prototype.isSupported = function () { return this._currentPlugin.isSupported() }, b.NoImpostor = 0, b.SphereImpostor = 1, b.BoxImpostor = 2, b.PlaneImpostor = 3, b.CompoundImpostor = 4, b.MeshImpostor = 4, b.Epsilon = .001, b }(); a.PhysicsEngine = b }(BABYLON || (BABYLON = {}));
var BABYLON; !function (a) { var b = function (b) { var c = {}; if (c.name = b.name, c.id = b.id, c.tags = a.Tags.GetTags(b), b instanceof a.PointLight) c.type = 0, c.position = b.position.asArray(); else if (b instanceof a.DirectionalLight) { c.type = 1; var d = b; c.position = d.position.asArray(), c.direction = d.direction.asArray() } else if (b instanceof a.SpotLight) { c.type = 2; var e = b; c.position = e.position.asArray(), c.direction = e.position.asArray(), c.angle = e.angle, c.exponent = e.exponent } else b instanceof a.HemisphericLight && (c.type = 2, c.groundColor = b.groundColor.asArray()); return b.intensity && (c.intensity = b.intensity), c.range = b.range, c.diffuse = b.diffuse.asArray(), c.specular = b.specular.asArray(), c }, c = function (b) { var c = {}; return c.name = b.name, c.tags = a.Tags.GetTags(b), c.id = b.id, c.position = b.position.asArray(), b.parent && (c.parentId = b.parent.id), c.rotation = b.rotation.asArray(), b.lockedTarget && b.lockedTarget.id && (c.lockedTargetId = b.lockedTarget.id), c.fov = b.fov, c.minZ = b.minZ, c.maxZ = b.maxZ, c.speed = b.speed, c.inertia = b.inertia, c.checkCollisions = b.checkCollisions, c.applyGravity = b.applyGravity, b.ellipsoid && (c.ellipsoid = b.ellipsoid.asArray()), d(b, c), c }, d = function (a, b) { if (a.animations) { b.animations = []; for (var c = 0; c < a.animations.length; c++) { var d = a.animations[c]; b.animations.push(e(d)) } } }, e = function (b) { var c = {}; c.name = b.name, c.property = b.targetProperty, c.framePerSecond = b.framePerSecond, c.dataType = b.dataType, c.loopBehavior = b.loopMode; var d = b.dataType; c.keys = []; for (var e = b.getKeys(), f = 0; f < e.length; f++) { var g = e[f], h = {}; switch (h.frame = g.frame, d) { case a.Animation.ANIMATIONTYPE_FLOAT: h.values = [g.value]; break; case a.Animation.ANIMATIONTYPE_QUATERNION: case a.Animation.ANIMATIONTYPE_MATRIX: case a.Animation.ANIMATIONTYPE_VECTOR3: h.values = g.value.asArray() } c.keys.push(h) } return c }, f = function (b) { var c = {}; c.name = b.name, c.id = b.id, c.tags = a.Tags.GetTags(b), c.materials = []; for (var d = 0; d < b.subMaterials.length; d++) { var e = b.subMaterials[d]; c.materials.push(e ? e.id : null) } return c }, g = function (b) { var c = {}; return c.name = b.name, c.ambient = b.ambientColor.asArray(), c.diffuse = b.diffuseColor.asArray(), c.specular = b.specularColor.asArray(), c.specularPower = b.specularPower, c.emissive = b.emissiveColor.asArray(), c.alpha = b.alpha, c.id = b.id, c.tags = a.Tags.GetTags(b), c.backFaceCulling = b.backFaceCulling, b.diffuseTexture && (c.diffuseTexture = h(b.diffuseTexture)), b.ambientTexture && (c.ambientTexture = h(b.ambientTexture)), b.opacityTexture && (c.opacityTexture = h(b.opacityTexture)), b.reflectionTexture && (c.reflectionTexture = h(b.reflectionTexture)), b.emissiveTexture && (c.emissiveTexture = h(b.emissiveTexture)), b.specularTexture && (c.specularTexture = h(b.specularTexture)), b.bumpTexture && (c.bumpTexture = h(b.bumpTexture)), c }, h = function (b) { var c = {}; if (!b.name) return null; if (b instanceof a.CubeTexture) return c.name = b.name, c.hasAlpha = b.hasAlpha, c.level = b.level, c.coordinatesMode = b.coordinatesMode, c; if (b instanceof a.MirrorTexture) { var e = b; c.renderTargetSize = e.getRenderSize(), c.renderList = []; for (var f = 0; f < e.renderList.length; f++) c.renderList.push(e.renderList[f].id); c.mirrorPlane = e.mirrorPlane.asArray() } else if (b instanceof a.RenderTargetTexture) { var g = b; for (c.renderTargetSize = g.getRenderSize(), c.renderList = [], f = 0; f < g.renderList.length; f++) c.renderList.push(g.renderList[f].id) } return c.name = b.name, c.hasAlpha = b.hasAlpha, c.level = b.level, c.coordinatesIndex = b.coordinatesIndex, c.coordinatesMode = b.coordinatesMode, c.uOffset = b.uOffset, c.vOffset = b.vOffset, c.uScale = b.uScale, c.vScale = b.vScale, c.uAng = b.uAng, c.vAng = b.vAng, c.wAng = b.wAng, c.wrapU = b.wrapU, c.wrapV = b.wrapV, d(b, c), c }, i = function (a) { var b = {}; b.name = a.name, b.id = a.id, b.bones = []; for (var c = 0; c < a.bones.length; c++) { var d = a.bones[c], f = { parentBoneIndex: d.getParent() ? a.bones.indexOf(d.getParent()) : -1, name: d.name, matrix: d.getLocalMatrix().toArray() }; b.bones.push(f), d.animations && d.animations.length > 0 && (f.animation = e(d.animations[0])) } return b }, j = function (a) { var b = {}; return b.emitterId = a.emitter.id, b.capacity = a.getCapacity(), a.particleTexture && (b.textureName = a.particleTexture.name), b.minAngularSpeed = a.minAngularSpeed, b.maxAngularSpeed = a.maxAngularSpeed, b.minSize = a.minSize, b.maxSize = a.maxSize, b.minLifeTime = a.minLifeTime, b.maxLifeTime = a.maxLifeTime, b.emitRate = a.emitRate, b.minEmitBox = a.minEmitBox.asArray(), b.maxEmitBox = a.maxEmitBox.asArray(), b.gravity = a.gravity.asArray(), b.direction1 = a.direction1.asArray(), b.direction2 = a.direction2.asArray(), b.color1 = a.color1.asArray(), b.color2 = a.color2.asArray(), b.colorDead = a.colorDead.asArray(), b.updateSpeed = a.updateSpeed, b.targetStopDuration = a.targetStopDuration, b.textureMask = a.textureMask.asArray(), b.blendMode = a.blendMode, b }, k = function (b) { var c = {}; c.emitterId = b.getEmitter().id, c.borderLimit = b.borderLimit, c.flares = []; for (var d = 0; d < b.lensFlares.length; d++) { var e = b.lensFlares[d]; c.flares.push({ size: e.size, position: e.position, color: e.color.asArray(), textureName: a.Tools.GetFilename(e.texture.name) }) } return c }, l = function (a) { var b = {}, c = a.getShadowGenerator(); b.lightId = a.id, b.mapSize = c.getShadowMap().getRenderSize(), b.useVarianceShadowMap = c.useVarianceShadowMap, b.renderList = []; for (var d = 0; d < c.getShadowMap().renderList.length; d++) { var e = c.getShadowMap().renderList[d]; b.renderList.push(e.id) } return b }, m = [], n = function (b, c) { if (!m[b.id]) { if (b instanceof a.Geometry.Primitives.Box) c.boxes.push(r(b)); else if (b instanceof a.Geometry.Primitives.Sphere) c.spheres.push(s(b)); else if (b instanceof a.Geometry.Primitives.Cylinder) c.cylinders.push(t(b)); else if (b instanceof a.Geometry.Primitives.Torus) c.toruses.push(u(b)); else if (b instanceof a.Geometry.Primitives.Ground) c.grounds.push(v(b)); else if (b instanceof a.Geometry.Primitives.Plane) c.planes.push(w(b)); else if (b instanceof a.Geometry.Primitives.TorusKnot) c.torusKnots.push(x(b)); else { if (b instanceof a.Geometry.Primitives._Primitive) throw new Error("Unknow primitive type"); c.vertexData.push(p(b)) } m[b.id] = !0 } }, o = function (b) { var c = {}; return c.id = b.id, a.Tags.HasTags(b) && (c.tags = a.Tags.GetTags(b)), c }, p = function (b) { var c = o(b); return b.isVerticesDataPresent(a.VertexBuffer.PositionKind) && (c.positions = b.getVerticesData(a.VertexBuffer.PositionKind)), b.isVerticesDataPresent(a.VertexBuffer.NormalKind) && (c.normals = b.getVerticesData(a.VertexBuffer.NormalKind)), b.isVerticesDataPresent(a.VertexBuffer.UVKind) && (c.uvs = b.getVerticesData(a.VertexBuffer.UVKind)), b.isVerticesDataPresent(a.VertexBuffer.UV2Kind) && (c.uvs2 = b.getVerticesData(a.VertexBuffer.UV2Kind)), b.isVerticesDataPresent(a.VertexBuffer.ColorKind) && (c.colors = b.getVerticesData(a.VertexBuffer.ColorKind)), b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind) && (c.matricesIndices = b.getVerticesData(a.VertexBuffer.MatricesIndicesKind), c.matricesIndices._isExpanded = !0), b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind) && (c.matricesWeights = b.getVerticesData(a.VertexBuffer.MatricesWeightsKind)), c.indices = b.getIndices(), c }, q = function (a) { var b = o(a); return b.canBeRegenerated = a.canBeRegenerated(), b }, r = function (a) { var b = q(a); return b.size = a.size, b }, s = function (a) { var b = q(a); return b.segments = a.segments, b.diameter = a.diameter, b }, t = function (a) { var b = q(a); return b.height = a.height, b.diameterTop = a.diameterTop, b.diameterBottom = a.diameterBottom, b.tessellation = a.tessellation, b }, u = function (a) { var b = q(a); return b.diameter = a.diameter, b.thickness = a.thickness, b.tessellation = a.tessellation, b }, v = function (a) { var b = q(a); return b.width = a.width, b.height = a.height, b.subdivisions = a.subdivisions, b }, w = function (a) { var b = q(a); return b.size = a.size, b }, x = function (a) { var b = q(a); return b.radius = a.radius, b.tube = a.tube, b.radialSegments = a.radialSegments, b.tubularSegments = a.tubularSegments, b.p = a.p, b.q = a.q, b }, y = function (b, c) { var e = {}; e.name = b.name, e.id = b.id, a.Tags.HasTags(b) && (e.tags = a.Tags.GetTags(b)), e.position = b.position.asArray(), b.rotation ? e.rotation = b.rotation.asArray() : b.rotationQuaternion && (e.rotationQuaternion = b.rotationQuaternion.asArray()), e.scaling = b.scaling.asArray(), e.localMatrix = b.getPivotMatrix().asArray(), e.isEnabled = b.isEnabled(), e.isVisible = b.isVisible, e.infiniteDistance = b.infiniteDistance, e.pickable = b.isPickable, e.receiveShadows = b.receiveShadows, e.billboardMode = b.billboardMode, e.visibility = b.visibility, e.checkCollisions = b.checkCollisions, b.parent && (e.parentId = b.parent.id); var f = b._geometry; if (f) { var g = f.id; e.geometryId = g, b.getScene().getGeometryByID(g) || n(f, c.geometries), e.subMeshes = []; for (var h = 0; h < b.subMeshes.length; h++) { var i = b.subMeshes[h]; e.subMeshes.push({ materialIndex: i.materialIndex, verticesStart: i.verticesStart, verticesCount: i.verticesCount, indexStart: i.indexStart, indexCount: i.indexCount }) } } if (b.material ? e.materialId = b.material.id : b.material = null, b.skeleton && (e.skeletonId = b.skeleton.id), b.getPhysicsImpostor() !== a.PhysicsEngine.NoImpostor) switch (e.physicsMass = b.getPhysicsMass(), e.physicsFriction = b.getPhysicsFriction(), e.physicsRestitution = b.getPhysicsRestitution(), b.getPhysicsImpostor()) { case a.PhysicsEngine.BoxImpostor: e.physicsImpostor = 1; break; case a.PhysicsEngine.SphereImpostor: e.physicsImpostor = 2 } return d(b, e), e }, z = function () { function d() { } return d.Serialize = function (d) { var e = {}; e.useDelayedTextureLoading = d.useDelayedTextureLoading, e.autoClear = d.autoClear, e.clearColor = d.clearColor.asArray(), e.ambientColor = d.ambientColor.asArray(), e.gravity = d.gravity.asArray(), d.fogMode && 0 !== d.fogMode && (e.fogMode = d.fogMode, e.fogColor = d.fogColor.asArray(), e.fogStart = d.fogStart, e.fogEnd = d.fogEnd, e.fogDensity = d.fogDensity), e.lights = []; for (var h = 0; h < d.lights.length; h++) { var o = d.lights[h]; e.lights.push(b(o)) } for (e.cameras = [], h = 0; h < d.cameras.length; h++) { var p = d.cameras[h]; p instanceof a.FreeCamera && e.cameras.push(c(p)) } for (d.activeCamera && (e.activeCameraID = d.activeCamera.id), e.materials = [], e.multiMaterials = [], h = 0; h < d.materials.length; h++) { var q = d.materials[h]; q instanceof a.StandardMaterial ? e.materials.push(g(q)) : q instanceof a.MultiMaterial && e.multiMaterials.push(f(q)) } for (e.skeletons = [], h = 0; h < d.skeletons.length; h++) e.skeletons.push(i(d.skeletons[h])); e.geometries = {}, e.geometries.boxes = [], e.geometries.spheres = [], e.geometries.cylinders = [], e.geometries.toruses = [], e.geometries.grounds = [], e.geometries.planes = [], e.geometries.torusKnots = [], e.geometries.vertexData = [], m = []; for (var r = d.getGeometries(), h = 0; h < r.length; h++) { var s = r[h]; s.isReady() && n(s, e.geometries) } for (e.meshes = [], h = 0; h < d.meshes.length; h++) { var t = d.meshes[h]; (t.delayLoadState === a.Engine.DELAYLOADSTATE_LOADED || t.delayLoadState === a.Engine.DELAYLOADSTATE_NONE) && e.meshes.push(y(t, e)) } for (e.particleSystems = [], h = 0; h < d.particleSystems.length; h++) e.particleSystems.push(j(d.particleSystems[h])); for (e.lensFlareSystems = [], h = 0; h < d.lensFlareSystems.length; h++) e.lensFlareSystems.push(k(d.lensFlareSystems[h])); for (e.shadowGenerators = [], h = 0; h < d.lights.length; h++) o = d.lights[h], o.getShadowGenerator() && e.shadowGenerators.push(l(o)); return e }, d }(); a.SceneSerializer = z }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { BABYLON.SceneLoader = { _registeredPlugins: [], _getPluginForFilename: function (a) { for (var b = a.lastIndexOf("."), c = a.substring(b).toLowerCase(), d = 0; d < this._registeredPlugins.length; d++) { var e = this._registeredPlugins[d]; if (-1 !== e.extensions.indexOf(c)) return e } throw new Error("No plugin found to load this file: " + a) }, RegisterPlugin: function (a) { a.extensions = a.extensions.toLowerCase(), this._registeredPlugins.push(a) }, ImportMesh: function (a, b, c, d, e, f, g) { var h = new BABYLON.Database(b + c); d.database = h; var i = this._getPluginForFilename(c); BABYLON.Tools.LoadFile(b + c, function (f) { var h = [], j = [], k = []; return i.importMesh(a, d, f, b, h, j, k) ? void (e && (d.importedMeshesFiles.push(b + c), e(h, j, k))) : void (g && g(d)) }, f, h) }, Load: function (a, b, c, d, e, f) { var g, h = this._getPluginForFilename(b.name || b), i = function (b) { var e = new BABYLON.Scene(c); return e.database = g, h.load(e, b, a) ? void (d && d(e)) : void (f && f(e)) }; -1 === a.indexOf("file:") ? (g = new BABYLON.Database(a + b), BABYLON.Tools.LoadFile(a + b, i, e, g)) : BABYLON.Tools.ReadFile(b, i, e) } } }(); var BABYLON = BABYLON || {}; !function () { var a = function (a, b, c) { var d = new BABYLON.CubeTexture(a + b.name, c); return d.name = b.name, d.hasAlpha = b.hasAlpha, d.level = b.level, d.coordinatesMode = b.coordinatesMode, d }, b = function (b, c, d) { if (!c.name && !c.isRenderTarget) return null; if (c.isCube) return a(b, c, d); var e; if (c.mirrorPlane ? (e = new BABYLON.MirrorTexture(c.name, c.renderTargetSize, d), e._waitingRenderList = c.renderList, e.mirrorPlane = BABYLON.Plane.FromArray(c.mirrorPlane)) : c.isRenderTarget ? (e = new BABYLON.RenderTargetTexture(c.name, c.renderTargetSize, d), e._waitingRenderList = c.renderList) : e = new BABYLON.Texture(b + c.name, d), e.name = c.name, e.hasAlpha = c.hasAlpha, e.level = c.level, e.coordinatesIndex = c.coordinatesIndex, e.coordinatesMode = c.coordinatesMode, e.uOffset = c.uOffset, e.vOffset = c.vOffset, e.uScale = c.uScale, e.vScale = c.vScale, e.uAng = c.uAng, e.vAng = c.vAng, e.wAng = c.wAng, e.wrapU = c.wrapU, e.wrapV = c.wrapV, c.animations) for (var f = 0; f < c.animations.length; f++) { var g = c.animations[f]; e.animations.push(j(g)) } return e }, c = function (a, b) { for (var c = new BABYLON.Skeleton(a.name, a.id, b), d = 0; d < a.bones.length; d++) { var e = a.bones[d], f = null; e.parentBoneIndex > -1 && (f = c.bones[e.parentBoneIndex]); var g = new BABYLON.Bone(e.name, c, f, BABYLON.Matrix.FromArray(e.matrix)); e.animation && g.animations.push(j(e.animation)) } return c }, d = function (a, c, d) { var e; return e = new BABYLON.StandardMaterial(a.name, c), e.ambientColor = BABYLON.Color3.FromArray(a.ambient), e.diffuseColor = BABYLON.Color3.FromArray(a.diffuse), e.specularColor = BABYLON.Color3.FromArray(a.specular), e.specularPower = a.specularPower, e.emissiveColor = BABYLON.Color3.FromArray(a.emissive), e.alpha = a.alpha, e.id = a.id, BABYLON.Tags.AddTagsTo(e, a.tags), e.backFaceCulling = a.backFaceCulling, a.diffuseTexture && (e.diffuseTexture = b(d, a.diffuseTexture, c)), a.ambientTexture && (e.ambientTexture = b(d, a.ambientTexture, c)), a.opacityTexture && (e.opacityTexture = b(d, a.opacityTexture, c)), a.reflectionTexture && (e.reflectionTexture = b(d, a.reflectionTexture, c)), a.emissiveTexture && (e.emissiveTexture = b(d, a.emissiveTexture, c)), a.specularTexture && (e.specularTexture = b(d, a.specularTexture, c)), a.bumpTexture && (e.bumpTexture = b(d, a.bumpTexture, c)), e }, e = function (a, b, c, e) { for (var f = 0; f < b.materials.length; f++) { var g = b.materials[f]; if (g.id === a) return d(g, c, e) } return null }, f = function (a, b) { var c = new BABYLON.MultiMaterial(a.name, b); c.id = a.id, BABYLON.Tags.AddTagsTo(c, a.tags); for (var d = 0; d < a.materials.length; d++) { var e = a.materials[d]; c.subMaterials.push(e ? b.getMaterialByID(e) : null) } return c }, g = function (a, b, c) { var d = b.getLastEntryByID(a.emitterId), e = new BABYLON.LensFlareSystem("lensFlareSystem#" + a.emitterId, d, b); e.borderLimit = a.borderLimit; for (var f = 0; f < a.flares.length; f++) { var g = a.flares[f]; new BABYLON.LensFlare(g.size, g.position, BABYLON.Color3.FromArray(g.color), c + g.textureName, e) } return e }, h = function (a, b, c) { var d = b.getLastMeshByID(a.emitterId), e = new BABYLON.ParticleSystem("particles#" + d.name, a.capacity, b); return a.textureName && (e.particleTexture = new BABYLON.Texture(c + a.textureName, b), e.particleTexture.name = a.textureName), e.minAngularSpeed = a.minAngularSpeed, e.maxAngularSpeed = a.maxAngularSpeed, e.minSize = a.minSize, e.maxSize = a.maxSize, e.minLifeTime = a.minLifeTime, e.maxLifeTime = a.maxLifeTime, e.emitter = d, e.emitRate = a.emitRate, e.minEmitBox = BABYLON.Vector3.FromArray(a.minEmitBox), e.maxEmitBox = BABYLON.Vector3.FromArray(a.maxEmitBox), e.gravity = BABYLON.Vector3.FromArray(a.gravity), e.direction1 = BABYLON.Vector3.FromArray(a.direction1), e.direction2 = BABYLON.Vector3.FromArray(a.direction2), e.color1 = BABYLON.Color4.FromArray(a.color1), e.color2 = BABYLON.Color4.FromArray(a.color2), e.colorDead = BABYLON.Color4.FromArray(a.colorDead), e.updateSpeed = a.updateSpeed, e.targetStopDuration = a.targetStopFrame, e.textureMask = BABYLON.Color4.FromArray(a.textureMask), e.blendMode = a.blendMode, e.start(), e }, i = function (a, b) { for (var c = b.getLightByID(a.lightId), d = new BABYLON.ShadowGenerator(a.mapSize, c), e = 0; e < a.renderList.length; e++) { var f = b.getMeshByID(a.renderList[e]); d.getShadowMap().renderList.push(f) } return d.useVarianceShadowMap = a.useVarianceShadowMap, d }, j = function (a) { for (var b = new BABYLON.Animation(a.name, a.property, a.framePerSecond, a.dataType, a.loopBehavior), c = a.dataType, d = [], e = 0; e < a.keys.length; e++) { var f, g = a.keys[e]; switch (c) { case BABYLON.Animation.ANIMATIONTYPE_FLOAT: f = g.values[0]; break; case BABYLON.Animation.ANIMATIONTYPE_QUATERNION: f = BABYLON.Quaternion.FromArray(g.values); break; case BABYLON.Animation.ANIMATIONTYPE_MATRIX: f = BABYLON.Matrix.FromArray(g.values); break; case BABYLON.Animation.ANIMATIONTYPE_VECTOR3: default: f = BABYLON.Vector3.FromArray(g.values) } d.push({ frame: g.frame, value: f }) } return b.setKeys(d), b }, k = function (a, b) { var c; switch (a.type) { case 0: c = new BABYLON.PointLight(a.name, BABYLON.Vector3.FromArray(a.position), b); break; case 1: c = new BABYLON.DirectionalLight(a.name, BABYLON.Vector3.FromArray(a.direction), b), c.position = BABYLON.Vector3.FromArray(a.position); break; case 2: c = new BABYLON.SpotLight(a.name, BABYLON.Vector3.FromArray(a.position), BABYLON.Vector3.FromArray(a.direction), a.angle, a.exponent, b); break; case 3: c = new BABYLON.HemisphericLight(a.name, BABYLON.Vector3.FromArray(a.direction), b), c.groundColor = BABYLON.Color3.FromArray(a.groundColor) } c.id = a.id, BABYLON.Tags.AddTagsTo(c, a.tags), a.intensity && (c.intensity = a.intensity), a.range && (c.range = a.range), c.diffuse = BABYLON.Color3.FromArray(a.diffuse), c.specular = BABYLON.Color3.FromArray(a.specular) }, l = function (a, b) { var c = new BABYLON.FreeCamera(a.name, BABYLON.Vector3.FromArray(a.position), b); if (c.id = a.id, BABYLON.Tags.AddTagsTo(c, a.tags), a.parentId && (c._waitingParentId = a.parentId), a.target ? c.setTarget(BABYLON.Vector3.FromArray(a.target)) : c.rotation = BABYLON.Vector3.FromArray(a.rotation), a.lockedTargetId && (c._waitingLockedTargetId = a.lockedTargetId), c.fov = a.fov, c.minZ = a.minZ, c.maxZ = a.maxZ, c.speed = a.speed, c.inertia = a.inertia, c.checkCollisions = a.checkCollisions, c.applyGravity = a.applyGravity, a.ellipsoid && (c.ellipsoid = BABYLON.Vector3.FromArray(a.ellipsoid)), a.animations) for (var d = 0; d < a.animations.length; d++) { var e = a.animations[d]; c.animations.push(j(e)) } return a.autoAnimate && b.beginAnimation(c, a.autoAnimateFrom, a.autoAnimateTo, a.autoAnimateLoop, 1), c }, m = function (a, b) { var c = a.id; return b.getGeometryByID(c) }, n = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.Box(a.id, b.getEngine(), a.size, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, o = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.Sphere(a.id, b.getEngine(), a.segments, a.diameter, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, p = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.Cylinder(a.id, b.getEngine(), a.height, a.diameterTop, a.diameterBottom, a.tessellation, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, q = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.Torus(a.id, b.getEngine(), a.diameter, a.thickness, a.tessellation, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, r = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.Ground(a.id, b.getEngine(), a.width, a.height, a.subdivisions, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, s = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.Plane(a.id, b.getEngine(), a.size, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, t = function (a, b) { if (m(a, b)) return null; var c = new BABYLON.Geometry.Primitives.TorusKnot(a.id, b.getEngine(), a.radius, a.tube, a.radialSegments, a.tubularSegments, a.p, a.q, a.canBeRegenerated, null); return BABYLON.Tags.AddTagsTo(c, a.tags), b.pushGeometry(c, !0), c }, u = function (a, b, c) { if (m(a, b)) return null; var d = new BABYLON.Geometry(a.id, b.getEngine()); return BABYLON.Tags.AddTagsTo(d, a.tags), a.delayLoadingFile ? (d.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED, d.delayLoadingFile = c + a.delayLoadingFile, d._boundingInfo = new BABYLON.BoundingInfo(BABYLON.Vector3.FromArray(a.boundingBoxMinimum), BABYLON.Vector3.FromArray(a.boundingBoxMaximum)), d._delayInfo = [], a.hasUVs && d._delayInfo.push(BABYLON.VertexBuffer.UVKind), a.hasUVs2 && d._delayInfo.push(BABYLON.VertexBuffer.UV2Kind), a.hasColors && d._delayInfo.push(BABYLON.VertexBuffer.ColorKind), a.hasMatricesIndices && d._delayInfo.push(BABYLON.VertexBuffer.MatricesIndicesKind), a.hasMatricesWeights && d._delayInfo.push(BABYLON.VertexBuffer.MatricesWeightsKind), d._delayLoadingFunction = x) : x(a, d), b.pushGeometry(d, !0), d }, v = function (a, b, c) { var d = new BABYLON.Mesh(a.name, b); if (d.id = a.id, BABYLON.Tags.AddTagsTo(d, a.tags), d.position = BABYLON.Vector3.FromArray(a.position), a.rotation ? d.rotation = BABYLON.Vector3.FromArray(a.rotation) : a.rotationQuaternion && (d.rotationQuaternion = BABYLON.Quaternion.FromArray(a.rotationQuaternion)), d.scaling = BABYLON.Vector3.FromArray(a.scaling), a.localMatrix && d.setPivotMatrix(BABYLON.Matrix.FromArray(a.localMatrix)), d.setEnabled(a.isEnabled), d.isVisible = a.isVisible, d.infiniteDistance = a.infiniteDistance, void 0 !== a.pickable && (d.isPickable = a.pickable), d.receiveShadows = a.receiveShadows, d.billboardMode = a.billboardMode, void 0 !== a.visibility && (d.visibility = a.visibility), d.checkCollisions = a.checkCollisions, d._shouldGenerateFlatShading = a.useFlatShading, a.parentId && (d.parent = b.getLastEntryByID(a.parentId)), a.delayLoadingFile ? (d.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED, d.delayLoadingFile = c + a.delayLoadingFile, d._boundingInfo = new BABYLON.BoundingInfo(BABYLON.Vector3.FromArray(a.boundingBoxMinimum), BABYLON.Vector3.FromArray(a.boundingBoxMaximum)), d._delayInfo = [], a.hasUVs && d._delayInfo.push(BABYLON.VertexBuffer.UVKind), a.hasUVs2 && d._delayInfo.push(BABYLON.VertexBuffer.UV2Kind), a.hasColors && d._delayInfo.push(BABYLON.VertexBuffer.ColorKind), a.hasMatricesIndices && d._delayInfo.push(BABYLON.VertexBuffer.MatricesIndicesKind), a.hasMatricesWeights && d._delayInfo.push(BABYLON.VertexBuffer.MatricesWeightsKind), d._delayLoadingFunction = y) : y(a, d), a.materialId ? d.setMaterialByID(a.materialId) : d.material = null, a.skeletonId > -1 && (d.skeleton = b.getLastSkeletonByID(a.skeletonId)), a.physicsImpostor) switch (b.isPhysicsEnabled() || b.enablePhysics(), a.physicsImpostor) { case 1: d.setPhysicsState({ impostor: BABYLON.PhysicsEngine.BoxImpostor, mass: a.physicsMass, friction: a.physicsFriction, restitution: a.physicsRestitution }); break; case 2: d.setPhysicsState({ impostor: BABYLON.PhysicsEngine.SphereImpostor, mass: a.physicsMass, friction: a.physicsFriction, restitution: a.physicsRestitution }) } if (a.animations) for (var e = 0; e < a.animations.length; e++) { var f = a.animations[e]; d.animations.push(j(f)) } return a.autoAnimate && b.beginAnimation(d, a.autoAnimateFrom, a.autoAnimateTo, a.autoAnimateLoop, 1), d }, w = function (a, b, c) { b = b instanceof Array ? b : [b]; for (var d in b) if (a.name === b[d]) return c.push(a.id), !0; return a.parentId && -1 !== c.indexOf(a.parentId) ? (c.push(a.id), !0) : !1 }, x = function (a, b) { var c = new BABYLON.VertexData, d = a.positions; d && c.set(d, BABYLON.VertexBuffer.PositionKind); var e = a.normals; e && c.set(e, BABYLON.VertexBuffer.NormalKind); var f = a.uvs; f && c.set(f, BABYLON.VertexBuffer.UVKind); var g = a.uv2s; g && c.set(g, BABYLON.VertexBuffer.UV2Kind); var h = a.colors; h && c.set(h, BABYLON.VertexBuffer.ColorKind); var i = a.matricesIndices; i && c.set(i, BABYLON.VertexBuffer.MatricesIndicesKind); var j = a.matricesWeights; j && c.set(j, BABYLON.VertexBuffer.MatricesWeightsKind); var k = a.indices; k && (c.indices = k), b.setAllVerticesData(c, a.updatable) }, y = function (a, b) { var c = b.getScene(), d = a.geometryId; if (d) { var e = c.getGeometryByID(d); e && e.applyToMesh(b) } else if (a.positions && a.normals && a.indices) { if (b.setVerticesData(a.positions, BABYLON.VertexBuffer.PositionKind, !1), b.setVerticesData(a.normals, BABYLON.VertexBuffer.NormalKind, !1), a.uvs && b.setVerticesData(a.uvs, BABYLON.VertexBuffer.UVKind, !1), a.uvs2 && b.setVerticesData(a.uvs2, BABYLON.VertexBuffer.UV2Kind, !1), a.colors && b.setVerticesData(a.colors, BABYLON.VertexBuffer.ColorKind, !1), a.matricesIndices) if (a.matricesIndices._isExpanded) delete a.matricesIndices._isExpanded, b.setVerticesData(a.matricesIndices, BABYLON.VertexBuffer.MatricesIndicesKind, !1); else { for (var f = [], g = 0; g < a.matricesIndices.length; g++) { var h = a.matricesIndices[g]; f.push(255 & h), f.push((65280 & h) >> 8), f.push((16711680 & h) >> 16), f.push(h >> 24) } b.setVerticesData(f, BABYLON.VertexBuffer.MatricesIndicesKind, !1) } a.matricesWeights && b.setVerticesData(a.matricesWeights, BABYLON.VertexBuffer.MatricesWeightsKind, !1), b.setIndices(a.indices) } if (a.subMeshes) { b.subMeshes = []; for (var i = 0; i < a.subMeshes.length; i++) { var j = a.subMeshes[i]; new BABYLON.SubMesh(j.materialIndex, j.verticesStart, j.verticesCount, j.indexStart, j.indexCount, b) } } b.computeWorldMatrix(!0), b._shouldGenerateFlatShading && (b.convertToFlatShadedMesh(), delete b._shouldGenerateFlatShading), c._selectionOctree && c._selectionOctree.addMesh(b) }; BABYLON.SceneLoader.RegisterPlugin({ extensions: ".babylon", importMesh: function (a, b, d, g, i, j, k) { for (var l = JSON.parse(d), m = [], n = [], o = [], p = 0; p < l.meshes.length; p++) { var q = l.meshes[p]; if (!a || w(q, a, o)) { if (a instanceof Array && delete a[a.indexOf(q.name)], q.materialId) { var r = -1 !== n.indexOf(q.materialId); if (!r) for (var s = 0; s < l.multiMaterials.length; s++) { var t = l.multiMaterials[s]; if (t.id == q.materialId) { for (var u = 0; u < t.materials.length; u++) { var x = t.materials[u]; n.push(x), e(x, l, b, g) } n.push(t.id), f(t, b), r = !0; break } } r || (n.push(q.materialId), e(q.materialId, l, b, g)) } if (q.skeletonId > -1 && b.skeletons) { var y = m.indexOf(q.skeletonId) > -1; if (!y) for (var z = 0; z < l.skeletons.length; z++) { var A = l.skeletons[z]; A.id === q.skeletonId && (k.push(c(A, b)), m.push(A.id)) } } var B = v(q, b, g); i.push(B) } } if (l.particleSystems) for (var p = 0; p < l.particleSystems.length; p++) { var C = l.particleSystems[p]; -1 !== o.indexOf(C.emitterId) && j.push(h(C, b, g)) } return !0 }, load: function (a, b, e) { var j = JSON.parse(b); a.useDelayedTextureLoading = j.useDelayedTextureLoading, a.autoClear = j.autoClear, a.clearColor = BABYLON.Color3.FromArray(j.clearColor), a.ambientColor = BABYLON.Color3.FromArray(j.ambientColor), a.gravity = BABYLON.Vector3.FromArray(j.gravity), j.fogMode && 0 !== j.fogMode && (a.fogMode = j.fogMode, a.fogColor = BABYLON.Color3.FromArray(j.fogColor), a.fogStart = j.fogStart, a.fogEnd = j.fogEnd, a.fogDensity = j.fogDensity); for (var m = 0; m < j.lights.length; m++) { var w = j.lights[m]; k(w, a) } for (var m = 0; m < j.cameras.length; m++) { var x = j.cameras[m]; l(x, a) } if (j.activeCameraID && a.setActiveCameraByID(j.activeCameraID), j.materials) for (var m = 0; m < j.materials.length; m++) { var y = j.materials[m]; d(y, a, e) } if (j.multiMaterials) for (var m = 0; m < j.multiMaterials.length; m++) { var z = j.multiMaterials[m]; f(z, a) } if (j.skeletons) for (var m = 0; m < j.skeletons.length; m++) { var A = j.skeletons[m]; c(A, a) } var B = j.geometries; if (B) { var C = B.boxes; if (C) for (var m = 0; m < C.length; m++) { var D = C[m]; n(D, a) } var E = B.spheres; if (E) for (var m = 0; m < E.length; m++) { var F = E[m]; o(F, a) } var G = B.cylinders; if (G) for (var m = 0; m < G.length; m++) { var H = G[m]; p(H, a) } var I = B.toruses; if (I) for (var m = 0; m < I.length; m++) { var J = I[m]; q(J, a) } var K = B.grounds; if (K) for (var m = 0; m < K.length; m++) { var L = K[m]; r(L, a) } var M = B.planes; if (M) for (var m = 0; m < M.length; m++) { var N = M[m]; s(N, a) } var O = B.torusKnots; if (O) for (var m = 0; m < O.length; m++) { var P = O[m]; t(P, a) } var Q = B.vertexData; if (Q) for (var m = 0; m < Q.length; m++) { var R = Q[m]; u(R, a, e) } } for (var m = 0; m < j.meshes.length; m++) { var S = j.meshes[m]; v(S, a, e) } for (var m = 0; m < a.cameras.length; m++) { var T = a.cameras[m]; T._waitingParentId && (T.parent = a.getLastEntryByID(T._waitingParentId), delete T._waitingParentId), T._waitingLockedTargetId && (T.lockedTarget = a.getLastEntryByID(T._waitingLockedTargetId), delete T._waitingLockedTargetId) } if (j.particleSystems) for (var m = 0; m < j.particleSystems.length; m++) { var U = j.particleSystems[m]; h(U, a, e) } if (j.lensFlareSystems) for (var m = 0; m < j.lensFlareSystems.length; m++) { var V = j.lensFlareSystems[m]; g(V, a, e) } if (j.shadowGenerators) for (var m = 0; m < j.shadowGenerators.length; m++) { var W = j.shadowGenerators[m]; i(W, a) } return !0 } }) }(); var BABYLON; !function (a) {
	var b = 0, c = function () { function b(a, b, c) { this.pos = a, this.normal = b, this.uv = c } return b.prototype.clone = function () { return new b(this.pos.clone(), this.normal.clone(), this.uv.clone()) }, b.prototype.flip = function () { this.normal = this.normal.scale(-1) }, b.prototype.interpolate = function (c, d) { return new b(a.Vector3.Lerp(this.pos, c.pos, d), a.Vector3.Lerp(this.normal, c.normal, d), a.Vector2.Lerp(this.uv, c.uv, d)) }, b }(), d = function () { function b(a, b) { this.normal = a, this.w = b } return b.FromPoints = function (c, d, e) { var f = e.subtract(c), g = d.subtract(c); if (0 === f.lengthSquared() || 0 === g.lengthSquared()) return null; var h = a.Vector3.Normalize(a.Vector3.Cross(f, g)); return new b(h, a.Vector3.Dot(h, c)) }, b.prototype.clone = function () { return new b(this.normal.clone(), this.w) }, b.prototype.flip = function () { this.normal.scaleInPlace(-1), this.w = -this.w }, b.prototype.splitPolygon = function (c, d, f, g, h) { for (var i = 0, j = 1, k = 2, l = 3, m = 0, n = [], o = 0; o < c.vertices.length; o++) { var p = a.Vector3.Dot(this.normal, c.vertices[o].pos) - this.w, q = p < -b.EPSILON ? k : p > b.EPSILON ? j : i; m |= q, n.push(q) } switch (m) { case i: (a.Vector3.Dot(this.normal, c.plane.normal) > 0 ? d : f).push(c); break; case j: g.push(c); break; case k: h.push(c); break; case l: var r = [], s = []; for (o = 0; o < c.vertices.length; o++) { var t = (o + 1) % c.vertices.length, u = n[o], v = n[t], w = c.vertices[o], x = c.vertices[t]; if (u != k && r.push(w), u != j && s.push(u != k ? w.clone() : w), (u | v) == l) { p = (this.w - a.Vector3.Dot(this.normal, w.pos)) / a.Vector3.Dot(this.normal, x.pos.subtract(w.pos)); var y = w.interpolate(x, p); r.push(y), s.push(y.clone()) } } if (r.length >= 3) { var z = new e(r, c.shared); z.plane && g.push(z) } s.length >= 3 && (z = new e(s, c.shared), z.plane && h.push(z)) } }, b.EPSILON = 1e-5, b }(), e = function () { function a(a, b) { this.vertices = a, this.shared = b, this.plane = d.FromPoints(a[0].pos, a[1].pos, a[2].pos) } return a.prototype.clone = function () { var b = this.vertices.map(function (a) { return a.clone() }); return new a(b, this.shared) }, a.prototype.flip = function () { this.vertices.reverse().map(function (a) { a.flip() }), this.plane.flip() }, a }(), f = function () { function a(a) { this.plane = null, this.front = null, this.back = null, this.polygons = [], a && this.build(a) } return a.prototype.clone = function () { var b = new a; return b.plane = this.plane && this.plane.clone(), b.front = this.front && this.front.clone(), b.back = this.back && this.back.clone(), b.polygons = this.polygons.map(function (a) { return a.clone() }), b }, a.prototype.invert = function () { for (var a = 0; a < this.polygons.length; a++) this.polygons[a].flip(); this.plane && this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert(); var b = this.front; this.front = this.back, this.back = b }, a.prototype.clipPolygons = function (a) { if (!this.plane) return a.slice(); for (var b = [], c = [], d = 0; d < a.length; d++) this.plane.splitPolygon(a[d], b, c, b, c); return this.front && (b = this.front.clipPolygons(b)), c = this.back ? this.back.clipPolygons(c) : [], b.concat(c) }, a.prototype.clipTo = function (a) { this.polygons = a.clipPolygons(this.polygons), this.front && this.front.clipTo(a), this.back && this.back.clipTo(a) }, a.prototype.allPolygons = function () { var a = this.polygons.slice(); return this.front && (a = a.concat(this.front.allPolygons())), this.back && (a = a.concat(this.back.allPolygons())), a }, a.prototype.build = function (b) { if (b.length) { this.plane || (this.plane = b[0].plane.clone()); for (var c = [], d = [], e = 0; e < b.length; e++) this.plane.splitPolygon(b[e], this.polygons, this.polygons, c, d); c.length && (this.front || (this.front = new a), this.front.build(c)), d.length && (this.back || (this.back = new a), this.back.build(d)) } }, a }(), g = function () {
		function d() { this.polygons = new Array } return d.FromMesh = function (f) { var g, h, i, j, k, l, m = []; if (!(f instanceof a.Mesh)) throw "BABYLON.CSG:Wrong Mesh type,must be BABYLON.Mesh"; f.computeWorldMatrix(!0); for (var n = f.getWorldMatrix(), o = f.position.clone(), p = f.rotation.clone(), q = f.scaling.clone(), r = f.getIndices(), s = f.getVerticesData(a.VertexBuffer.PositionKind), t = f.getVerticesData(a.VertexBuffer.NormalKind), u = f.getVerticesData(a.VertexBuffer.UVKind), v = f.subMeshes, w = 0, x = v.length; x > w; w++) for (var y = v[w].indexStart, z = v[w].indexCount + v[w].indexStart; z > y; y += 3) { l = []; for (var A = 0; 3 > A; A++) h = new a.Vector3(t[3 * r[y + A]], t[3 * r[y + A] + 1], t[3 * r[y + A] + 2]), i = new a.Vector2(u[2 * r[y + A]], u[2 * r[y + A] + 1]), j = new a.Vector3(s[3 * r[y + A]], s[3 * r[y + A] + 1], s[3 * r[y + A] + 2]), a.Vector3.TransformCoordinatesToRef(j, n, j), a.Vector3.TransformNormalToRef(h, n, h), g = new c(j, h, i), l.push(g); k = new e(l, { subMeshId: w, meshId: b, materialIndex: v[w].materialIndex }), k.plane && m.push(k) } var B = d.FromPolygons(m); return B.matrix = n, B.position = o, B.rotation = p, B.scaling = q, b++, B }, d.FromPolygons = function (b) {
			var c = new a.CSG;
			return c.polygons = b, c
		}, d.prototype.clone = function () { var b = new a.CSG; return b.polygons = this.polygons.map(function (a) { return a.clone() }), b.copyTransformAttributes(this), b }, d.prototype.toPolygons = function () { return this.polygons }, d.prototype.union = function (a) { var b = new f(this.clone().polygons), c = new f(a.clone().polygons); return b.clipTo(c), c.clipTo(b), c.invert(), c.clipTo(b), c.invert(), b.build(c.allPolygons()), d.FromPolygons(b.allPolygons()).copyTransformAttributes(this) }, d.prototype.unionInPlace = function (a) { var b = new f(this.polygons), c = new f(a.polygons); b.clipTo(c), c.clipTo(b), c.invert(), c.clipTo(b), c.invert(), b.build(c.allPolygons()), this.polygons = b.allPolygons() }, d.prototype.subtract = function (a) { var b = new f(this.clone().polygons), c = new f(a.clone().polygons); return b.invert(), b.clipTo(c), c.clipTo(b), c.invert(), c.clipTo(b), c.invert(), b.build(c.allPolygons()), b.invert(), d.FromPolygons(b.allPolygons()).copyTransformAttributes(this) }, d.prototype.subtractInPlace = function (a) { var b = new f(this.polygons), c = new f(a.polygons); b.invert(), b.clipTo(c), c.clipTo(b), c.invert(), c.clipTo(b), c.invert(), b.build(c.allPolygons()), b.invert(), this.polygons = b.allPolygons() }, d.prototype.intersect = function (a) { var b = new f(this.clone().polygons), c = new f(a.clone().polygons); return b.invert(), c.clipTo(b), c.invert(), b.clipTo(c), c.clipTo(b), b.build(c.allPolygons()), b.invert(), d.FromPolygons(b.allPolygons()).copyTransformAttributes(this) }, d.prototype.intersectInPlace = function (a) { var b = new f(this.polygons), c = new f(a.polygons); b.invert(), c.clipTo(b), c.invert(), b.clipTo(c), c.clipTo(b), b.build(c.allPolygons()), b.invert(), this.polygons = b.allPolygons() }, d.prototype.inverse = function () { var a = this.clone(); return a.inverseInPlace(), a }, d.prototype.inverseInPlace = function () { this.polygons.map(function (a) { a.flip() }) }, d.prototype.copyTransformAttributes = function (a) { return this.matrix = a.matrix, this.position = a.position, this.rotation = a.rotation, this.scaling = a.scaling, this }, d.prototype.buildMeshGeometry = function (b, c, d) { var e = this.matrix.clone(); e.invert(); var f, g, h, i = new a.Mesh(b, c), j = [], k = [], l = [], m = [], n = a.Vector3.Zero(), o = a.Vector3.Zero(), p = a.Vector2.Zero(), q = this.polygons, r = [0, 0, 0], s = {}, t = 0, u = {}; d && q.sort(function (a, b) { return a.shared.meshId === b.shared.meshId ? a.shared.subMeshId - b.shared.subMeshId : a.shared.meshId - b.shared.meshId }); for (var v = 0, w = q.length; w > v; v++) { f = q[v], u[f.shared.meshId] || (u[f.shared.meshId] = {}), u[f.shared.meshId][f.shared.subMeshId] || (u[f.shared.meshId][f.shared.subMeshId] = { indexStart: +1 / 0, indexEnd: -1 / 0, materialIndex: f.shared.materialIndex }), h = u[f.shared.meshId][f.shared.subMeshId]; for (var x = 2, y = f.vertices.length; y > x; x++) { r[0] = 0, r[1] = x - 1, r[2] = x; for (var z = 0; 3 > z; z++) n.copyFrom(f.vertices[r[z]].pos), o.copyFrom(f.vertices[r[z]].normal), p.copyFrom(f.vertices[r[z]].uv), a.Vector3.TransformCoordinatesToRef(n, e, n), a.Vector3.TransformNormalToRef(o, e, o), g = s[n.x + "," + n.y + "," + n.z], ("undefined" == typeof g || l[3 * g] !== o.x || l[3 * g + 1] !== o.y || l[3 * g + 2] !== o.z || m[2 * g] !== p.x || m[2 * g + 1] !== p.y) && (j.push(n.x, n.y, n.z), m.push(p.x, p.y), l.push(o.x, o.y, o.z), g = s[n.x + "," + n.y + "," + n.z] = j.length / 3 - 1), k.push(g), h.indexStart = Math.min(t, h.indexStart), h.indexEnd = Math.max(t, h.indexEnd), t++ } } if (i.setVerticesData(j, a.VertexBuffer.PositionKind), i.setVerticesData(l, a.VertexBuffer.NormalKind), i.setVerticesData(m, a.VertexBuffer.UVKind), i.setIndices(k), d) { var A, B = 0; i.subMeshes.length = 0; for (var C in u) { A = -1; for (var D in u[C]) h = u[C][D], a.SubMesh.CreateFromIndices(h.materialIndex + B, h.indexStart, h.indexEnd - h.indexStart + 1, i), A = Math.max(h.materialIndex, A); B += ++A } } return i }, d.prototype.toMesh = function (a, b, c, d) { var e = this.buildMeshGeometry(a, c, d); return e.material = b, e.position.copyFrom(this.position), e.rotation.copyFrom(this.rotation), e.scaling.copyFrom(this.scaling), e.computeWorldMatrix(!0), e }, d
	}(); a.CSG = g
}(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f) { var g = this; b.call(this, c, "oculusDistortionCorrection", ["LensCenter", "Scale", "ScaleIn", "HmdWarpParam"], null, f.PostProcessScaleFactor, d, a.Texture.BILINEAR_SAMPLINGMODE, null, null), this._isRightEye = e, this._distortionFactors = f.DistortionK, this._postProcessScaleFactor = f.PostProcessScaleFactor, this._lensCenterOffset = f.LensCenterOffset, this.onSizeChanged = function () { g.aspectRatio = .5 * g.width / g.height, g._scaleIn = new a.Vector2(2, 2 / g.aspectRatio), g._scaleFactor = new a.Vector2(.5 * (1 / g._postProcessScaleFactor), .5 * (1 / g._postProcessScaleFactor) * g.aspectRatio), g._lensCenter = new a.Vector2(g._isRightEye ? .5 - .5 * g._lensCenterOffset : .5 + .5 * g._lensCenterOffset, .5) }, this.onApply = function (a) { a.setFloat2("LensCenter", g._lensCenter.x, g._lensCenter.y), a.setFloat2("Scale", g._scaleFactor.x, g._scaleFactor.y), a.setFloat2("ScaleIn", g._scaleIn.x, g._scaleIn.y), a.setFloat4("HmdWarpParam", g._distortionFactors[0], g._distortionFactors[1], g._distortionFactors[2], g._distortionFactors[3]) } } return __extends(c, b), c }(a.PostProcess); a.OculusDistortionCorrectionPostProcess = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { !function (a) { a[a.X = 0] = "X", a[a.Y = 1] = "Y", a[a.Z = 2] = "Z" }(a.JoystickAxis || (a.JoystickAxis = {})); var b = (a.JoystickAxis, function () { function b(c) { var d = this; this._leftJoystick = c ? !0 : !1, this._joystickIndex = b._globalJoystickIndex, b._globalJoystickIndex++, this._axisTargetedByLeftAndRight = 0, this._axisTargetedByUpAndDown = 1, this.reverseLeftRight = !1, this.reverseUpDown = !1, this._touches = new a.VirtualJoystick.Collection, this.deltaPosition = a.Vector3.Zero(), this._joystickSensibility = 25, this._inversedSensibility = 1 / (this._joystickSensibility / 1e3), this._rotationSpeed = 25, this._inverseRotationSpeed = 1 / (this._rotationSpeed / 1e3), this._rotateOnAxisRelativeToMesh = !1, b.vjCanvas || (window.addEventListener("resize", function () { b.vjCanvasWidth = window.innerWidth, b.vjCanvasHeight = window.innerHeight, b.vjCanvas.width = b.vjCanvasWidth, b.vjCanvas.height = b.vjCanvasHeight, b.halfWidth = b.vjCanvasWidth / 2, b.halfHeight = b.vjCanvasHeight / 2 }, !1), b.vjCanvas = document.createElement("canvas"), b.vjCanvasWidth = window.innerWidth, b.vjCanvasHeight = window.innerHeight, b.vjCanvas.width = window.innerWidth, b.vjCanvas.height = window.innerHeight, b.vjCanvas.style.width = "100%", b.vjCanvas.style.height = "100%", b.vjCanvas.style.position = "absolute", b.vjCanvas.style.backgroundColor = "transparent", b.vjCanvas.style.top = "0px", b.vjCanvas.style.left = "0px", b.vjCanvas.style.zIndex = "5", b.vjCanvas.style.msTouchAction = "none", b.vjCanvasContext = b.vjCanvas.getContext("2d"), b.vjCanvasContext.strokeStyle = "#ffffff", b.vjCanvasContext.lineWidth = 2, document.body.appendChild(b.vjCanvas)), b.halfWidth = b.vjCanvas.width / 2, b.halfHeight = b.vjCanvas.height / 2, this.pressed = !1, this._joystickColor = "cyan", this._joystickPointerID = -1, this._joystickPointerPos = new a.Vector2(0, 0), this._joystickPointerStartPos = new a.Vector2(0, 0), this._deltaJoystickVector = new a.Vector2(0, 0), b.vjCanvas.addEventListener("pointerdown", function (a) { d._onPointerDown(a) }, !1), b.vjCanvas.addEventListener("pointermove", function (a) { d._onPointerMove(a) }, !1), b.vjCanvas.addEventListener("pointerup", function (a) { d._onPointerUp(a) }, !1), b.vjCanvas.addEventListener("pointerout", function (a) { d._onPointerUp(a) }, !1), b.vjCanvas.addEventListener("contextmenu", function (a) { a.preventDefault() }, !1), requestAnimationFrame(function () { d._drawVirtualJoystick() }) } return b.prototype.setJoystickSensibility = function (a) { this._joystickSensibility = a, this._inversedSensibility = 1 / (this._joystickSensibility / 1e3) }, b.prototype._onPointerDown = function (a) { var c; a.preventDefault(), c = this._leftJoystick === !0 ? a.clientX < b.halfWidth : a.clientX > b.halfWidth, c && this._joystickPointerID < 0 ? (this._joystickPointerID = a.pointerId, this._joystickPointerStartPos.x = a.clientX, this._joystickPointerStartPos.y = a.clientY, this._joystickPointerPos = this._joystickPointerStartPos.clone(), this._deltaJoystickVector.x = 0, this._deltaJoystickVector.y = 0, this.pressed = !0, this._touches.add(a.pointerId.toString(), a)) : b._globalJoystickIndex < 2 && this._action && (this._action(), this._touches.add(a.pointerId.toString(), a)) }, b.prototype._onPointerMove = function (a) { if (this._joystickPointerID == a.pointerId) { this._joystickPointerPos.x = a.clientX, this._joystickPointerPos.y = a.clientY, this._deltaJoystickVector = this._joystickPointerPos.clone(), this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos); var b = this.reverseLeftRight ? -1 : 1, c = b * this._deltaJoystickVector.x / this._inversedSensibility; switch (this._axisTargetedByLeftAndRight) { case 0: this.deltaPosition.x = Math.min(1, Math.max(-1, c)); break; case 1: this.deltaPosition.y = Math.min(1, Math.max(-1, c)); break; case 2: this.deltaPosition.z = Math.min(1, Math.max(-1, c)) } var d = this.reverseUpDown ? 1 : -1, e = d * this._deltaJoystickVector.y / this._inversedSensibility; switch (this._axisTargetedByUpAndDown) { case 0: this.deltaPosition.x = Math.min(1, Math.max(-1, e)); break; case 1: this.deltaPosition.y = Math.min(1, Math.max(-1, e)); break; case 2: this.deltaPosition.z = Math.min(1, Math.max(-1, e)) } } else this._touches.item(a.pointerId.toString()) && (this._touches.item(a.pointerId.toString()).x = a.clientX, this._touches.item(a.pointerId.toString()).y = a.clientY) }, b.prototype._onPointerUp = function (a) { this._clearCanvas(), this._joystickPointerID == a.pointerId && (this._joystickPointerID = -1, this.pressed = !1), this._deltaJoystickVector.x = 0, this._deltaJoystickVector.y = 0, this._touches.remove(a.pointerId.toString()) }, b.prototype.setJoystickColor = function (a) { this._joystickColor = a }, b.prototype.setActionOnTouch = function (a) { this._action = a }, b.prototype.setAxisForLeftRight = function (a) { switch (a) { case 0: case 1: case 2: this._axisTargetedByLeftAndRight = a; break; default: this._axisTargetedByLeftAndRight = 0 } }, b.prototype.setAxisForUpDown = function (a) { switch (a) { case 0: case 1: case 2: this._axisTargetedByUpAndDown = a; break; default: this._axisTargetedByUpAndDown = 1 } }, b.prototype._clearCanvas = function () { this._leftJoystick ? b.vjCanvasContext.clearRect(0, 0, b.vjCanvasWidth / 2, b.vjCanvasHeight) : b.vjCanvasContext.clearRect(b.vjCanvasWidth / 2, 0, b.vjCanvasWidth, b.vjCanvasHeight) }, b.prototype._drawVirtualJoystick = function () { var a = this; this.pressed && (this._clearCanvas(), this._touches.forEach(function (c) { c.pointerId === a._joystickPointerID ? (b.vjCanvasContext.beginPath(), b.vjCanvasContext.strokeStyle = a._joystickColor, b.vjCanvasContext.lineWidth = 6, b.vjCanvasContext.arc(a._joystickPointerStartPos.x, a._joystickPointerStartPos.y, 40, 0, 2 * Math.PI, !0), b.vjCanvasContext.stroke(), b.vjCanvasContext.beginPath(), b.vjCanvasContext.strokeStyle = a._joystickColor, b.vjCanvasContext.lineWidth = 2, b.vjCanvasContext.arc(a._joystickPointerStartPos.x, a._joystickPointerStartPos.y, 60, 0, 2 * Math.PI, !0), b.vjCanvasContext.stroke(), b.vjCanvasContext.beginPath(), b.vjCanvasContext.strokeStyle = a._joystickColor, b.vjCanvasContext.arc(a._joystickPointerPos.x, a._joystickPointerPos.y, 40, 0, 2 * Math.PI, !0), b.vjCanvasContext.stroke()) : (b.vjCanvasContext.beginPath(), b.vjCanvasContext.fillStyle = "white", b.vjCanvasContext.beginPath(), b.vjCanvasContext.strokeStyle = "red", b.vjCanvasContext.lineWidth = 6, b.vjCanvasContext.arc(c.x, c.y, 40, 0, 2 * Math.PI, !0), b.vjCanvasContext.stroke()) })), requestAnimationFrame(function () { a._drawVirtualJoystick() }) }, b.prototype.releaseCanvas = function () { b.vjCanvas && (document.body.removeChild(b.vjCanvas), b.vjCanvas = null) }, b._globalJoystickIndex = 0, b }()); a.VirtualJoystick = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { !function (a) { var b = function () { function a() { this._count = 0, this._collection = new Array } return a.prototype.Count = function () { return this._count }, a.prototype.add = function (a, b) { return void 0 != this._collection[a] ? void 0 : (this._collection[a] = b, ++this._count) }, a.prototype.remove = function (a) { return void 0 == this._collection[a] ? void 0 : (delete this._collection[a], --this._count) }, a.prototype.item = function (a) { return this._collection[a] }, a.prototype.forEach = function (a) { var b; for (b in this._collection) this._collection.hasOwnProperty(b) && a(this._collection[b]) }, a }(); a.Collection = b }(a.VirtualJoystick || (a.VirtualJoystick = {})); a.VirtualJoystick }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { BABYLON.OculusOrientedCamera = function (a, b, c, d, e, f) { b = b ? new BABYLON.Vector3(b.x, b.y, b.z) : null, BABYLON.Camera.call(this, a, b, c), this._referenceDirection = new BABYLON.Vector3(0, 0, 1), this._referenceUp = new BABYLON.Vector3(0, 1, 0), this._actualDirection = new BABYLON.Vector3(1, 0, 0), this._actualUp = new BABYLON.Vector3(0, 1, 0), this._currentTargetPoint = new BABYLON.Vector3(0, 0, 0), this._currentOrientation = Object.create(f || { yaw: 0, pitch: 0, roll: 0 }), this._currentViewMatrix = new BABYLON.Matrix, this._currentOrientationMatrix = new BABYLON.Matrix, this._currentInvertOrientationMatrix = new BABYLON.Matrix, this._tempMatrix = new BABYLON.Matrix, this.viewport = d ? new BABYLON.Viewport(0, 0, .5, 1) : new BABYLON.Viewport(.5, 0, .5, 1), this._aspectRatioAspectRatio = e.HResolution / (2 * e.VResolution), this._aspectRatioFov = 2 * Math.atan(e.PostProcessScaleFactor * e.VScreenSize / (2 * e.EyeToScreenDistance)); var g = e.HScreenSize / 4 - e.LensSeparationDistance / 2, h = 4 * g / e.HScreenSize; this._hMatrix = BABYLON.Matrix.Translation(d ? h : -h, 0, 0), this._projectionMatrix = new BABYLON.Matrix, this._preViewMatrix = BABYLON.Matrix.Translation(d ? .5 * e.InterpupillaryDistance : -.5 * e.InterpupillaryDistance, 0, 0), new BABYLON.OculusDistortionCorrectionPostProcess("Oculus Distortion", this, !d, e), this.resetProjectionMatrix(), this.resetViewMatrix() }, BABYLON.OculusOrientedCamera.BuildOculusStereoCamera = function (a, b, c, d, e, f, g, h, i, j, k) { var l = a.getEngine().getRenderingCanvas(); e = e || BABYLON.Vector3.Zero(0, 0, 0), f = f || { yaw: 0, pitch: 0, roll: 0 }, k = k || BABYLON.OculusController.CameraSettings_OculusRiftDevKit2013_Metric; var m = new BABYLON.OculusOrientedCamera(b + "_left", e, a, !0, k, f); m.minZ = c, m.maxZ = d, g && new BABYLON.FxaaPostProcess("fxaa_left", 1, m); var n = new BABYLON.OculusOrientedCamera(b + "_right", e.clone(), a, !1, k, f); n.minZ = c, n.maxZ = d, g && new BABYLON.FxaaPostProcess("fxaa_right", 1, n), a.activeCameras = [], a.activeCameras.push(m), a.activeCameras.push(n), m.attachControl(l), n.attachControl(l); var o = new BABYLON.InputControllerMultiTarget([m, n]), p = new BABYLON.OculusController(a, o), q = o; if (!i) { var r = new BABYLON.InputCollisionFilter(a, o, j); q = r } if (!h) { { var s = new BABYLON.GlobalAxisFactorsFilter(a, q, 1, 0, 1); new BABYLON.GravityInputController(a, q) } q = s } var t = new BABYLON.KeyboardMoveController(a, q); t.attachToCanvas(l); var u = { leftCamera: m, rightCamera: n, intermediateControllerTarget: o, oculusController: p, keyboardController: t }; return u.dispose = function () { this.leftCamera.detachControl(l), this.rightCamera.detachControl(l), this.leftCamera.dispose(), this.rightCamera.dispose(), this.oculusController.dispose(), this.keyboardController.detachFromCanvas(l), this.keyboardController.dispose() }.bind(u), u }, BABYLON.OculusOrientedCamera.prototype = Object.create(BABYLON.Camera.prototype), BABYLON.OculusOrientedCamera.prototype.resetViewMatrix = function () { return BABYLON.Matrix.RotationYawPitchRollToRef(this._currentOrientation.yaw, this._currentOrientation.pitch, -this._currentOrientation.roll, this._currentOrientationMatrix), this._currentOrientationMatrix.invertToRef(this._currentInvertOrientationMatrix), BABYLON.Vector3.TransformNormalToRef(this._referenceDirection, this._currentOrientationMatrix, this._actualDirection), BABYLON.Vector3.TransformNormalToRef(this._referenceUp, this._currentOrientationMatrix, this._actualUp), BABYLON.Vector3.FromFloatsToRef(this.position.x + this._actualDirection.x, this.position.y + this._actualDirection.y, this.position.z + this._actualDirection.z, this._currentTargetPoint), BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTargetPoint, this._actualUp, this._tempMatrix), this._tempMatrix.multiplyToRef(this._preViewMatrix, this._currentViewMatrix), this._currentViewMatrix }, BABYLON.OculusOrientedCamera.prototype.getViewMatrix = function () { return this._currentViewMatrix }, BABYLON.OculusOrientedCamera.prototype._update = function () { if (this.controllers) for (var a = 0; a < this.controllers.length; ++a) this.controllers[a].update() }, BABYLON.OculusOrientedCamera.prototype.getOrientationMatrix = function () { return this._currentOrientationMatrix }, BABYLON.OculusOrientedCamera.prototype.getInvertOrientationMatrix = function () { return this._currentInvertOrientationMatrix }, BABYLON.OculusOrientedCamera.prototype.resetProjectionMatrix = function () { return BABYLON.Matrix.PerspectiveFovLHToRef(this._aspectRatioFov, this._aspectRatioAspectRatio, this.minZ, this.maxZ, this._tempMatrix), this._tempMatrix.multiplyToRef(this._hMatrix, this._projectionMatrix), this._projectionMatrix }, BABYLON.OculusOrientedCamera.prototype.getProjectionMatrix = function () { return this._projectionMatrix }, BABYLON.OculusOrientedCamera.prototype.getOrientation = function () { return this._currentOrientation }, BABYLON.OculusOrientedCamera.prototype.getPosition = function () { return this.position }, BABYLON.OculusOrientedCamera.prototype.moveRelative = function (a) { this._tempMoveVector || (this._tempMoveVector = new BABYLON.Vector3(0, 0, 0)), BABYLON.Vector3.TransformNormalToRef(a, this._currentOrientationMatrix, this._tempMoveVector), this.position.addInPlace(this._tempMoveVector), this.resetViewMatrix() }, BABYLON.OculusOrientedCamera.prototype.rotateRelative = function (a) { this._currentOrientation.yaw += a.yaw, this._currentOrientation.pitch += a.pitch, this._currentOrientation.roll += a.roll, this.resetViewMatrix() } }(); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e) { b.call(this, c, d, e), this._leftjoystick = new a.VirtualJoystick(!0), this._leftjoystick.setAxisForUpDown(2), this._leftjoystick.setAxisForLeftRight(0), this._leftjoystick.setJoystickSensibility(.15), this._rightjoystick = new a.VirtualJoystick(!1), this._rightjoystick.setAxisForUpDown(0), this._rightjoystick.setAxisForLeftRight(1), this._rightjoystick.reverseUpDown = !0, this._rightjoystick.setJoystickSensibility(.05), this._rightjoystick.setJoystickColor("yellow") } return __extends(c, b), c.prototype._checkInputs = function () { var b = a.Matrix.RotationYawPitchRoll(this.rotation.y, this.rotation.x, 0), c = a.Vector3.TransformCoordinates(this._leftjoystick.deltaPosition, b); this.cameraDirection = this.cameraDirection.add(c), this.cameraRotation = this.cameraRotation.add(this._rightjoystick.deltaPosition), this._leftjoystick.pressed || (this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(.9)), this._rightjoystick.pressed || (this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(.9)) }, c.prototype.dispose = function () { this._leftjoystick.releaseCanvas() }, c }(a.FreeCamera); a.VirtualJoysticksCamera = b }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { BABYLON.KeyboardMoveController = function (a, b) { BABYLON.InputController.call(this, a, b), this._keys = [], this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39], this._currentSpeed = new BABYLON.Vector3(0, 0, 0), this._lastFrameSpeed = new BABYLON.Vector3(0, 0, 0), this._currentAcceleration = new BABYLON.Vector3(0, 0, 0), this._tempSpeed = new BABYLON.Vector3(0, 0, 0), this._tempSpeed2 = new BABYLON.Vector3(0, 0, 0), this.maxAbsoluteSpeed = 2, this.maxAbsoluteAcceleration = 5, this._targetSpeed = new BABYLON.Vector3(0, 0, 0) }, BABYLON.KeyboardMoveController.prototype = Object.create(BABYLON.InputController.prototype), BABYLON.KeyboardMoveController.prototype.attachToCanvas = function (a) { var b = this; this._canvas = a, this._onKeyDown = function (a) { if (-1 !== b.keysUp.indexOf(a.keyCode) || -1 !== b.keysDown.indexOf(a.keyCode) || -1 !== b.keysLeft.indexOf(a.keyCode) || -1 !== b.keysRight.indexOf(a.keyCode)) { var c = b._keys.indexOf(a.keyCode); -1 === c && b._keys.push(a.keyCode) } }, this._onKeyUp = function (a) { if (-1 !== b.keysUp.indexOf(a.keyCode) || -1 !== b.keysDown.indexOf(a.keyCode) || -1 !== b.keysLeft.indexOf(a.keyCode) || -1 !== b.keysRight.indexOf(a.keyCode)) { var c = b._keys.indexOf(a.keyCode); c >= 0 && b._keys.splice(c, 1) } }, this._onLostFocus = function () { b._keys = [] }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("blur", this._onLostFocus, !1) }, BABYLON.KeyboardMoveController.prototype.detachFromCanvas = function () { window.removeEventListener("keydown", this._onKeyDown, !1), window.removeEventListener("keyup", this._onKeyUp, !1), window.removeEventListener("blur", this._onLostFocus, !1) }, BABYLON.KeyboardMoveController.prototype.updateCurrentSpeed = function () { if (this._lastFrameSpeed.x = this._currentSpeed.x, this._lastFrameSpeed.y = this._currentSpeed.y, this._lastFrameSpeed.z = this._currentSpeed.z, this._currentSpeed.equals(this._targetSpeed)) return this._currentAcceleration.x = 0, this._currentAcceleration.y = 0, void (this._currentAcceleration.z = 0); var a = BABYLON.Tools.GetDeltaTime() / 1e3, b = this._tempSpeed; this._targetSpeed.subtractToRef(this._lastFrameSpeed, b); var c = b.length() / a; c < this.maxAbsoluteAcceleration ? (this._currentSpeed.x = this._targetSpeed.x, this._currentSpeed.y = this._targetSpeed.y, this._currentSpeed.z = this._targetSpeed.z, b.normalize(), b.scaleToRef(c, this._currentAcceleration)) : (b.normalize(), b.scaleToRef(this.maxAbsoluteAcceleration, this._currentAcceleration), b.scaleInPlace(this.maxAbsoluteAcceleration * a), this._currentSpeed.addInPlace(b)) }, BABYLON.KeyboardMoveController.prototype.update = function () { this._targetSpeed.x = 0, this._targetSpeed.y = 0, this._targetSpeed.z = 0; for (var a = 0; a < this._keys.length; a++) { var b = this._keys[a]; -1 !== this.keysLeft.indexOf(b) ? this._targetSpeed.x -= 1 : -1 !== this.keysUp.indexOf(b) ? this._targetSpeed.z += 1 : -1 !== this.keysRight.indexOf(b) ? this._targetSpeed.x += 1 : -1 !== this.keysDown.indexOf(b) && (this._targetSpeed.z -= 1) } if ((0 != this._targetSpeed.x || 0 != this._targetSpeed.z) && (this._targetSpeed.normalize(), this._targetSpeed.scaleInPlace(this.maxAbsoluteSpeed)), this.updateCurrentSpeed(), 0 != this._lastFrameSpeed.x || 0 != this._lastFrameSpeed.z || 0 != this._currentAcceleration.x || 0 != this._currentAcceleration.z) { var c = BABYLON.Tools.GetDeltaTime() / 1e3; this._lastFrameSpeed.scaleToRef(c, this._tempSpeed), this._currentAcceleration.scaleToRef(c * c * .5, this._tempSpeed2), this._tempSpeed.addInPlace(this._tempSpeed2), (0 != this._tempSpeed.x || 0 != this._tempSpeed.z) && this.target.moveRelative(this._tempSpeed) } } }(); var BABYLON = BABYLON || {}; !function () { BABYLON.OculusController = function (a, b) { BABYLON.InputController.call(this, a, b), this._deviceOrientationHandler = this.onOrientationEvent.bind(this), this._tempOrientation = { yaw: 0, pitch: 0, roll: 0 }, this._relativeOrientation = { yaw: 0, pitch: 0, roll: 0 }, window.addEventListener("deviceorientation", this._deviceOrientationHandler) }, BABYLON.OculusController.prototype = Object.create(BABYLON.InputController.prototype), BABYLON.OculusController.prototype.onOrientationEvent = function (a) { if (this._tempOrientation.yaw = a.alpha / 180 * Math.PI, this._tempOrientation.pitch = a.beta / 180 * Math.PI, this._tempOrientation.roll = a.gamma / 180 * Math.PI, this._lastOrientation) { this._relativeOrientation.yaw = this._tempOrientation.yaw - this._lastOrientation.yaw, this._relativeOrientation.pitch = this._tempOrientation.pitch - this._lastOrientation.pitch, this._relativeOrientation.roll = this._tempOrientation.roll - this._lastOrientation.roll; var b = this._tempOrientation; this._tempOrientation = this._lastOrientation, this._lastOrientation = b, this.target.rotateRelative(this._relativeOrientation) } else this._lastOrientation = Object.create(this._tempOrientation) }, BABYLON.OculusController.prototype.dispose = function () { window.removeEventListener("deviceorientation", this._deviceOrientationHandler) }, BABYLON.OculusController.CameraSettings_OculusRiftDevKit2013_Metric = { HResolution: 1280, VResolution: 800, HScreenSize: .149759993, VScreenSize: .0935999975, VScreenCenter: .0467999987, EyeToScreenDistance: .0410000011, LensSeparationDistance: .063500002, InterpupillaryDistance: .064000003, DistortionK: [1, .219999999, .239999995, 0], ChromaAbCorrection: [.995999992, -.00400000019, 1.01400006, 0], PostProcessScaleFactor: 1.714605507808412, LensCenterOffset: .151976421 } }(); var BABYLON = BABYLON || {}; !function () { BABYLON.InputCollisionFilter = function (a, b, c) { BABYLON.inputFilter.call(this, a, b), this._transformedDirection = new BABYLON.Vector3, this._tempNewPosition = new BABYLON.Vector3, this._tempNewPosition2 = new BABYLON.Vector3, this._ellipsoid = c || new BABYLON.Vector3(.2, .855, .2), this._collider = new BABYLON.Collider, this._collidedPosition = new BABYLON.Vector3(0, 0, 0), this._cameraHeight = 1.7, this._positionBottom = new BABYLON.Vector3(0, 0, 0) }, BABYLON.InputCollisionFilter.prototype = Object.create(BABYLON.inputFilter.prototype), BABYLON.InputCollisionFilter.prototype.moveRelative = function (a) { this.getOrientation(); BABYLON.Vector3.TransformNormalToRef(a, this.getOrientationMatrix(), this._transformedDirection), this.getPosition().addToRef(this._transformedDirection, this._tempNewPosition), this._collider.radius = this._ellipsoid; var b = this.getPosition(); this._positionBottom.x = b.x, this._positionBottom.y = b.y, this._positionBottom.z = b.z, this._positionBottom.y += this._ellipsoid.y - this._cameraHeight, this.scene._getNewPosition(this._positionBottom, this._transformedDirection, this._collider, 3, this._collidedPosition), this._collidedPosition.subtractToRef(this._positionBottom, this._tempNewPosition2), this._tempNewPosition2.length() > 2 * BABYLON.Engine.collisionsEpsilon && (BABYLON.Vector3.TransformNormalToRef(this._tempNewPosition2, this.getInvertOrientationMatrix(), this._tempNewPosition), this.target.moveRelative(this._tempNewPosition)) } }(); var BABYLON = BABYLON || {}; !function () { BABYLON.GravityInputController = function (a, b) { BABYLON.InputController.call(this, a, b), this._moveVectorGlobal = new BABYLON.Vector3(0, 0, 0), this._moveVectorLocal = new BABYLON.Vector3(0, 0, 0), this._fallSpeed = 2 }, BABYLON.GravityInputController.prototype = Object.create(BABYLON.InputController.prototype), BABYLON.GravityInputController.prototype.update = function () { this._moveVectorGlobal.x = 0, this._moveVectorGlobal.y = -this._fallSpeed * BABYLON.Tools.GetDeltaTime() / 1e3, this._moveVectorGlobal.z = 0, BABYLON.Vector3.TransformNormalToRef(this._moveVectorGlobal, this.target.getInvertOrientationMatrix(), this._moveVectorLocal), this.target.moveRelative(this._moveVectorLocal) } }(); var BABYLON = BABYLON || {}; !function () { BABYLON.GlobalAxisFactorsFilter = function (a, b, c, d, e) { BABYLON.inputFilter.call(this, a, b), this.xFactor = c, this.yFactor = d, this.zFactor = e, this._globalMovement = new BABYLON.Vector3(0, 0, 0) }, BABYLON.GlobalAxisFactorsFilter.prototype = Object.create(BABYLON.inputFilter.prototype), BABYLON.GlobalAxisFactorsFilter.prototype.moveRelative = function (a) { this.getOrientation(); BABYLON.Vector3.TransformNormalToRef(a, this.getOrientationMatrix(), this._globalMovement), this._globalMovement.x *= this.xFactor, this._globalMovement.y *= this.yFactor, this._globalMovement.z *= this.zFactor, BABYLON.Vector3.TransformNormalToRef(this._globalMovement, this.getInvertOrientationMatrix(), a), this.target.moveRelative(a) } }(); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(c, d, e, f) { b.call(this, c, d), this._textures = new Array, this._floats = new Array, this._floatsArrays = {}, this._colors3 = new Array, this._colors4 = new Array, this._vectors2 = new Array, this._vectors3 = new Array, this._matrices = new Array, this._cachedWorldViewMatrix = new a.Matrix, this._shaderPath = e, f.needAlphaBlending = f.needAlphaBlending || !1, f.needAlphaTesting = f.needAlphaTesting || !1, f.attributes = f.attributes || ["position", "normal", "uv"], f.uniforms = f.uniforms || ["worldViewProjection"], f.samplers = f.samplers || [], this._options = f } return __extends(c, b), c.prototype.needAlphaBlending = function () { return this._options.needAlphaBlending }, c.prototype.needAlphaTesting = function () { return this._options.needAlphaTesting }, c.prototype._checkUniform = function (a) { -1 === this._options.uniforms.indexOf(a) && this._options.uniforms.push(a) }, c.prototype.setTexture = function (a, b) { return -1 === this._options.samplers.indexOf(a) && this._options.samplers.push(a), this._textures[a] = b, this }, c.prototype.setFloat = function (a, b) { return this._checkUniform(a), this._floats[a] = b, this }, c.prototype.setFloats = function (a, b) { return this._checkUniform(a), this._floatsArrays[a] = b, this }, c.prototype.setColor3 = function (a, b) { return this._checkUniform(a), this._colors3[a] = b, this }, c.prototype.setColor4 = function (a, b) { return this._checkUniform(a), this._colors4[a] = b, this }, c.prototype.setVector2 = function (a, b) { return this._checkUniform(a), this._vectors2[a] = b, this }, c.prototype.setVector3 = function (a, b) { return this._checkUniform(a), this._vectors3[a] = b, this }, c.prototype.setMatrix = function (a, b) { return this._checkUniform(a), this._matrices[a] = b, this }, c.prototype.isReady = function () { var a = this.getScene().getEngine(); return this._effect = a.createEffect(this._shaderPath, this._options.attributes, this._options.uniforms, this._options.samplers, "", null, this.onCompiled, this.onError), this._effect.isReady() ? !0 : !1 }, c.prototype.bind = function (a) { -1 !== this._options.uniforms.indexOf("world") && this._effect.setMatrix("world", a), -1 !== this._options.uniforms.indexOf("view") && this._effect.setMatrix("view", this.getScene().getViewMatrix()), -1 !== this._options.uniforms.indexOf("worldView") && (a.multiplyToRef(this.getScene().getViewMatrix(), this._cachedWorldViewMatrix), this._effect.setMatrix("worldView", this._cachedWorldViewMatrix)), -1 !== this._options.uniforms.indexOf("projection") && this._effect.setMatrix("projection", this.getScene().getProjectionMatrix()), -1 !== this._options.uniforms.indexOf("worldViewProjection") && this._effect.setMatrix("worldViewProjection", a.multiply(this.getScene().getTransformMatrix())); for (var b in this._textures) this._effect.setTexture(b, this._textures[b]); for (b in this._floats) this._effect.setFloat(b, this._floats[b]); for (b in this._floatsArrays) this._effect.setArray(b, this._floatsArrays[b]); for (b in this._colors3) this._effect.setColor3(b, this._colors3[b]); for (b in this._colors4) { var c = this._colors4[b]; this._effect.setFloat4(b, c.r, c.g, c.b, c.a) } for (b in this._vectors2) this._effect.setVector2(b, this._vectors2[b]); for (b in this._vectors3) this._effect.setVector3(b, this._vectors3[b]); for (b in this._matrices) this._effect.setMatrix(b, this._matrices[b]) }, c.prototype.dispose = function (a) { for (var c in this._textures) this._textures[c].dispose(); this._textures = [], b.prototype.dispose.call(this, a) }, c }(a.Material); a.ShaderMaterial = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function () {
		function b() { } return b.prototype.set = function (b, c) { switch (c) { case a.VertexBuffer.PositionKind: this.positions = b; break; case a.VertexBuffer.NormalKind: this.normals = b; break; case a.VertexBuffer.UVKind: this.uvs = b; break; case a.VertexBuffer.UV2Kind: this.uv2s = b; break; case a.VertexBuffer.ColorKind: this.colors = b; break; case a.VertexBuffer.MatricesIndicesKind: this.matricesIndices = b; break; case a.VertexBuffer.MatricesWeightsKind: this.matricesWeights = b } }, b.prototype.applyToMesh = function (a, b) { this._applyTo(a, b) }, b.prototype.applyToGeometry = function (a, b) { this._applyTo(a, b) }, b.prototype._applyTo = function (b, c) { this.positions && b.setVerticesData(this.positions, a.VertexBuffer.PositionKind, c), this.normals && b.setVerticesData(this.normals, a.VertexBuffer.NormalKind, c), this.uvs && b.setVerticesData(this.uvs, a.VertexBuffer.UVKind, c), this.uv2s && b.setVerticesData(this.uv2s, a.VertexBuffer.UV2Kind, c), this.colors && b.setVerticesData(this.colors, a.VertexBuffer.ColorKind, c), this.matricesIndices && b.setVerticesData(this.matricesIndices, a.VertexBuffer.MatricesIndicesKind, c), this.matricesWeights && b.setVerticesData(this.matricesWeights, a.VertexBuffer.MatricesWeightsKind, c), this.indices && b.setIndices(this.indices) }, b.prototype.transform = function (b) { var c = a.Vector3.Zero(); if (this.positions) for (var d = a.Vector3.Zero(), e = 0; e < this.positions.length; e += 3) a.Vector3.FromArrayToRef(this.positions, e, d), a.Vector3.TransformCoordinatesToRef(d, b, c), this.positions[e] = c.x, this.positions[e + 1] = c.y, this.positions[e + 2] = c.z; if (this.normals) { var f = a.Vector3.Zero(); for (e = 0; e < this.normals.length; e += 3) a.Vector3.FromArrayToRef(this.normals, e, f), a.Vector3.TransformNormalToRef(f, b, c), this.normals[e] = c.x, this.normals[e + 1] = c.y, this.normals[e + 2] = c.z } }, b.prototype.merge = function (a) {
			if (a.indices) {
				this.indices || (this.indices = []); for (var b = this.positions ? this.positions.length / 3 : 0, c = 0; c < a.indices.length; c++) this.indices.push(a.indices[c] + b)
			} if (a.positions) for (this.positions || (this.positions = []), c = 0; c < a.positions.length; c++) this.positions.push(a.positions[c]); if (a.normals) for (this.normals || (this.normals = []), c = 0; c < a.normals.length; c++) this.normals.push(a.normals[c]); if (a.uvs) for (this.uvs || (this.uvs = []), c = 0; c < a.uvs.length; c++) this.uvs.push(a.uvs[c]); if (a.uv2s) for (this.uv2s || (this.uv2s = []), c = 0; c < a.uv2s.length; c++) this.uv2s.push(a.uv2s[c]); if (a.matricesIndices) for (this.matricesIndices || (this.matricesIndices = []), c = 0; c < a.matricesIndices.length; c++) this.matricesIndices.push(a.matricesIndices[c]); if (a.matricesWeights) for (this.matricesWeights || (this.matricesWeights = []), c = 0; c < a.matricesWeights.length; c++) this.matricesWeights.push(a.matricesWeights[c]); if (a.colors) for (this.colors || (this.colors = []), c = 0; c < a.colors.length; c++) this.colors.push(a.colors[c])
		}, b.ExtractFromMesh = function (a) { return b._ExtractFrom(a) }, b.ExtractFromGeometry = function (a) { return b._ExtractFrom(a) }, b._ExtractFrom = function (b) { var c = new a.VertexData; return b.isVerticesDataPresent(a.VertexBuffer.PositionKind) && (c.positions = b.getVerticesData(a.VertexBuffer.PositionKind)), b.isVerticesDataPresent(a.VertexBuffer.NormalKind) && (c.normals = b.getVerticesData(a.VertexBuffer.NormalKind)), b.isVerticesDataPresent(a.VertexBuffer.UVKind) && (c.uvs = b.getVerticesData(a.VertexBuffer.UVKind)), b.isVerticesDataPresent(a.VertexBuffer.UV2Kind) && (c.uv2s = b.getVerticesData(a.VertexBuffer.UV2Kind)), b.isVerticesDataPresent(a.VertexBuffer.ColorKind) && (c.colors = b.getVerticesData(a.VertexBuffer.ColorKind)), b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind) && (c.matricesIndices = b.getVerticesData(a.VertexBuffer.MatricesIndicesKind)), b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind) && (c.matricesWeights = b.getVerticesData(a.VertexBuffer.MatricesWeightsKind)), c.indices = b.getIndices(), c }, b.CreateBox = function (b) { var c = [new a.Vector3(0, 0, 1), new a.Vector3(0, 0, -1), new a.Vector3(1, 0, 0), new a.Vector3(-1, 0, 0), new a.Vector3(0, 1, 0), new a.Vector3(0, -1, 0)], d = [], e = [], f = [], g = []; b = b || 1; for (var h = 0; h < c.length; h++) { var i = c[h], j = new a.Vector3(i.y, i.z, i.x), k = a.Vector3.Cross(i, j), l = e.length / 3; d.push(l), d.push(l + 1), d.push(l + 2), d.push(l), d.push(l + 2), d.push(l + 3); var m = i.subtract(j).subtract(k).scale(b / 2); e.push(m.x, m.y, m.z), f.push(i.x, i.y, i.z), g.push(1, 1), m = i.subtract(j).add(k).scale(b / 2), e.push(m.x, m.y, m.z), f.push(i.x, i.y, i.z), g.push(0, 1), m = i.add(j).add(k).scale(b / 2), e.push(m.x, m.y, m.z), f.push(i.x, i.y, i.z), g.push(0, 0), m = i.add(j).subtract(k).scale(b / 2), e.push(m.x, m.y, m.z), f.push(i.x, i.y, i.z), g.push(1, 0) } var n = new a.VertexData; return n.indices = d, n.positions = e, n.normals = f, n.uvs = g, n }, b.CreateSphere = function (b, c) { b = b || 32, c = c || 1; for (var d = c / 2, e = 2 + b, f = 2 * e, g = [], h = [], i = [], j = [], k = 0; e >= k; k++) { for (var l = k / e, m = l * Math.PI, n = 0; f >= n; n++) { var o = n / f, p = o * Math.PI * 2, q = a.Matrix.RotationZ(-m), r = a.Matrix.RotationY(p), s = a.Vector3.TransformCoordinates(a.Vector3.Up(), q), t = a.Vector3.TransformCoordinates(s, r), u = t.scale(d), v = a.Vector3.Normalize(u); h.push(u.x, u.y, u.z), i.push(v.x, v.y, v.z), j.push(l, o) } if (k > 0) for (var w = h.length / 3, x = w - 2 * (f + 1) ; w > x + f + 2; x++) g.push(x), g.push(x + 1), g.push(x + f + 1), g.push(x + f + 1), g.push(x + 1), g.push(x + f + 2) } var y = new a.VertexData; return y.indices = g, y.positions = h, y.normals = i, y.uvs = j, y }, b.CreateCylinder = function (b, c, d, e) { var f = c / 2, g = d / 2, h = [], i = [], j = [], k = []; b = b || 1, c = c || .5, d = d || 1, e = e || 16; var l = function (b) { var c = 2 * b * Math.PI / e, d = Math.sin(c), f = Math.cos(c); return new a.Vector3(d, 0, f) }, m = function (c) { var d = c ? f : g; if (0 != d) { for (var m = 0; e - 2 > m; m++) { var n = (m + 1) % e, o = (m + 2) % e; if (!c) { var p = n; n = o, o = p } var q = i.length / 3; h.push(q), h.push(q + n), h.push(q + o) } var r = new a.Vector3(0, -1, 0), s = new a.Vector2(-.5, -.5); for (c || (r = r.scale(-1), s.x = -s.x), m = 0; e > m; m++) { var t = l(m), u = t.scale(d).add(r.scale(b)), v = new a.Vector2(t.x * s.x + .5, t.z * s.y + .5); i.push(u.x, u.y, u.z), j.push(r.x, r.y, r.z), k.push(v.x, v.y) } } }; b /= 2; for (var n = new a.Vector3(0, 1, 0).scale(b), o = e + 1, p = 0; e >= p; p++) { var q = l(p), r = q.scale(g), s = q.scale(f), t = new a.Vector2(p / e, 0), u = r.add(n); i.push(u.x, u.y, u.z), j.push(q.x, q.y, q.z), k.push(t.x, t.y), u = s.subtract(n), t.y += 1, i.push(u.x, u.y, u.z), j.push(q.x, q.y, q.z), k.push(t.x, t.y), h.push(2 * p), h.push((2 * p + 2) % (2 * o)), h.push(2 * p + 1), h.push(2 * p + 1), h.push((2 * p + 2) % (2 * o)), h.push((2 * p + 3) % (2 * o)) } m(!0), m(!1); var v = new a.VertexData; return v.indices = h, v.positions = i, v.normals = j, v.uvs = k, v }, b.CreateTorus = function (b, c, d) { var e = [], f = [], g = [], h = []; b = b || 1, c = c || .5, d = d || 16; for (var i = d + 1, j = 0; d >= j; j++) for (var k = j / d, l = j * Math.PI * 2 / d - Math.PI / 2, m = a.Matrix.Translation(b / 2, 0, 0).multiply(a.Matrix.RotationY(l)), n = 0; d >= n; n++) { var o = 1 - n / d, p = n * Math.PI * 2 / d + Math.PI, q = Math.cos(p), r = Math.sin(p), s = new a.Vector3(q, r, 0), t = s.scale(c / 2), u = new a.Vector2(k, o); t = a.Vector3.TransformCoordinates(t, m), s = a.Vector3.TransformNormal(s, m), f.push(t.x, t.y, t.z), g.push(s.x, s.y, s.z), h.push(u.x, u.y); var v = (j + 1) % i, w = (n + 1) % i; e.push(j * i + n), e.push(j * i + w), e.push(v * i + n), e.push(j * i + w), e.push(v * i + w), e.push(v * i + n) } var x = new a.VertexData; return x.indices = e, x.positions = f, x.normals = g, x.uvs = h, x }, b.CreateGround = function (b, c, d) { var e, f, g = [], h = [], i = [], j = []; for (b = b || 1, c = c || 1, d = d || 1, e = 0; d >= e; e++) for (f = 0; d >= f; f++) { var k = new a.Vector3(f * b / d - b / 2, 0, (d - e) * c / d - c / 2), l = new a.Vector3(0, 1, 0); h.push(k.x, k.y, k.z), i.push(l.x, l.y, l.z), j.push(f / d, 1 - e / d) } for (e = 0; d > e; e++) for (f = 0; d > f; f++) g.push(f + 1 + (e + 1) * (d + 1)), g.push(f + 1 + e * (d + 1)), g.push(f + e * (d + 1)), g.push(f + (e + 1) * (d + 1)), g.push(f + 1 + (e + 1) * (d + 1)), g.push(f + e * (d + 1)); var m = new a.VertexData; return m.indices = g, m.positions = h, m.normals = i, m.uvs = j, m }, b.CreateGroundFromHeightMap = function (b, c, d, e, f, g, h, i) { var j, k, l = [], m = [], n = [], o = []; for (j = 0; d >= j; j++) for (k = 0; d >= k; k++) { var p = new a.Vector3(k * b / d - b / 2, 0, (d - j) * c / d - c / 2), q = (p.x + b / 2) / b * (h - 1) | 0, r = (1 - (p.z + c / 2) / c) * (i - 1) | 0, s = 4 * (q + r * h), t = g[s] / 255, u = g[s + 1] / 255, v = g[s + 2] / 255, w = .3 * t + .59 * u + .11 * v; p.y = e + (f - e) * w, m.push(p.x, p.y, p.z), n.push(0, 0, 0), o.push(k / d, 1 - j / d) } for (j = 0; d > j; j++) for (k = 0; d > k; k++) l.push(k + 1 + (j + 1) * (d + 1)), l.push(k + 1 + j * (d + 1)), l.push(k + j * (d + 1)), l.push(k + (j + 1) * (d + 1)), l.push(k + 1 + (j + 1) * (d + 1)), l.push(k + j * (d + 1)); a.VertexData.ComputeNormals(m, l, n); var x = new a.VertexData; return x.indices = l, x.positions = m, x.normals = n, x.uvs = o, x }, b.CreatePlane = function (b) { var c = [], d = [], e = [], f = []; b = b || 1; var g = b / 2; d.push(-g, -g, 0), e.push(0, 0, -1), f.push(0, 0), d.push(g, -g, 0), e.push(0, 0, -1), f.push(1, 0), d.push(g, g, 0), e.push(0, 0, -1), f.push(1, 1), d.push(-g, g, 0), e.push(0, 0, -1), f.push(0, 1), c.push(0), c.push(1), c.push(2), c.push(0), c.push(2), c.push(3); var h = new a.VertexData; return h.indices = c, h.positions = d, h.normals = e, h.uvs = f, h }, b.CreateTorusKnot = function (b, c, d, e, f, g) { var h = [], i = [], j = [], k = []; b = b || 2, c = c || .5, d = d || 32, e = e || 32, f = f || 2, g = g || 3; for (var l = function (c) { var d = Math.cos(c), e = Math.sin(c), h = g / f * c, i = Math.cos(h), j = b * (2 + i) * .5 * d, k = b * (2 + i) * e * .5, l = b * Math.sin(h) * .5; return new a.Vector3(j, k, l) }, m = 0; d >= m; m++) { var n = m % d, o = n / d * 2 * f * Math.PI, p = l(o), q = l(o + .01), r = q.subtract(p), s = q.add(p), t = a.Vector3.Cross(r, s); s = a.Vector3.Cross(t, r), t.normalize(), s.normalize(); for (var u = 0; e > u; u++) { var v = u % e, w = v / e * 2 * Math.PI, x = -c * Math.cos(w), y = c * Math.sin(w); i.push(p.x + x * s.x + y * t.x), i.push(p.y + x * s.y + y * t.y), i.push(p.z + x * s.z + y * t.z), k.push(m / d), k.push(u / e) } } for (m = 0; d > m; m++) for (u = 0; e > u; u++) { var z = (u + 1) % e, A = m * e + u, B = (m + 1) * e + u, C = (m + 1) * e + z, D = m * e + z; h.push(D), h.push(B), h.push(A), h.push(D), h.push(C), h.push(B) } a.VertexData.ComputeNormals(i, h, j); var E = new a.VertexData; return E.indices = h, E.positions = i, E.normals = j, E.uvs = k, E }, b.ComputeNormals = function (b, c, d) { var e, f = [], g = []; for (e = 0; e < b.length; e += 3) { var h = new a.Vector3(b[e], b[e + 1], b[e + 2]); f.push(h), g.push([]) } var i = []; for (e = 0; e < c.length / 3; e++) { var j = c[3 * e], k = c[3 * e + 1], l = c[3 * e + 2], m = f[j], n = f[k], o = f[l], p = m.subtract(n), q = o.subtract(n); i[e] = a.Vector3.Normalize(a.Vector3.Cross(p, q)), g[j].push(e), g[k].push(e), g[l].push(e) } for (e = 0; e < f.length; e++) { for (var r = g[e], s = a.Vector3.Zero(), t = 0; t < r.length; t++) s.addInPlace(i[r[t]]); s = a.Vector3.Normalize(s.scale(1 / r.length)), d[3 * e] = s.x, d[3 * e + 1] = s.y, d[3 * e + 2] = s.z } }, b
	}(); a.VertexData = b
}(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b, c) { b._leftCamera.isIntermediate = !0, b.subCameras.push(b._leftCamera), b.subCameras.push(b._rightCamera), b._leftTexture = new a.PassPostProcess(c + "_leftTexture", 1, b._leftCamera), b._anaglyphPostProcess = new a.AnaglyphPostProcess(c + "_anaglyph", 1, b._rightCamera), b._anaglyphPostProcess.onApply = function (a) { a.setTextureFromPostProcess("leftSampler", b._leftTexture) }, b._update() }, c = function (c) { function d(d, e, f, g, h, i, j) { c.call(this, d, e, f, g, h, j), this._eyeSpace = a.Tools.ToRadians(i), this._leftCamera = new a.ArcRotateCamera(d + "_left", e - this._eyeSpace, f, g, h, j), this._rightCamera = new a.ArcRotateCamera(d + "_right", e + this._eyeSpace, f, g, h, j), b(this, d) } return __extends(d, c), d.prototype._update = function () { this._updateCamera(this._leftCamera), this._updateCamera(this._rightCamera), this._leftCamera.alpha = this.alpha - this._eyeSpace, this._rightCamera.alpha = this.alpha + this._eyeSpace, c.prototype._update.call(this) }, d.prototype._updateCamera = function (a) { a.beta = this.beta, a.radius = this.radius, a.minZ = this.minZ, a.maxZ = this.maxZ, a.fov = this.fov, a.target = this.target }, d }(a.ArcRotateCamera); a.AnaglyphArcRotateCamera = c; var d = function (c) { function d(d, e, f, g) { c.call(this, d, e, g), this._eyeSpace = a.Tools.ToRadians(f), this._transformMatrix = new a.Matrix, this._leftCamera = new a.FreeCamera(d + "_left", e.clone(), g), this._rightCamera = new a.FreeCamera(d + "_right", e.clone(), g), b(this, d) } return __extends(d, c), d.prototype._getSubCameraPosition = function (b, c) { var d = this.getTarget(); a.Matrix.Translation(-d.x, -d.y, -d.z).multiplyToRef(a.Matrix.RotationY(b), this._transformMatrix), this._transformMatrix = this._transformMatrix.multiply(a.Matrix.Translation(d.x, d.y, d.z)), a.Vector3.TransformCoordinatesToRef(this.position, this._transformMatrix, c) }, d.prototype._update = function () { this._getSubCameraPosition(-this._eyeSpace, this._leftCamera.position), this._getSubCameraPosition(this._eyeSpace, this._rightCamera.position), this._updateCamera(this._leftCamera), this._updateCamera(this._rightCamera), c.prototype._update.call(this) }, d.prototype._updateCamera = function (a) { a.minZ = this.minZ, a.maxZ = this.maxZ, a.fov = this.fov, a.viewport = this.viewport, a.setTarget(this.getTarget()) }, d }(a.FreeCamera); a.AnaglyphFreeCamera = d }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g) { a.call(this, b, "anaglyph", null, ["leftSampler"], c, d, e, f, g) } return __extends(b, a), b }(a.PostProcess); a.AnaglyphPostProcess = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b() { } return b.EnableFor = function (a) { a._tags = a._tags || {}, a.hasTags = function () { return b.HasTags(a) }, a.addTags = function (c) { return b.AddTagsTo(a, c) }, a.removeTags = function (c) { return b.RemoveTagsFrom(a, c) }, a.matchesTagsQuery = function (c) { return b.MatchesQuery(a, c) } }, b.DisableFor = function (a) { delete a._tags, delete a.hasTags, delete a.addTags, delete a.removeTags, delete a.matchesTagsQuery }, b.HasTags = function (b) { return b._tags ? !a.Tools.IsEmpty(b._tags) : !1 }, b.GetTags = function (a) { return a._tags ? a._tags : null }, b.AddTagsTo = function (a, c) { if (c) { var d = c.split(" "); for (var e in d) b._AddTagTo(a, d[e]) } }, b._AddTagTo = function (a, c) { c = c.trim(), "" !== c && "true" !== c && "false" !== c && (c.match(/[\s]/) || c.match(/^([!]|([|]|[&]){2})/) || (b.EnableFor(a), a._tags[c] = !0)) }, b.RemoveTagsFrom = function (a, c) { if (b.HasTags(a)) { var d = c.split(" "); for (var e in d) b._RemoveTagFrom(a, d[e]) } }, b._RemoveTagFrom = function (a, b) { delete a._tags[b] }, b.MatchesQuery = function (c, d) { return void 0 === d ? !0 : "" === d ? b.HasTags(c) : a.Internals.AndOrNotEvaluator.Eval(d, function (a) { return b.HasTags(c) && c._tags[a] }) }, b }(); a.Tags = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { !function (a) { var b = function () { function a() { } return a.Eval = function (b, c) { return b = b.match(/\([^\(\)]*\)/g) ? b.replace(/\([^\(\)]*\)/g, function (b) { return b = b.slice(1, b.length - 1), a._HandleParenthesisContent(b, c) }) : a._HandleParenthesisContent(b, c), "true" === b ? !0 : "false" === b ? !1 : a.Eval(b, c) }, a._HandleParenthesisContent = function (b, c) { c = c || function (a) { return "true" === a ? !0 : !1 }; var d, e = b.split("||"); for (var f in e) { var g = a._SimplifyNegation(e[f].trim()), h = g.split("&&"); if (h.length > 1) for (var i = 0; i < h.length; ++i) { var j = a._SimplifyNegation(h[i].trim()); if (d = "true" !== j && "false" !== j ? "!" === j[0] ? !c(j.substring(1)) : c(j) : "true" === j ? !0 : !1, !d) { g = "false"; break } } if (d || "true" === g) { d = !0; break } d = "true" !== g && "false" !== g ? "!" === g[0] ? !c(g.substring(1)) : c(g) : "true" === g ? !0 : !1 } return d ? "true" : "false" }, a._SimplifyNegation = function (a) { return a = a.replace(/^[\s!]+/, function (a) { return a = a.replace(/[\s]/g, function () { return "" }), a.length % 2 ? "!" : "" }), a = a.trim(), "!true" === a ? a = "false" : "!false" === a && (a = "true"), a }, a }(); a.AndOrNotEvaluator = b }(a.Internals || (a.Internals = {})); a.Internals }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b, c, d, e, f, g) { this.name = c, this._enabled = !0, this._refCount = 0, this._renderTexture = new a.RenderTargetTexture(c, d, b), this.setRenderList(e), this._renderTexture.onBeforeRender = f, this._renderTexture.onAfterRender = g, this._scene = b } return b.prototype.incRefCount = function () { return 0 == this._refCount && this._scene.customRenderTargets.push(this._renderTexture), ++this._refCount }, b.prototype.decRefCount = function () { return this._refCount--, this._refCount <= 0 && this._scene.customRenderTargets.splice(this._scene.customRenderTargets.indexOf(this._renderTexture), 1), this._refCount }, b.prototype.setRenderList = function (a) { this._renderTexture.renderList = a }, b.prototype.getRenderTexture = function () { return this._renderTexture }, b.prototype._update = function () { this.setRenderList(this._renderList) }, b }(); a.PostProcessRenderPass = b }(BABYLON || (BABYLON = {})); var BABYLON = BABYLON || {}; !function () { BABYLON.PostProcessRenderEffect = function (a, b, c, d, e, f) { this._engine = a, this._name = b, this._singleInstance = f || !0, this._postProcesses = [], this._postProcessType = c, this._ratio = d || 1, this._samplingMode = e || null, this._cameras = [], this._indicesForCamera = [], this._renderPasses = [], this._renderEffectAsPasses = [], this.parameters = function () { } }, BABYLON.PostProcessRenderEffect.prototype.addPass = function (a) { this._renderPasses[a._name] = a, this._linkParameters() }, BABYLON.PostProcessRenderEffect.prototype.removePass = function (a) { delete this._renderPasses[a._name], this._linkParameters() }, BABYLON.PostProcessRenderEffect.prototype.addRenderEffectAsPass = function (a) { this._renderEffectAsPasses[a._name] = a, this._linkParameters() }, BABYLON.PostProcessRenderEffect.prototype.getPass = function (a) { for (var b in this._renderPasses) if (b == a) return this._renderPasses[a] }, BABYLON.PostProcessRenderEffect.prototype.emptyPasses = function () { this._renderPasses.length = 0, this._linkParameters() }, BABYLON.PostProcessRenderEffect.prototype.attachCameras = function (a) { var b = null; a = BABYLON.Tools.MakeArray(a || this._cameras); for (var c = 0; c < a.length; c++) { this._singleInstance ? (b = this._postProcesses[0] || BABYLON.PostProcessRenderEffect.getInstance(this._engine, this._postProcessType, this._ratio, this._samplingMode), this._postProcesses[0] = b) : (b = this._postProcesses[a[c]] || BABYLON.PostProcessRenderEffect.getInstance(this._engine, this._postProcessType, this._ratio, this._samplingMode), this._postProcesses[a[c].name] = b); var d = a[c].attachPostProcess(b); null == this._indicesForCamera[a[c].name] && (this._indicesForCamera[a[c].name] = []), this._indicesForCamera[a[c].name].push(d), -1 == this._cameras.indexOf(a[c].name) && this._cameras.push(a[c].name); for (var e in this._renderPasses) this._renderPasses[e].incRefCount() } this._linkParameters() }, BABYLON.PostProcessRenderEffect.prototype.detachCameras = function (a) { a = BABYLON.Tools.MakeArray(a || this._cameras); for (var b = 0; b < a.length; b++) { this._singleInstance ? a[b].detachPostProcess(this._postProcesses[0], this._indicesForCamera[a[b].name]) : a[b].detachPostProcess(this._postProcesses[a[b].name], this._indicesForCamera[a[b].name]), this._indicesForCamera.splice(a[b].name, 1), this._cameras.splice(this._cameras.indexOf(a[b].name), 1); for (var c in this._renderPasses) this._renderPasses[c].decRefCount() } }, BABYLON.PostProcessRenderEffect.prototype._linkParameters = function () { var a = this; for (var b in this._postProcesses) this._postProcesses[b].onApply = function (b) { a.parameters(b), a._linkTextures(b) } }, BABYLON.PostProcessRenderEffect.prototype._linkTextures = function (a) { for (var b in this._renderPasses) a.setTexture(b, this._renderPasses[b].getRenderTexture()); for (var c in this._renderEffectAsPasses) a.setTextureFromPostProcess(c + "Sampler", this._renderEffectAsPasses[c].getPostProcess()) }, BABYLON.PostProcessRenderEffect.prototype._update = function () { for (var a in this._renderPasses) this._renderPasses[a]._update() }, BABYLON.PostProcessRenderEffect.prototype.enable = function (a) { a = BABYLON.Tools.MakeArray(a || this._cameras); for (var b = 0; b < a.length; b++) { for (var c = 0; c < this._indicesForCamera[a[b].name].length; c++) void 0 === a[b]._postProcesses[this._indicesForCamera[a[b].name][c]] && (this._singleInstance ? a[b].attachPostProcess(this._postProcesses[0], this._indicesForCamera[a[b].name][c]) : a[b].attachPostProcess(this._postProcesses[a[b].name], this._indicesForCamera[a[b].name][c])); for (var d in this._renderPasses) this._renderPasses[d].incRefCount() } }, BABYLON.PostProcessRenderEffect.prototype.disable = function (a) { a = BABYLON.Tools.MakeArray(a || this._cameras); for (var b = 0; b < a.length; b++) { this._singleInstance ? a[b].detachPostProcess(this._postProcesses[0], this._indicesForCamera[a[b].name]) : a[b].detachPostProcess(this._postProcesses[a[b].name], this._indicesForCamera[a[b].name]); for (var c in this._renderPasses) this._renderPasses[c].decRefCount() } }, BABYLON.PostProcessRenderEffect.prototype.getPostProcess = function () { return this._postProcess }, BABYLON.PostProcessRenderEffect.getInstance = function (a, b, c, d) { for (var e, f, g = new Array, h = BABYLON.PostProcessRenderEffect.getParametersNames(b), i = 0; i < h.length; i++) switch (h[i]) { case "name": g[i] = b.toString(); break; case "ratio": g[i] = c; break; case "camera": g[i] = null; break; case "samplingMode": g[i] = d; break; case "engine": g[i] = a; break; case "reusable": g[i] = !0; break; default: g[i] = null } return e = function () { }, e.prototype = b.prototype, f = new e, b.apply(f, g), f }, BABYLON.PostProcessRenderEffect.getParametersNames = function (func) { var commentsRegex = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, functWithoutComments = eval(func).toString().replace(commentsRegex, ""), parameters = functWithoutComments.slice(functWithoutComments.indexOf("(") + 1, functWithoutComments.indexOf(")")).match(/([^\s,]+)/g); return null === parameters && (parameters = []), parameters } }(); var BABYLON = BABYLON || {}; !function () { BABYLON.PostProcessRenderPipeline = function (a, b) { this._engine = a, this._name = b, this._renderEffects = [], this._renderEffectsPasses = [], this._cameras = [] }, BABYLON.PostProcessRenderPipeline.prototype.addEffect = function (a) { this._renderEffects[a._name] = a }, BABYLON.PostProcessRenderPipeline.prototype.enableEffect = function (a, b) { b = BABYLON.Tools.MakeArray(b || this._cameras); var c = this._renderEffects[a]; c && c.enable(b) }, BABYLON.PostProcessRenderPipeline.prototype.disableEffect = function (a, b) { b = BABYLON.Tools.MakeArray(b || this._cameras); var c = this._renderEffects[a]; c && c.disable(b) }, BABYLON.PostProcessRenderPipeline.prototype.attachCameras = function (a, b) { a = BABYLON.Tools.MakeArray(a || this._cameras); for (var c = [], d = 0; d < a.length; d++) -1 == this._cameras.indexOf(a[d]) ? this._cameras.push(a[d]) : b && c.push(d); for (var d = 0; d < c.length; d++) a.splice(c[d], 1); for (var e in this._renderEffects) this._renderEffects[e].attachCameras(a) }, BABYLON.PostProcessRenderPipeline.prototype.detachCameras = function (a) { a = BABYLON.Tools.MakeArray(a || this._cameras); for (var b in this._renderEffects) this._renderEffects[b].detachCameras(a); for (var c = 0; c < a.length; c++) this._cameras.splice(this._cameras.indexOf(a[c]), 1) }, BABYLON.PostProcessRenderPipeline.prototype.enableDisplayOnlyPass = function (a, b) { b = BABYLON.Tools.MakeArray(b || this._cameras); var c = null; for (var d in this._renderEffects) if (c = this._renderEffects[d].getPass(a), null != c) break; if (null != c) { for (var d in this._renderEffects) this._renderEffects[d].disable(b); c._name = BABYLON.PostProcessRenderPipeline.PASS_SAMPLER_NAME; for (var e = 0; e < b.length; e++) this._renderEffectsPasses[b[e].name] = this._renderEffectsPasses[b[e].name] || new BABYLON.RenderEffect(this._engine, BABYLON.PostProcessRenderPipeline.PASS_EFFECT_NAME, "BABYLON.DisplayPassPostProcess", 1), this._renderEffectsPasses[b[e].name].emptyPasses(), this._renderEffectsPasses[b[e].name].addPass(c), this._renderEffectsPasses[b[e].name].attachCameras(b[e]) } }, BABYLON.PostProcessRenderPipeline.prototype.disableDisplayOnlyPass = function (a) { a = BABYLON.Tools.MakeArray(a || this._cameras); for (var b = 0; b < a.length; b++) this._renderEffectsPasses[a[b].name] = this._renderEffectsPasses[a[b].name] || new BABYLON.RenderEffect(this._engine, BABYLON.PostProcessRenderPipeline.PASS_EFFECT_NAME, "BABYLON.DisplayPassPostProcess", 1), this._renderEffectsPasses[a[b].name].disable(a[b]); for (var c in this._renderEffects) this._renderEffects[c].enable(a) }, BABYLON.PostProcessRenderPipeline.prototype._update = function () { for (var a in this._renderEffects) this._renderEffects[a]._update(); for (var b = 0; b < this._cameras.length; b++) this._renderEffectsPasses[this._cameras[b]] && this._renderEffectsPasses[this._cameras[b]]._update() }, BABYLON.PostProcessRenderPipeline.PASS_EFFECT_NAME = "passEffect", BABYLON.PostProcessRenderPipeline.PASS_SAMPLER_NAME = "passSampler" }(); var BABYLON = BABYLON || {}; !function () { BABYLON.PostProcessRenderPipelineManager = function () { this._renderPipelines = [] }, BABYLON.PostProcessRenderPipelineManager.prototype.addPipeline = function (a) { this._renderPipelines[a._name] = a }, BABYLON.PostProcessRenderPipelineManager.prototype.update = function () { for (var a in this._renderPipelines) this._renderPipelines[a]._update() }, BABYLON.PostProcessRenderPipelineManager.prototype.attachCamerasToRenderPipeline = function (a, b, c) { var d = this._renderPipelines[a]; d && d.attachCameras(b, c) }, BABYLON.PostProcessRenderPipelineManager.prototype.detachCamerasFromRenderPipeline = function (a, b) { var c = this._renderPipelines[a]; c && c.detachCameras(b) }, BABYLON.PostProcessRenderPipelineManager.prototype.enableEffectInPipeline = function (a, b, c) { var d = this._renderPipelines[a]; d && d.enableEffect(b, c) }, BABYLON.PostProcessRenderPipelineManager.prototype.disableEffectInPipeline = function (a, b, c) { var d = this._renderPipelines[a]; d && d.disableEffect(b, c) }, BABYLON.PostProcessRenderPipelineManager.prototype.enableDisplayOnlyPassInPipeline = function (a, b, c) { var d = this._renderPipelines[a]; d && d.enableDisplayOnlyPass(b, c) }, BABYLON.PostProcessRenderPipelineManager.prototype.disableDisplayOnlyPassInPipeline = function (a, b) { var c = this._renderPipelines[a]; c && c.disableDisplayOnlyPass(b) } }(); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e, f, g) { a.call(this, b, "displayPass", ["passSampler"], ["passSampler"], c, d, e, f, g) } return __extends(b, a), b }(a.PostProcess); a.DisplayPassPostProcess = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(b) { this.frontColor = new a.Color3(1, 1, 1), this.backColor = new a.Color3(.1, .1, .1), this.showBackLines = !0, this.renderList = new a.SmartArray(32), this._scene = b, this._colorShader = new a.ShaderMaterial("colorShader", b, "color", { attributes: ["position"], uniforms: ["worldViewProjection", "color"] }); var c = this._scene.getEngine(), d = a.VertexData.CreateBox(1); this._vb = new a.VertexBuffer(c, d.positions, a.VertexBuffer.PositionKind, !1), this._ib = c.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]) } return b.prototype.reset = function () { this.renderList.reset() }, b.prototype.render = function () { if (0 != this.renderList.length && this._colorShader.isReady()) { var b = this._scene.getEngine(); b.setDepthWrite(!1), this._colorShader._preBind(); for (var c = 0; c < this.renderList.length; c++) { var d = this.renderList.data[c], e = d.getBoundingInfo().boundingBox, f = e.minimum, g = e.maximum, h = g.subtract(f), i = f.add(h.scale(.5)), j = a.Matrix.Scaling(h.x, h.y, h.z).multiply(a.Matrix.Translation(i.x, i.y, i.z)).multiply(d.getWorldMatrix()); b.bindBuffers(this._vb.getBuffer(), this._ib, [3], 12, this._colorShader.getEffect()), this.showBackLines && (b.setDepthFunctionToGreaterOrEqual(), this._colorShader.setColor3("color", this.backColor), this._colorShader.bind(j, d), b.draw(!1, 0, 24)), b.setDepthFunctionToLess(), this._colorShader.setColor3("color", this.frontColor), this._colorShader.bind(j, d), b.draw(!1, 0, 24) } this._colorShader.unbind(), b.setDepthFunctionToLessOrEqual(), b.setDepthWrite(!0) } }, b.prototype.dispose = function () { this._colorShader.dispose(), this._vb.dispose(), this._scene.getEngine()._releaseBuffer(this._ib) }, b }(); a.BoundingBoxRenderer = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { !function (b) { function c(a) { return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24) } function d(a) { return String.fromCharCode(255 & a, a >> 8 & 255, a >> 16 & 255, a >> 24 & 255) } var e = 542327876, f = 131072, g = 4, h = c("DXT1"), i = c("DXT3"), j = c("DXT5"), k = 31, l = 0, m = 1, n = 2, o = 3, p = 4, q = 7, r = 20, s = 21, t = function () { function b() { } return b.GetDDSInfo = function (a) { var b = new Int32Array(a, 0, k), c = 1; return b[n] & f && (c = Math.max(1, b[q])), { width: b[p], height: b[o], mipmapCount: c } }, b.UploadDDSLevels = function (b, c, t, u) { var v, w, x, y, z, A, B, C, D, E, F = new Int32Array(t, 0, k); if (F[l] != e) return void a.Tools.Error("Invalid magic number in DDS header"); if ((F[r] & g) !== g) return void a.Tools.Error("Unsupported format, must contain a FourCC code"); switch (v = F[s]) { case h: w = 8, x = c.COMPRESSED_RGBA_S3TC_DXT1_EXT; break; case i: w = 16, x = c.COMPRESSED_RGBA_S3TC_DXT3_EXT; break; case j: w = 16, x = c.COMPRESSED_RGBA_S3TC_DXT5_EXT; break; default: return void console.error("Unsupported FourCC code:", d(v)) } for (D = 1, F[n] & f && u !== !1 && (D = Math.max(1, F[q])), y = F[p], z = F[o], B = F[m] + 4, E = 0; D > E; ++E) A = Math.max(4, y) / 4 * Math.max(4, z) / 4 * w, C = new Uint8Array(t, B, A), b.compressedTexImage2D(b.TEXTURE_2D, E, x, y, z, 0, C), B += A, y *= .5, z *= .5 }, b }(); b.DDSTools = t }(a.Internals || (a.Internals = {})); a.Internals }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function a(a) { this.length = 0, this.data = new Array(a) } return a.prototype.push = function (a) { this.data[this.length++] = a, this.length > this.data.length && (this.data.length *= 2) }, a.prototype.pushNoDuplicate = function (a) { this.indexOf(a) > -1 || this.push(a) }, a.prototype.sort = function (a) { this.data.sort(a) }, a.prototype.reset = function () { this.length = 0 }, a.prototype.concat = function (a) { if (0 !== a.length) { this.length + a.length > this.data.length && (this.data.length = 2 * (this.length + a.length)); for (var b = 0; b < a.length; b++) this.data[this.length++] = (a.data || a)[b] } }, a.prototype.concatWithNoDuplicate = function (a) { if (0 !== a.length) { this.length + a.length > this.data.length && (this.data.length = 2 * (this.length + a.length)); for (var b = 0; b < a.length; b++) { var c = (a.data || a)[b], d = this.data.indexOf(c); (-1 === d || d >= this.length) && (this.data[this.length++] = c) } } }, a.prototype.indexOf = function (a) { var b = this.data.indexOf(a); return b >= this.length ? -1 : b }, a }(); a.SmartArray = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) {
	var b = function () {
		function b() { this._registeredMeshes = [], this._physicsMaterials = [] } return b.prototype.initialize = function (a) { "undefined" == typeof a && (a = 10), this._world = new CANNON.World, this._world.broadphase = new CANNON.NaiveBroadphase, this._world.solver.iterations = a }, b.prototype._checkWithEpsilon = function (b) { return b < a.PhysicsEngine.Epsilon ? a.PhysicsEngine.Epsilon : b }, b.prototype.runOneStep = function (b) { this._world.step(b); for (var c = 0; c < this._registeredMeshes.length; c++) { var d = this._registeredMeshes[c]; d.isChild || (d.mesh.position.x = d.body.position.x, d.mesh.position.y = d.body.position.z, d.mesh.position.z = d.body.position.y, d.mesh.rotationQuaternion || (d.mesh.rotationQuaternion = new a.Quaternion(0, 0, 0, 1)), d.mesh.rotationQuaternion.x = d.body.quaternion.x, d.mesh.rotationQuaternion.y = d.body.quaternion.z, d.mesh.rotationQuaternion.z = d.body.quaternion.y, d.mesh.rotationQuaternion.w = -d.body.quaternion.w) } }, b.prototype.setGravity = function (a) { this._world.gravity.set(a.x, a.z, a.y) }, b.prototype.registerMesh = function (b, c, d) { switch (this.unregisterMesh(b), b.computeWorldMatrix(!0), c) { case a.PhysicsEngine.SphereImpostor: var e = b.getBoundingInfo().boundingBox, f = e.maximumWorld.x - e.minimumWorld.x, g = e.maximumWorld.y - e.minimumWorld.y, h = e.maximumWorld.z - e.minimumWorld.z; return this._createSphere(Math.max(this._checkWithEpsilon(f), this._checkWithEpsilon(g), this._checkWithEpsilon(h)) / 2, b, d); case a.PhysicsEngine.BoxImpostor: e = b.getBoundingInfo().boundingBox; var i = e.minimumWorld, j = e.maximumWorld, k = j.subtract(i).scale(.5); return this._createBox(this._checkWithEpsilon(k.x), this._checkWithEpsilon(k.z), this._checkWithEpsilon(k.y), b, d); case a.PhysicsEngine.PlaneImpostor: return this._createPlane(b, d); case a.PhysicsEngine.MeshImpostor: var l = b.getVerticesData(a.VertexBuffer.PositionKind), m = b.getIndices(); return this._createConvexPolyhedron(l, m, b, d) } return null }, b.prototype._createSphere = function (a, b, c) { var d = new CANNON.Sphere(a); return c ? this._createRigidBodyFromShape(d, b, c.mass, c.friction, c.restitution) : d }, b.prototype._createBox = function (a, b, c, d, e) { var f = new CANNON.Box(new CANNON.Vec3(a, c, b)); return e ? this._createRigidBodyFromShape(f, d, e.mass, e.friction, e.restitution) : f }, b.prototype._createPlane = function (a, b) { var c = new CANNON.Plane; return b ? this._createRigidBodyFromShape(c, a, b.mass, b.friction, b.restitution) : c }, b.prototype._createConvexPolyhedron = function (b, c, d, e) { var f = [], g = []; d.computeWorldMatrix(!0); for (var h = 0; h < b.length; h += 3) { var i = a.Vector3.Zero(); a.Vector3.TransformNormalFromFloatsToRef(b[h], b[h + 1], b[h + 2], d.getWorldMatrix(), i), f.push(new CANNON.Vec3(i.x, i.z, i.y)) } for (var j = 0; j < c.length; j += 3) g.push([c[j], c[j + 2], c[j + 1]]); var k = new CANNON.ConvexPolyhedron(f, g); return e ? this._createRigidBodyFromShape(k, d, e.mass, e.friction, e.restitution) : k }, b.prototype._addMaterial = function (a, b) { var c, d; for (c = 0; c < this._physicsMaterials.length; c++) if (d = this._physicsMaterials[c], d.friction === a && d.restitution === b) return d; var e = new CANNON.Material; for (e.friction = a, e.restitution = b, this._physicsMaterials.push(e), c = 0; c < this._physicsMaterials.length; c++) { d = this._physicsMaterials[c]; var f = new CANNON.ContactMaterial(d, e, d.friction * e.friction, d.restitution * e.restitution); f.contactEquationStiffness = 1e10, f.contactEquationRegularizationTime = 10, this._world.addContactMaterial(f) } return e }, b.prototype._createRigidBodyFromShape = function (b, c, d, e, f) { var g = null; c.rotationQuaternion && (g = c.rotationQuaternion.clone(), c.rotationQuaternion = new a.Quaternion(0, 0, 0, 1)); var h = this._addMaterial(e, f), i = new CANNON.RigidBody(d, b, h); return g && (i.quaternion.x = g.x, i.quaternion.z = g.y, i.quaternion.y = g.z, i.quaternion.w = -g.w), i.position.set(c.position.x, c.position.z, c.position.y), this._world.add(i), this._registeredMeshes.push({ mesh: c, body: i, material: h }), i }, b.prototype.registerMeshesAsCompound = function (a, b) { for (var c = new CANNON.Compound, d = 0; d < a.length; d++) { var e = a[d].mesh, f = this.registerMesh(e, a[d].impostor); 0 == d ? c.addChild(f, new CANNON.Vec3(0, 0, 0)) : c.addChild(f, new CANNON.Vec3(e.position.x, e.position.z, e.position.y)) } var g = a[0].mesh, h = this._createRigidBodyFromShape(c, g, b.mass, b.friction, b.restitution); return h.parts = a, h }, b.prototype._unbindBody = function (a) { for (var b = 0; b < this._registeredMeshes.length; b++) { var c = this._registeredMeshes[b]; c.body === a && (c.body = null) } }, b.prototype.unregisterMesh = function (a) { for (var b = 0; b < this._registeredMeshes.length; b++) { var c = this._registeredMeshes[b]; if (c.mesh === a) return c.body && (this._world.remove(c.body), this._unbindBody(c.body)), void this._registeredMeshes.splice(b, 1) } }, b.prototype.applyImpulse = function (a, b, c) { for (var d = new CANNON.Vec3(c.x, c.z, c.y), e = new CANNON.Vec3(b.x, b.z, b.y), f = 0; f < this._registeredMeshes.length; f++) { var g = this._registeredMeshes[f]; if (g.mesh === a) return void g.body.applyImpulse(e, d) } }, b.prototype.createLink = function (a, b, c, d) { for (var e = null, f = null, g = 0; g < this._registeredMeshes.length; g++) { var h = this._registeredMeshes[g]; h.mesh === a ? e = h.body : h.mesh === b && (f = h.body) } if (!e || !f) return !1; var i = new CANNON.PointToPointConstraint(e, new CANNON.Vec3(c.x, c.z, c.y), f, new CANNON.Vec3(d.x, d.z, d.y)); return this._world.addConstraint(i), !0 }, b.prototype.dispose = function () {
			for (; this._registeredMeshes.length;) this.unregisterMesh(this._registeredMeshes[0].mesh)
		}, b.prototype.isSupported = function () { return void 0 !== window.CANNON }, b
	}(); a.CannonJSPlugin = b
}(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function () { function a(a) { this._actionManager = a } return a.prototype.isValid = function () { return !0 }, a.prototype._getProperty = function (a) { return this._actionManager._getProperty(a) }, a.prototype._getEffectiveTarget = function (a, b) { return this._actionManager._getEffectiveTarget(a, b) }, a }(); a.Condition = b; var c = function (a) { function b(c, d, e, f, g) { "undefined" == typeof g && (g = b.IsEqual), a.call(this, c), this.propertyPath = e, this.value = f, this.operator = g, this._target = this._getEffectiveTarget(d, this.propertyPath), this._property = this._getProperty(this.propertyPath) } return __extends(b, a), b.prototype.isValid = function () { switch (this.operator) { case b.IsGreater: return this._target[this._property] > this.value; case b.IsLesser: return this._target[this._property] < this.value; case b.IsEqual: case b.IsDifferent: var a; return a = this.value.equals ? this.value.equals(this._target[this._property]) : this.value === this._target[this._property], this.operator === b.IsEqual ? a : !a } return !1 }, b.IsEqual = 0, b.IsDifferent = 1, b.IsGreater = 2, b.IsLesser = 3, b }(b); a.StateCondition = c; var d = function (a) { function b(b, c) { a.call(this, b), this.predicate = c } return __extends(b, a), b.prototype.isValid = function () { return this.predicate() }, b }(b); a.PredicateCondition = d }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function a(a, b) { this.trigger = a, this._nextActiveAction = this, this._condition = b } return a.prototype._prepare = function () { }, a.prototype._executeCurrent = function () { if (this._condition) { var a = this._actionManager.getScene().getRenderId(); if (this._condition._evaluationId === a) { if (!this._condition._currentResult) return } else { if (this._condition._evaluationId = a, !this._condition.isValid()) return void (this._condition._currentResult = !1); this._condition._currentResult = !0 } } this._nextActiveAction.execute(), this._nextActiveAction = this._nextActiveAction._child ? this._nextActiveAction._child : this }, a.prototype.execute = function () { }, a.prototype.then = function (a) { return this._child = a, a._actionManager = this._actionManager, a._prepare(), a }, a.prototype._getProperty = function (a) { return this._actionManager._getProperty(a) }, a.prototype._getEffectiveTarget = function (a, b) { return this._actionManager._getEffectiveTarget(a, b) }, a }(); a.Action = b }(BABYLON || (BABYLON = {})); var BABYLON; !function (a) { var b = function () { function b(a) { this.actions = new Array, this._scene = a } return Object.defineProperty(b, "NoneTrigger", { get: function () { return b._NoneTrigger }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "OnPickTrigger", { get: function () { return b._OnPickTrigger }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "OnPointerOverTrigger", { get: function () { return b._OnPointerOverTrigger }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "OnPointerOutTrigger", { get: function () { return b._OnPointerOutTrigger }, enumerable: !0, configurable: !0 }), Object.defineProperty(b, "OnEveryFrameTrigger", { get: function () { return b._OnEveryFrameTrigger }, enumerable: !0, configurable: !0 }), b.prototype.getScene = function () { return this._scene }, b.prototype.registerAction = function (c) { return c.trigger === b.OnEveryFrameTrigger && this.getScene().actionManager !== this ? (a.Tools.Warn("OnEveryFrameTrigger can only be used with scene.actionManager"), null) : (this.actions.push(c), c._actionManager = this, c._prepare(), c) }, b.prototype.processTrigger = function (a) { for (var b = 0; b < this.actions.length; b++) { var c = this.actions[b]; c.trigger === a && c._executeCurrent() } }, b.prototype._getEffectiveTarget = function (a, b) { for (var c = b.split("."), d = 0; d < c.length - 1; d++) a = a[c[d]]; return a }, b.prototype._getProperty = function (a) { var b = a.split("."); return b[b.length - 1] }, b._NoneTrigger = 0, b._OnPickTrigger = 1, b._OnPointerOverTrigger = 2, b._OnPointerOutTrigger = 3, b._OnEveryFrameTrigger = 4, b }(); a.ActionManager = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (b) { function c(a, c, d, e, f, g, h) { "undefined" == typeof f && (f = 1e3), b.call(this, a, g), this.propertyPath = d, this.value = e, this.duration = f, this.stopOtherAnimations = h, this._target = c } return __extends(c, b), c.prototype._prepare = function () { this._target = this._getEffectiveTarget(this._target, this.propertyPath), this._property = this._getProperty(this.propertyPath) }, c.prototype.execute = function () { var b, c = this._actionManager.getScene(), d = [{ frame: 0, value: this._target[this._property] }, { frame: 100, value: this.value }]; if ("number" == typeof this.value) b = a.Animation.ANIMATIONTYPE_FLOAT; else if (this.value instanceof a.Color3) b = a.Animation.ANIMATIONTYPE_COLOR3; else if (this.value instanceof a.Vector3) b = a.Animation.ANIMATIONTYPE_VECTOR3; else if (this.value instanceof a.Matrix) b = a.Animation.ANIMATIONTYPE_MATRIX; else { if (!(this.value instanceof a.Quaternion)) return void a.Tools.Warn("InterpolateValueAction: Unsupported type (" + typeof this.value + ")"); b = a.Animation.ANIMATIONTYPE_QUATERNION } var e = new a.Animation("InterpolateValueAction", this._property, 100 * (1e3 / this.duration), b, a.Animation.ANIMATIONLOOPMODE_CONSTANT); e.setKeys(d), this.stopOtherAnimations && c.stopAnimation(this._target), c.beginDirectAnimation(this._target, [e], 0, 100) }, c }(a.Action); a.InterpolateValueAction = b }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function (a) { function b(b, c, d, e) { a.call(this, b, e), this.propertyPath = d, this._target = c } return __extends(b, a), b.prototype._prepare = function () { this._target = this._getEffectiveTarget(this._target, this.propertyPath), this._property = this._getProperty(this.propertyPath) }, b.prototype.execute = function () { this._target[this._property] = !this._target[this._property] }, b }(a.Action); a.SwitchBooleanAction = b; var c = function (a) { function b(b, c, d, e, f) { a.call(this, b, f), this.propertyPath = d, this.value = e, this._target = c } return __extends(b, a), b.prototype._prepare = function () { this._target = this._getEffectiveTarget(this._target, this.propertyPath), this._property = this._getProperty(this.propertyPath) }, b.prototype.execute = function () { this._target[this._property] = this.value }, b }(a.Action); a.SetValueAction = c; var d = function (b) { function c(a, c, d, e, f) { b.call(this, a, f), this.propertyPath = d, this.value = e, this._target = c } return __extends(c, b), c.prototype._prepare = function () { this._target = this._getEffectiveTarget(this._target, this.propertyPath), this._property = this._getProperty(this.propertyPath), "number" != typeof this._target[this._property] && a.Tools.Warn("Warning: IncrementValueAction can only be used with number values") }, c.prototype.execute = function () { this._target[this._property] += this.value }, c }(a.Action); a.IncrementValueAction = d; var e = function (a) { function b(b, c, d, e, f, g) { a.call(this, b, g), this.from = d, this.to = e, this.loop = f, this._target = c } return __extends(b, a), b.prototype._prepare = function () { }, b.prototype.execute = function () { var a = this._actionManager.getScene(); a.beginAnimation(this._target, this.from, this.to, this.loop) }, b }(a.Action); a.PlayAnimationAction = e; var f = function (a) { function b(b, c, d) { a.call(this, b, d), this._target = c } return __extends(b, a), b.prototype._prepare = function () { }, b.prototype.execute = function () { var a = this._actionManager.getScene(); a.stopAnimation(this._target) }, b }(a.Action); a.StopAnimationAction = f; var g = function (b) { function c(c, d) { "undefined" == typeof c && (c = a.ActionManager.NoneTrigger), b.call(this, c, d) } return __extends(c, b), c.prototype.execute = function () { }, c }(a.Action); a.DoNothingAction = g; var h = function (a) { function b(b, c, d) { a.call(this, b, d), this.children = c } return __extends(b, a), b.prototype._prepare = function () { for (var a = 0; a < this.children.length; a++) this.children[a]._actionManager = this._actionManager, this.children[a]._prepare() }, b.prototype.execute = function () { for (var a = 0; a < this.children.length; a++) this.children[a].execute() }, b }(a.Action); a.CombineAction = h; var i = function (a) { function b(b, c, d) { a.call(this, b, d), this.func = c } return __extends(b, a), b.prototype.execute = function () { this.func() }, b }(a.Action); a.ExecuteCodeAction = i; var j = function (b) { function c(a, c, d, e) { b.call(this, a, e), this._target = c, this._parent = d } return __extends(c, b), c.prototype._prepare = function () { }, c.prototype.execute = function () { if (this._target.parent !== this._parent) { var b = this._parent.getWorldMatrix().clone(); b.invert(), this._target.position = a.Vector3.TransformCoordinates(this._target.position, b), this._target.parent = this._parent } }, c }(a.Action); a.SetParentAction = j }(BABYLON || (BABYLON = {})); var __extends = this.__extends || function (a, b) { function c() { this.constructor = a } for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]); c.prototype = b.prototype, a.prototype = new c }, BABYLON; !function (a) { var b = function () { function b(b, c, d, e, f) { this.delayLoadState = a.Engine.DELAYLOADSTATE_NONE, this._totalVertices = 0, this._indices = [], this.id = b, this._engine = c, this._meshes = [], d ? this.setAllVerticesData(d, e) : (this._totalVertices = 0, this._indices = []), f && this.applyToMesh(f) } return b.prototype.getEngine = function () { return this._engine }, b.prototype.isReady = function () { return this.delayLoadState === a.Engine.DELAYLOADSTATE_LOADED || this.delayLoadState === a.Engine.DELAYLOADSTATE_NONE }, b.prototype.setAllVerticesData = function (a, b) { a.applyToGeometry(this, b) }, b.prototype.setVerticesData = function (b, c, d) { if (this._vertexBuffers = this._vertexBuffers || {}, this._vertexBuffers[c] && this._vertexBuffers[c].dispose(), this._vertexBuffers[c] = new a.VertexBuffer(this._engine, b, c, d, 0 === this._meshes.length), c === a.VertexBuffer.PositionKind) { var e = this._vertexBuffers[c].getStrideSize(); this._totalVertices = b.length / e; for (var f = a.Tools.ExtractMinAndMax(b, 0, this._totalVertices), g = this._meshes, h = g.length, i = 0; h > i; i++) { var j = g[i]; j._resetPointsArrayCache(), j._boundingInfo = new a.BoundingInfo(f.minimum, f.maximum), j._createGlobalSubMesh() } } }, b.prototype.updateVerticesData = function (b, c, d) { var e = this.getVertexBuffer(b); if (e && (e.update(c), b === a.VertexBuffer.PositionKind)) { var f; if (d) { var g = e.getStrideSize(); this._totalVertices = c.length / g, f = a.Tools.ExtractMinAndMax(c, 0, this._totalVertices) } for (var h = this._meshes, i = h.length, j = 0; i > j; j++) { var k = h[j]; k._resetPointsArrayCache(), d && (k._boundingInfo = new a.BoundingInfo(f.minimum, f.maximum)) } } }, b.prototype.getTotalVertices = function () { return this.isReady() ? this._totalVertices : 0 }, b.prototype.getVerticesData = function (a) { var b = this.getVertexBuffer(a); return b ? b.getData() : null }, b.prototype.getVertexBuffer = function (a) { return this.isReady() ? this._vertexBuffers[a] : null }, b.prototype.getVertexBuffers = function () { return this.isReady() ? this._vertexBuffers : null }, b.prototype.isVerticesDataPresent = function (a) { return this._vertexBuffers ? void 0 !== this._vertexBuffers[a] : this._delayInfo ? -1 !== this._delayInfo.indexOf(a) : !1 }, b.prototype.getVerticesDataKinds = function () { var a = []; if (!this._vertexBuffers && this._delayInfo) for (var b in this._delayInfo) a.push(b); else for (b in this._vertexBuffers) a.push(b); return a }, b.prototype.setIndices = function (a) { this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = a, 0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices)); for (var b = this._meshes, c = b.length, d = 0; c > d; d++) b[d]._createGlobalSubMesh() }, b.prototype.getTotalIndices = function () { return this.isReady() ? this._indices.length : 0 }, b.prototype.getIndices = function () { return this.isReady() ? this._indices : null }, b.prototype.getIndexBuffer = function () { return this.isReady() ? this._indexBuffer : null }, b.prototype.releaseForMesh = function (a) { var b = this._meshes, c = b.indexOf(a); if (-1 !== c) { for (var d in this._vertexBuffers) this._vertexBuffers[d].dispose(); this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer) && (this._indexBuffer = null), b.splice(c, 1), a._geometry = null } }, b.prototype.applyToMesh = function (a) { if (a._geometry !== this) { var b = a._geometry; b && b.releaseForMesh(a); var c = this._meshes; a._geometry = this, a.getScene().pushGeometry(this), c.push(a), this.isReady() ? this._applyToMesh(a) : a._boundingInfo = this._boundingInfo } }, b.prototype._applyToMesh = function (b) { var c = this._meshes.length; for (var d in this._vertexBuffers) if (1 === c && this._vertexBuffers[d].create(), this._vertexBuffers[d]._buffer.references = c, d === a.VertexBuffer.PositionKind) { b._resetPointsArrayCache(); var e = a.Tools.ExtractMinAndMax(this._vertexBuffers[d].getData(), 0, this._totalVertices); b._boundingInfo = new a.BoundingInfo(e.minimum, e.maximum), b._createGlobalSubMesh() } 1 === c && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices)), this._indexBuffer && (this._indexBuffer.references = c) }, b.prototype.load = function (b, c) { var d = this; if (this.delayLoadState !== a.Engine.DELAYLOADSTATE_LOADING) { if (this.isReady()) return void (c && c()); this.delayLoadState = a.Engine.DELAYLOADSTATE_LOADING, b._addPendingData(this), a.Tools.LoadFile(this.delayLoadingFile, function (e) { d._delayLoadingFunction(JSON.parse(e), d), d.delayLoadState = a.Engine.DELAYLOADSTATE_LOADED, d._delayInfo = [], b._removePendingData(d); for (var f = d._meshes, g = f.length, h = 0; g > h; h++) d._applyToMesh(f[h]); c && c() }, function () { }, b.database) } }, b.prototype.dispose = function () { for (var b = this._meshes, c = b.length, d = 0; c > d; d++) this.releaseForMesh(b[d]); this._meshes = []; for (var e in this._vertexBuffers) this._vertexBuffers[e].dispose(); this._vertexBuffers = [], this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = a.Engine.DELAYLOADSTATE_NONE, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null }, b.prototype.copy = function (b) { var c = new a.VertexData; c.indices = []; for (var d = this.getIndices(), e = 0; e < d.length; e++) c.indices.push(d[e]); var f = !1, g = !1; for (var h in this._vertexBuffers) c.set(this.getVerticesData(h), h), g || (f = this.getVertexBuffer(h).isUpdatable(), g = !f); var i = new a.Geometry(b, this._engine, c, f, null); i.delayLoadState = this.delayLoadState, i.delayLoadingFile = this.delayLoadingFile, i._delayLoadingFunction = this._delayLoadingFunction; for (h in this._delayInfo) i._delayInfo = i._delayInfo || [], i._delayInfo.push(h); var j = a.Tools.ExtractMinAndMax(this.getVerticesData(a.VertexBuffer.PositionKind), 0, this.getTotalVertices()); return i._boundingInfo = new a.BoundingInfo(j.minimum, j.maximum), i }, b.ExtractFromMesh = function (a, b) { var c = a._geometry; return c ? c.copy(b) : null }, b.RandomId = function () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (a) { var b = 16 * Math.random() | 0, c = "x" == a ? b : 3 & b | 8; return c.toString(16) }) }, b }(); a.Geometry = b, function (b) { !function (c) { var d = function (a) { function b(b, c, d, e, f) { this._beingRegenerated = !0, this._canBeRegenerated = e, a.call(this, b, c, d, !1, f), this._beingRegenerated = !1 } return __extends(b, a), b.prototype.canBeRegenerated = function () { return this._canBeRegenerated }, b.prototype.regenerate = function () { this._canBeRegenerated && (this._beingRegenerated = !0, this.setAllVerticesData(this._regenerateVertexData(), !1), this._beingRegenerated = !1) }, b.prototype.asNewGeometry = function (b) { return a.prototype.copy.call(this, b) }, b.prototype.setAllVerticesData = function (b) { this._beingRegenerated && a.prototype.setAllVerticesData.call(this, b, !1) }, b.prototype.setVerticesData = function (b, c) { this._beingRegenerated && a.prototype.setVerticesData.call(this, b, c, !1) }, b.prototype._regenerateVertexData = function () { throw new Error("Abstract method") }, b.prototype.copy = function () { throw new Error("Must be overriden in sub-classes.") }, b }(b); c._Primitive = d; var e = function (b) { function c(a, c, d, e, f) { this.size = d, b.call(this, a, c, this._regenerateVertexData(), e, f) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreateBox(this.size) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.size, this.canBeRegenerated(), null) }, c }(d); c.Box = e; var f = function (b) { function c(a, c, d, e, f, g) { this.segments = d, this.diameter = e, b.call(this, a, c, this._regenerateVertexData(), f, g) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreateSphere(this.segments, this.diameter) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.segments, this.diameter, this.canBeRegenerated(), null) }, c }(d); c.Sphere = f; var g = function (b) { function c(a, c, d, e, f, g, h, i) { this.height = d, this.diameterTop = e, this.diameterBottom = f, this.tessellation = g, b.call(this, a, c, this._regenerateVertexData(), h, i) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreateCylinder(this.height, this.diameterTop, this.diameterBottom, this.tessellation) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.height, this.diameterTop, this.diameterBottom, this.tessellation, this.canBeRegenerated(), null) }, c }(d); c.Cylinder = g; var h = function (b) { function c(a, c, d, e, f, g, h) { this.diameter = d, this.thickness = e, this.tessellation = f, b.call(this, a, c, this._regenerateVertexData(), g, h) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreateTorus(this.diameter, this.thickness, this.tessellation) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.diameter, this.thickness, this.tessellation, this.canBeRegenerated(), null) }, c }(d); c.Torus = h; var i = function (b) { function c(a, c, d, e, f, g, h) { this.width = d, this.height = e, this.subdivisions = f, b.call(this, a, c, this._regenerateVertexData(), g, h) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreateGround(this.width, this.height, this.subdivisions) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.width, this.height, this.subdivisions, this.canBeRegenerated(), null) }, c }(d); c.Ground = i; var j = function (b) { function c(a, c, d, e, f) { this.size = d, b.call(this, a, c, this._regenerateVertexData(), e, f) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreatePlane(this.size) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.size, this.canBeRegenerated(), null) }, c }(d); c.Plane = j; var k = function (b) { function c(a, c, d, e, f, g, h, i, j, k) { this.radius = d, this.tube = e, this.radialSegments = f, this.tubularSegments = g, this.p = h, this.q = i, b.call(this, a, c, this._regenerateVertexData(), j, k) } return __extends(c, b), c.prototype._regenerateVertexData = function () { return a.VertexData.CreateTorusKnot(this.radius, this.tube, this.radialSegments, this.tubularSegments, this.p, this.q) }, c.prototype.copy = function (a) { return new c(a, this.getEngine(), this.radius, this.tube, this.radialSegments, this.tubularSegments, this.p, this.q, this.canBeRegenerated(), null) }, c }(d); c.TorusKnot = k }(b.Primitives || (b.Primitives = {})); b.Primitives }(a.Geometry || (a.Geometry = {})); var b = a.Geometry }(BABYLON || (BABYLON = {}));